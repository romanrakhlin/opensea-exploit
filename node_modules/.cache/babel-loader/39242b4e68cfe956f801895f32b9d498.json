{"ast":null,"code":"import * as ethUtil from \"ethereumjs-util\";\nimport * as _ from \"lodash\";\n\nasync function signTypedDataAsync(provider, message, signerAddress) {\n  let signature;\n  return new Promise((resolve, reject) => {\n    const callback = async (err, result) => {\n      console.log(err);\n      if (err) reject(err);\n\n      if (result.error) {\n        reject(result.error.message);\n      }\n\n      ; // eslint-disable-next-line prefer-promise-reject-errors\n\n      if (result.error) return reject(\"ERROR\", result); // console.log(result);\n      // const d = result.result;\n      // let v = d.slice(-2);\n      // let r = d.slice(2, -66);\n      // let s = d.slice(-66, -2);\n      // let actualsignature = v + r + s + '03';\n\n      resolve(parseSignatureHex(result.result));\n    };\n\n    const stringified = JSON.stringify({ ...message\n    });\n\n    try {\n      // Using sign typed data V4 works with a stringified message, used by browser providers i.e. Metamask\n      provider.sendAsync({\n        method: \"eth_signTypedData_v4\",\n        params: [signerAddress, stringified],\n        from: signerAddress,\n        id: new Date().getTime()\n      }, callback);\n    } catch (error) {\n      console.log(error); // Fallback to normal sign typed data for node providers, without using stringified message\n      // https://github.com/coinbase/coinbase-wallet-sdk/issues/60\n\n      provider.sendAsync({\n        method: \"eth_signTypedData\",\n        params: [signerAddress, message],\n        from: signerAddress,\n        id: new Date().getTime()\n      }, callback);\n    }\n\n    ;\n  });\n}\n\n; // sourced from 0x.js:\n// https://github.com/ProjectWyvern/wyvern-js/blob/39999cb93ce5d80ea90b4382182d1bd4339a9c6c/src/utils/signature_utils.ts\n\nasync function parseSignatureHex(signature) {\n  // HACK: There is no consensus on whether the signatureHex string should be formatted as\n  // v + r + s OR r + s + v, and different clients (even different versions of the same client)\n  // return the signature params in different orders. In order to support all client implementations,\n  // we parse the signature in both ways, and evaluate if either one is a valid signature.\n  const validVParamValues = [27, 28];\n\n  const ecSignatureRSV = _parseSignatureHexAsRSV(signature);\n\n  if (_.includes(validVParamValues, ecSignatureRSV.v)) {\n    return ecSignatureRSV;\n  }\n\n  ; // For older clients\n\n  const ecSignatureVRS = _parseSignatureHexAsVRS(signature);\n\n  if (_.includes(validVParamValues, ecSignatureVRS.v)) {\n    return ecSignatureVRS;\n  }\n\n  ;\n  throw new Error(\"Invalid signature\");\n\n  function _parseSignatureHexAsVRS(signatureHex) {\n    const signatureBuffer = ethUtil.toBuffer(signatureHex);\n    let v = signatureBuffer[0];\n\n    if (v < 27) {\n      v += 27;\n    }\n\n    const r = signatureBuffer.slice(1, 33);\n    const s = signatureBuffer.slice(33, 65);\n    const ecSignature = {\n      v,\n      r: ethUtil.bufferToHex(r),\n      s: ethUtil.bufferToHex(s)\n    };\n    return ecSignature;\n  }\n\n  ;\n\n  function _parseSignatureHexAsRSV(signatureHex) {\n    const {\n      v,\n      r,\n      s\n    } = ethUtil.fromRpcSig(signatureHex);\n    const ecSignature = {\n      v,\n      r: ethUtil.bufferToHex(r),\n      s: ethUtil.bufferToHex(s)\n    };\n    return ecSignature;\n  }\n\n  ;\n}\n\n;\nexport default signTypedDataAsync;","map":{"version":3,"names":["ethUtil","_","signTypedDataAsync","provider","message","signerAddress","signature","Promise","resolve","reject","callback","err","result","console","log","error","parseSignatureHex","stringified","JSON","stringify","sendAsync","method","params","from","id","Date","getTime","validVParamValues","ecSignatureRSV","_parseSignatureHexAsRSV","includes","v","ecSignatureVRS","_parseSignatureHexAsVRS","Error","signatureHex","signatureBuffer","toBuffer","r","slice","s","ecSignature","bufferToHex","fromRpcSig"],"sources":["/Users/romanrakhlin/Dropbox/Mac/Desktop/opensea-exploit/src/opensea-sdk/helpers/SignTypedDataAsync.js"],"sourcesContent":["import * as ethUtil from \"ethereumjs-util\";\nimport * as _ from \"lodash\";\n\nasync function signTypedDataAsync(provider, message, signerAddress) {\n    let signature;\n    return new Promise((resolve, reject) => {\n        const callback = async (err, result) => {\n            console.log(err);\n            if (err) reject(err);\n            if (result.error) {\n                reject(result.error.message);\n            };\n\n            // eslint-disable-next-line prefer-promise-reject-errors\n            if (result.error) return reject(\"ERROR\", result);\n            // console.log(result);\n            // const d = result.result;\n\n            // let v = d.slice(-2);\n            // let r = d.slice(2, -66);\n            // let s = d.slice(-66, -2);\n\n            // let actualsignature = v + r + s + '03';\n            resolve(parseSignatureHex(result.result));\n        };\n\n        const stringified = JSON.stringify({ ...message });\n\n        try {\n            // Using sign typed data V4 works with a stringified message, used by browser providers i.e. Metamask\n            provider.sendAsync({\n                method: \"eth_signTypedData_v4\",\n                params: [signerAddress, stringified],\n                from: signerAddress,\n                id: new Date().getTime(),\n            }, callback);\n        } catch (error) {\n            console.log(error);\n\n            // Fallback to normal sign typed data for node providers, without using stringified message\n            // https://github.com/coinbase/coinbase-wallet-sdk/issues/60\n            provider.sendAsync({\n                method: \"eth_signTypedData\",\n                params: [signerAddress, message],\n                from: signerAddress,\n                id: new Date().getTime(),\n            }, callback);\n        };\n    });\n};\n\n// sourced from 0x.js:\n// https://github.com/ProjectWyvern/wyvern-js/blob/39999cb93ce5d80ea90b4382182d1bd4339a9c6c/src/utils/signature_utils.ts\nasync function parseSignatureHex(signature) {\n    // HACK: There is no consensus on whether the signatureHex string should be formatted as\n    // v + r + s OR r + s + v, and different clients (even different versions of the same client)\n    // return the signature params in different orders. In order to support all client implementations,\n    // we parse the signature in both ways, and evaluate if either one is a valid signature.\n    const validVParamValues = [27, 28];\n\n    const ecSignatureRSV = _parseSignatureHexAsRSV(signature);\n    if (_.includes(validVParamValues, ecSignatureRSV.v)) {\n        return ecSignatureRSV;\n    };\n\n    // For older clients\n    const ecSignatureVRS = _parseSignatureHexAsVRS(signature);\n    if (_.includes(validVParamValues, ecSignatureVRS.v)) {\n        return ecSignatureVRS;\n    };\n\n    throw new Error(\"Invalid signature\");\n\n    function _parseSignatureHexAsVRS(signatureHex) {\n        const signatureBuffer = ethUtil.toBuffer(signatureHex);\n        let v = signatureBuffer[0];\n\n        if (v < 27) {\n            v += 27;\n        }\n\n        const r = signatureBuffer.slice(1, 33);\n        const s = signatureBuffer.slice(33, 65);\n        const ecSignature = {\n            v,\n            r: ethUtil.bufferToHex(r),\n            s: ethUtil.bufferToHex(s),\n        };\n\n        return ecSignature;\n    };\n\n    function _parseSignatureHexAsRSV(signatureHex) {\n        const { v, r, s } = ethUtil.fromRpcSig(signatureHex);\n        const ecSignature = {\n            v,\n            r: ethUtil.bufferToHex(r),\n            s: ethUtil.bufferToHex(s),\n        };\n\n        return ecSignature;\n    };\n};\n\nexport default signTypedDataAsync;"],"mappings":"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"},"metadata":{},"sourceType":"module"}