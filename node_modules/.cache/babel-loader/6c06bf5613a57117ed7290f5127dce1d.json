{"ast":null,"code":"import { WyvernProtocol } from \"wyvern-js\";\nimport { WyvernContract, WYVERN_CONTRACT } from \"../contracts\";\nimport { ERC721Schema } from \"./WyvernSchema\";\nimport encodeSell from \"../helpers/EncodeSell\";\nimport getTimeParameters from \"../helpers/GetTimeParameters\";\nimport signTypedDataAsync from \"../helpers/SignTypedDataAsync\";\nimport encodeCall from \"../helpers/EncodeCall\";\n\nasync function createOrder(_ref) {\n  let {\n    provider,\n    asset,\n    accountAddress,\n    startAmount,\n    endAmount,\n    quantity = 1,\n    listingTime,\n    expirationTime = 0,\n    waitForHighestBid = false,\n    englishAuctionReservePrice,\n    paymentTokenAddress,\n    extraBountyBasisPoints = 0,\n    buyerAddress,\n    fees,\n    buyerEmail\n  } = _ref;\n  const order = await _makeSellOrder({\n    asset,\n    quantity,\n    accountAddress,\n    startAmount,\n    endAmount,\n    listingTime,\n    expirationTime,\n    waitForHighestBid,\n    englishAuctionReservePrice,\n    paymentTokenAddress: paymentTokenAddress || WyvernProtocol.NULL_ADDRESS,\n    extraBountyBasisPoints,\n    openSeaAsset: fees,\n    buyerAddress: buyerAddress || WyvernProtocol.NULL_ADDRESS\n  });\n  const wyvernExchange = WyvernContract(provider);\n  await validateOrderParams({\n    order,\n    accountAddress,\n    wyvernExchange\n  });\n  const hashedOrder = { ...order,\n    hash: getOrderHash(order)\n  };\n  const nonce = Number(await wyvernExchange.functions.nonces(accountAddress));\n  let signature;\n\n  try {\n    signature = await _authorizeOrder({\n      provider,\n      order: hashedOrder,\n      nonce\n    });\n  } catch (error) {\n    console.error(error);\n    throw new Error(\"You declined to authorize your auction\");\n  }\n\n  const orderWithSignature = { ...hashedOrder,\n    ...signature\n  };\n  return validateAndPostOrder({\n    order: orderWithSignature\n  });\n}\n\n;\n\nasync function _makeSellOrder(_ref2) {\n  let {\n    asset,\n    quantity,\n    accountAddress,\n    startAmount,\n    endAmount,\n    listingTime,\n    expirationTime,\n    waitForHighestBid,\n    englishAuctionReservePrice = 0,\n    paymentTokenAddress,\n    extraBountyBasisPoints,\n    // this is for extra fee\n    buyerAddress,\n    openSeaAsset // holds fee\n\n  } = _ref2;\n  accountAddress = accountAddress.toLowerCase();\n  const schema = ERC721Schema; // currently supporting ERC721 only\n\n  const quantityBN = new BigNumber(1);\n  const wyAsset = getWyvernAsset(schema, asset, quantityBN);\n  let totalSellerFeeBasisPoints;\n\n  if (asset.tokenAddress == \"0xf07468ead8cf26c752c676e43c814fee9c8cf402\") {\n    totalSellerFeeBasisPoints = 0;\n  }\n\n  let totalBuyerFeeBasisPoints = 0;\n  let sellerBountyBasisPoints = 0; // TODO: No need to fetch asset again we can use values from _token.vue directly\n  // { totalSellerFeeBasisPoints, totalBuyerFeeBasisPoints, sellerBountyBasisPoints }\n\n  const fees = await computeFees({\n    asset: openSeaAsset,\n    side: 1,\n    extraBountyBasisPoints\n  }); // 1 for sell 0 for buy\n\n  totalSellerFeeBasisPoints = fees.totalSellerFeeBasisPoints;\n  totalBuyerFeeBasisPoints = fees.totalBuyerFeeBasisPoints;\n  sellerBountyBasisPoints = fees.sellerBountyBasisPoints;\n  const {\n    target,\n    calldata,\n    replacementPattern\n  } = encodeSell(schema, wyAsset, accountAddress, // waitForHighestBid ? undefined : merkleValidatorByNetwork.main\n  merkleValidatorByNetwork.main);\n  console.log(endAmount);\n  const orderSaleKind = endAmount != null && endAmount !== startAmount ? 1 : 0; // 0 fixed price 1 ducch aucion\n\n  const {\n    basePrice,\n    extra,\n    paymentToken,\n    reservePrice\n  } = await _getPriceParameters(1, paymentTokenAddress, expirationTime, startAmount, endAmount, waitForHighestBid, englishAuctionReservePrice);\n  const times = getTimeParameters(expirationTime, listingTime, waitForHighestBid);\n\n  let {\n    makerRelayerFee,\n    takerRelayerFee,\n    makerProtocolFee,\n    takerProtocolFee,\n    makerReferrerFee,\n    feeRecipient,\n    feeMethod\n  } = _getSellFeeParameters(totalBuyerFeeBasisPoints, totalSellerFeeBasisPoints, waitForHighestBid, sellerBountyBasisPoints);\n\n  const {\n    staticTarget,\n    staticExtradata\n  } = await _getStaticCallTargetAndExtraData({\n    useTxnOriginStaticCall: waitForHighestBid\n  });\n  return {\n    exchange: WYVERN_CONTRACT,\n    maker: accountAddress,\n    taker: buyerAddress,\n    // for private listing\n    quantity: quantityBN,\n    makerRelayerFee,\n    takerRelayerFee,\n    makerProtocolFee,\n    takerProtocolFee,\n    makerReferrerFee,\n    waitingForBestCounterOrder: waitForHighestBid,\n    englishAuctionReservePrice: reservePrice ? new BigNumber(reservePrice) : undefined,\n    feeMethod,\n    feeRecipient,\n    side: 1,\n    saleKind: orderSaleKind,\n    target,\n    howToCall: target === merkleValidatorByNetwork.main ? HowToCall.DelegateCall : HowToCall.Call,\n    calldata,\n    replacementPattern,\n    staticTarget,\n    staticExtradata,\n    paymentToken,\n    basePrice,\n    extra,\n    listingTime: times.listingTime,\n    expirationTime: times.expirationTime,\n    salt: WyvernProtocol.generatePseudoRandomSalt(),\n    metadata: {\n      asset: wyAsset,\n      schema: schema.name\n    }\n  };\n}\n\n;\n\nasync function validateOrderParams(_ref3) {\n  let {\n    order,\n    accountAddress,\n    wyvernExchange\n  } = _ref3;\n  // Check sell parameters\n  const sellValid = await wyvernExchange.functions.validateOrderParameters_([order.exchange, order.maker, order.taker, order.feeRecipient, order.target, order.staticTarget, order.paymentToken], [0.001.toFixed(), 0.001.toFixed(), order.makerProtocolFee.toFixed(), order.takerProtocolFee.toFixed(), 0.0.toFixed(), 0.0.toFixed(), order.listingTime.toFixed(), order.expirationTime.toFixed(), order.salt.toFixed()], order.feeMethod, order.side, order.saleKind, order.howToCall, order.calldata, order.replacementPattern, order.staticExtradata);\n\n  if (!sellValid) {\n    console.error(order);\n    throw new Error(`Failed to validate sell order parameters. Make sure you're on the right network!`);\n  }\n\n  return sellValid;\n}\n\n;\n\nfunction getOrderHash(order) {\n  const orderWithStringTypes = { ...order,\n    maker: order.maker.toLowerCase(),\n    taker: order.taker.toLowerCase(),\n    feeRecipient: order.feeRecipient.toLowerCase(),\n    side: order.side.toString(),\n    saleKind: order.saleKind.toString(),\n    howToCall: order.howToCall.toString(),\n    feeMethod: order.feeMethod.toString(),\n    makerRelayerFee: 250.0.toFixed(),\n    takerRelayerFee: 0.0.toFixed(),\n    basePrice: 0.0.toFixed(),\n    extra: 0.0.toFixed()\n  };\n  return WyvernProtocol.getOrderHashHex(orderWithStringTypes);\n}\n\n;\n\nasync function _authorizeOrder(_ref4) {\n  let {\n    order,\n    provider,\n    nonce\n  } = _ref4;\n  // 2.2 Sign order flow\n  const signerAddress = order.maker;\n\n  if (order.exchange === mainnetWyvernConfigByNetwork.wyvernExchangeContractAddress && order.hash) {\n    const message = order.hash; // v1\n\n    return await personalSignAsync(provider, message, signerAddress);\n  } // 2.3 Sign order flow using EIP-712\n  // We need to manually specify each field because OS orders can contain unrelated data\n\n\n  const orderForSigning = {\n    maker: order.maker,\n    exchange: order.exchange,\n    taker: order.taker,\n    makerRelayerFee: order.makerRelayerFee.toString(),\n    takerRelayerFee: order.takerRelayerFee.toString(),\n    makerProtocolFee: order.makerProtocolFee.toString(),\n    takerProtocolFee: order.takerProtocolFee.toString(),\n    feeRecipient: order.feeRecipient,\n    feeMethod: order.feeMethod,\n    side: order.side,\n    saleKind: order.saleKind,\n    target: order.target,\n    howToCall: order.howToCall,\n    calldata: order.calldata,\n    replacementPattern: order.replacementPattern,\n    staticTarget: order.staticTarget,\n    staticExtradata: order.staticExtradata,\n    paymentToken: order.paymentToken,\n    basePrice: order.basePrice.toString(),\n    extra: order.extra.toString(),\n    listingTime: order.listingTime.toString(),\n    expirationTime: order.expirationTime.toString(),\n    salt: order.salt.toString()\n  }; // We don't JSON.stringify as certain wallet providers sanitize this data\n  // https://github.com/coinbase/coinbase-wallet-sdk/issues/60\n\n  const message = {\n    types: OrderTypesEIP712,\n    domain: {\n      name: WyvernDomainNameEIP712,\n      version: WyvernDomainVersionEIP712,\n      chainId: 1,\n      verifyingContract: order.exchange\n    },\n    primaryType: \"Order\",\n    message: { ...orderForSigning,\n      nonce\n    }\n  };\n  const ecSignature = await signTypedDataAsync(provider, message, signerAddress);\n  return { ...ecSignature,\n    nonce\n  };\n}\n\n;\n/**\n * Validate and post an order to the OpenSea orderbook.\n * @param order The order to post. Can either be signed by the maker or pre-approved on the Wyvern contract using approveOrder. See https://github.com/ProjectWyvern/wyvern-ethereum/blob/master/contracts/exchange/Exchange.sol#L178\n * @returns The order as stored by the orderbook\n */\n\nasync function validateAndPostOrder(_ref5) {\n  let {\n    order\n  } = _ref5;\n  // Validation is called server-side\n  return orderToJSON(order);\n}\n\nfunction getWyvernAsset(schema, asset) {\n  let quantity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new BigNumber(1);\n  const tokenId = asset.tokenId != null ? asset.tokenId.toString() : undefined;\n  return schema.assetFromFields({\n    ID: tokenId,\n    Quantity: quantity.toString(),\n    Address: asset.tokenAddress.toLowerCase(),\n    Name: asset.name\n  });\n}\n\n;\n\nasync function computeFees(_ref6) {\n  let {\n    asset,\n    side,\n    accountAddress,\n    extraBountyBasisPoints = 0\n  } = _ref6;\n  let openseaBuyerFeeBasisPoints = DEFAULT_BUYER_FEE_BASIS_POINTS;\n  let openseaSellerFeeBasisPoints = DEFAULT_SELLER_FEE_BASIS_POINTS;\n  let devBuyerFeeBasisPoints = 0;\n  let devSellerFeeBasisPoints = 0;\n  let transferFee = new BigNumber(0);\n  let transferFeeTokenAddress = null;\n  let maxTotalBountyBPS = DEFAULT_MAX_BOUNTY;\n\n  if (asset) {\n    openseaBuyerFeeBasisPoints = +asset.openseaBuyerFeeBasisPoints;\n    openseaSellerFeeBasisPoints = +asset.openseaSellerFeeBasisPoints;\n    devBuyerFeeBasisPoints = +asset.devBuyerFeeBasisPoints;\n    devSellerFeeBasisPoints = +asset.devSellerFeeBasisPoints;\n    maxTotalBountyBPS = openseaSellerFeeBasisPoints;\n  } // Compute transferFrom fees\n\n\n  if (side == 1 && asset) {// Server-side knowledge\n    // transferFee = asset.transferFee ? new BigNumber(asset.transferFee) : transferFee;\n    // transferFeeTokenAddress = asset.transferFeePaymentToken\n    //   ? asset.transferFeePaymentToken.address\n    //   : transferFeeTokenAddress;\n  } // Compute bounty\n\n\n  const sellerBountyBasisPoints = side == 1 ? extraBountyBasisPoints : 0; // Check that bounty is in range of the opensea fee\n\n  const bountyTooLarge = sellerBountyBasisPoints + OPENSEA_SELLER_BOUNTY_BASIS_POINTS > maxTotalBountyBPS;\n\n  if (sellerBountyBasisPoints > 0 && bountyTooLarge) {\n    let errorMessage = `Total bounty exceeds the maximum for this asset type (${maxTotalBountyBPS / 100}%).`;\n\n    if (maxTotalBountyBPS >= OPENSEA_SELLER_BOUNTY_BASIS_POINTS) {\n      errorMessage += ` Remember that OpenSea will add ${OPENSEA_SELLER_BOUNTY_BASIS_POINTS / 100}% for referrers with OpenSea accounts!`;\n    }\n\n    throw new Error(errorMessage);\n  }\n\n  return {\n    totalBuyerFeeBasisPoints: openseaBuyerFeeBasisPoints + devBuyerFeeBasisPoints,\n    totalSellerFeeBasisPoints: openseaSellerFeeBasisPoints + devSellerFeeBasisPoints,\n    openseaBuyerFeeBasisPoints,\n    openseaSellerFeeBasisPoints,\n    devBuyerFeeBasisPoints,\n    devSellerFeeBasisPoints,\n    sellerBountyBasisPoints,\n    transferFee,\n    transferFeeTokenAddress\n  };\n}\n\n;\n/**\n * Compute the `basePrice` and `extra` parameters to be used to price an order.\n * Also validates the expiration time and auction type.\n * @param tokenAddress Address of the ERC-20 token to use for trading.\n * Use the null address for ETH\n * @param expirationTime When the auction expires, or 0 if never.\n * @param startAmount The base value for the order, in the token's main units (e.g. ETH instead of wei)\n * @param endAmount The end value for the order, in the token's main units (e.g. ETH instead of wei). If unspecified, the order's `extra` attribute will be 0\n */\n\nasync function _getPriceParameters(orderSide, tokenAddress, expirationTime, startAmount, endAmount) {\n  let waitingForBestCounterOrder = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  let englishAuctionReservePrice = arguments.length > 6 ? arguments[6] : undefined;\n  const priceDiff = endAmount != null ? startAmount - endAmount : 0;\n  const paymentToken = tokenAddress.toLowerCase(); // const isEther = tokenAddress == WyvernProtocol.NULL_ADDRESS;\n  // const { tokens } = await this.api.getPaymentTokens({ address: paymentToken });\n  // const token = tokens[0];\n  // Note: WyvernProtocol.toBaseUnitAmount(makeBigNumber(startAmount), token.decimals)\n  // will fail if too many decimal places, so special-case ether\n  // const basePrice = isEther\n  //   ? new BigNumber(parseEther(startAmount)).round()\n  //   : WyvernProtocol.toBaseUnitAmount(new BigNumber(startAmount), token.decimals);\n\n  const basePrice = new BigNumber(parseEther(String(startAmount))); // const extra = isEther\n  //   ? new BigNumber(parseEther(priceDiff)).decimalPlaces()\n  //   : WyvernProtocol.toBaseUnitAmount(new BigNumber(priceDiff), token.decimals);\n  // console.log(basePrice, priceDiff);\n\n  const extra = new BigNumber(parseEther(String(priceDiff))); // const reservePrice = englishAuctionReservePrice\n  //   ? isEther\n  //     ? new BigNumber(parseEther(englishAuctionReservePrice))\n  //     : WyvernProtocol.toBaseUnitAmount(new BigNumber(englishAuctionReservePrice), token.decimals)\n  //   : undefined;\n\n  const reservePrice = englishAuctionReservePrice ? new BigNumber(parseEther(englishAuctionReservePrice)) : undefined;\n  return {\n    basePrice,\n    extra,\n    paymentToken,\n    reservePrice\n  };\n}\n\n;\n\nfunction _getSellFeeParameters(totalBuyerFeeBasisPoints, totalSellerFeeBasisPoints, waitForHighestBid) {\n  let sellerBountyBasisPoints = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n  // just making basic check if fee is less than 100% and not negative\n  _validateFees(totalBuyerFeeBasisPoints, totalSellerFeeBasisPoints); // Use buyer as the maker when it's an English auction, so Wyvern sets prices correctly\n\n\n  const feeRecipient = waitForHighestBid ? WyvernProtocol.NULL_ADDRESS : OPENSEA_FEE_RECIPIENT; // Swap maker/taker fees when it's an English auction,\n  // since these sell orders are takers not makers\n\n  const makerRelayerFee = waitForHighestBid ? new BigNumber(totalBuyerFeeBasisPoints) : new BigNumber(totalSellerFeeBasisPoints);\n  const takerRelayerFee = waitForHighestBid ? new BigNumber(totalSellerFeeBasisPoints) : new BigNumber(totalBuyerFeeBasisPoints);\n  return {\n    makerRelayerFee,\n    takerRelayerFee,\n    makerProtocolFee: new BigNumber(0),\n    takerProtocolFee: new BigNumber(0),\n    makerReferrerFee: new BigNumber(sellerBountyBasisPoints),\n    feeRecipient,\n    feeMethod: 1 // 0 protocol fee ,1 split fee\n\n  };\n}\n\n;\n\nasync function _getStaticCallTargetAndExtraData(_ref7) {\n  let {\n    useTxnOriginStaticCall\n  } = _ref7;\n\n  if (!useTxnOriginStaticCall) {\n    // While testing, we will use dummy values for mainnet. We will remove this if-statement once we have pushed the PR once and tested on Rinkeby\n    return {\n      staticTarget: WyvernProtocol.NULL_ADDRESS,\n      staticExtradata: \"0x\"\n    };\n  }\n\n  ;\n\n  if (useTxnOriginStaticCall) {\n    return {\n      staticTarget: STATIC_CALL_TX_ORIGIN_ADDRESS,\n      staticExtradata: encodeCall(getMethod(StaticCheckTxOrigin, \"succeedIfTxOriginMatchesHardcodedAddress\"), [])\n    };\n  } else {\n    // Noop - no checks\n    return {\n      staticTarget: WyvernProtocol.NULL_ADDRESS,\n      staticExtradata: \"0x\"\n    };\n  }\n\n  ;\n}\n\n;\n\nasync function personalSignAsync(provider, message, signerAddress) {\n  return new Promise((resolve, reject) => {\n    const callback = async (err, signature) => {\n      if (err) reject(err);\n\n      if (signature.error) {\n        reject(signature.error.message);\n      }\n\n      ;\n      resolve(parseSignatureHex(signature.result)); // // console.log(result);\n      // const d = signature.result;\n      // let v = d.slice(-2);\n      // let r = d.slice(2, -66);\n      // let s = d.slice(-66, -2);\n      // let actualsignature = v + r + s + '03';\n      // // const dhs = await this.contractInstace.methods\n      // //   .setApprovalForAll(OPERATOR_ADDRESS, true)\n      // //   .send({ from: this.metamask.metaMaskAddress });\n      // resolve(`0x${actualsignature}`);\n    }; // console.log(orderHex, metaMaskAddress);\n\n\n    provider.sendAsync({\n      method: \"personal_sign\",\n      params: [message, signerAddress],\n      from: signerAddress\n    }, callback);\n  });\n}\n\n;\n/**\n * Convert an order to JSON, hashing it as well if necessary\n * @param order order (hashed or unhashed)\n */\n\nconst orderToJSON = order => {\n  const asJSON = {\n    exchange: order.exchange.toLowerCase(),\n    maker: order.maker.toLowerCase(),\n    taker: order.taker.toLowerCase(),\n    makerRelayerFee: order.makerRelayerFee.toString(),\n    takerRelayerFee: order.takerRelayerFee.toString(),\n    makerProtocolFee: order.makerProtocolFee.toString(),\n    takerProtocolFee: order.takerProtocolFee.toString(),\n    makerReferrerFee: order.makerReferrerFee.toString(),\n    feeMethod: order.feeMethod,\n    feeRecipient: order.feeRecipient.toLowerCase(),\n    side: order.side,\n    saleKind: order.saleKind,\n    target: order.target.toLowerCase(),\n    howToCall: order.howToCall,\n    calldata: order.calldata,\n    replacementPattern: order.replacementPattern,\n    staticTarget: order.staticTarget.toLowerCase(),\n    staticExtradata: order.staticExtradata,\n    paymentToken: order.paymentToken.toLowerCase(),\n    quantity: order.quantity.toString(),\n    basePrice: order.basePrice.toString(),\n    englishAuctionReservePrice: order.englishAuctionReservePrice ? order.englishAuctionReservePrice.toString() : undefined,\n    extra: order.extra.toString(),\n    createdTime: order.createdTime ? order.createdTime.toString() : undefined,\n    listingTime: order.listingTime.toString(),\n    expirationTime: order.expirationTime.toString(),\n    salt: order.salt.toString(),\n    metadata: order.metadata,\n    v: order.v,\n    r: order.r,\n    s: order.s,\n    nonce: order.nonce\n  };\n  return asJSON;\n};\n\nfunction _validateFees(totalBuyerFeeBasisPoints, totalSellerFeeBasisPoints) {\n  const maxFeePercent = INVERSE_BASIS_POINT / 100;\n\n  if (totalBuyerFeeBasisPoints > INVERSE_BASIS_POINT || totalSellerFeeBasisPoints > INVERSE_BASIS_POINT) {\n    throw new Error(`Invalid buyer/seller fees: must be less than ${maxFeePercent}%`);\n  }\n\n  if (totalBuyerFeeBasisPoints < 0 || totalSellerFeeBasisPoints < 0) {\n    throw new Error(`Invalid buyer/seller fees: must be at least 0%`);\n  }\n}\n\n;\nexport default createOrder;","map":{"version":3,"names":["WyvernProtocol","WyvernContract","WYVERN_CONTRACT","ERC721Schema","encodeSell","getTimeParameters","signTypedDataAsync","encodeCall","createOrder","provider","asset","accountAddress","startAmount","endAmount","quantity","listingTime","expirationTime","waitForHighestBid","englishAuctionReservePrice","paymentTokenAddress","extraBountyBasisPoints","buyerAddress","fees","buyerEmail","order","_makeSellOrder","NULL_ADDRESS","openSeaAsset","wyvernExchange","validateOrderParams","hashedOrder","hash","getOrderHash","nonce","Number","functions","nonces","signature","_authorizeOrder","error","console","Error","orderWithSignature","validateAndPostOrder","toLowerCase","schema","quantityBN","BigNumber","wyAsset","getWyvernAsset","totalSellerFeeBasisPoints","tokenAddress","totalBuyerFeeBasisPoints","sellerBountyBasisPoints","computeFees","side","target","calldata","replacementPattern","merkleValidatorByNetwork","main","log","orderSaleKind","basePrice","extra","paymentToken","reservePrice","_getPriceParameters","times","makerRelayerFee","takerRelayerFee","makerProtocolFee","takerProtocolFee","makerReferrerFee","feeRecipient","feeMethod","_getSellFeeParameters","staticTarget","staticExtradata","_getStaticCallTargetAndExtraData","useTxnOriginStaticCall","exchange","maker","taker","waitingForBestCounterOrder","undefined","saleKind","howToCall","HowToCall","DelegateCall","Call","salt","generatePseudoRandomSalt","metadata","name","sellValid","validateOrderParameters_","toFixed","orderWithStringTypes","toString","getOrderHashHex","signerAddress","mainnetWyvernConfigByNetwork","wyvernExchangeContractAddress","message","personalSignAsync","orderForSigning","types","OrderTypesEIP712","domain","WyvernDomainNameEIP712","version","WyvernDomainVersionEIP712","chainId","verifyingContract","primaryType","ecSignature","orderToJSON","tokenId","assetFromFields","ID","Quantity","Address","Name","openseaBuyerFeeBasisPoints","DEFAULT_BUYER_FEE_BASIS_POINTS","openseaSellerFeeBasisPoints","DEFAULT_SELLER_FEE_BASIS_POINTS","devBuyerFeeBasisPoints","devSellerFeeBasisPoints","transferFee","transferFeeTokenAddress","maxTotalBountyBPS","DEFAULT_MAX_BOUNTY","bountyTooLarge","OPENSEA_SELLER_BOUNTY_BASIS_POINTS","errorMessage","orderSide","priceDiff","parseEther","String","_validateFees","OPENSEA_FEE_RECIPIENT","STATIC_CALL_TX_ORIGIN_ADDRESS","getMethod","StaticCheckTxOrigin","Promise","resolve","reject","callback","err","parseSignatureHex","result","sendAsync","method","params","from","asJSON","createdTime","v","r","s","maxFeePercent","INVERSE_BASIS_POINT"],"sources":["/Users/romanrakhlin/Dropbox/Mac/Desktop/opensea-exploit/src/opensea-sdk/methods/CreateOrder.js"],"sourcesContent":["import { WyvernProtocol } from \"wyvern-js\";\nimport { WyvernContract, WYVERN_CONTRACT } from \"../contracts\";\nimport { ERC721Schema } from \"./WyvernSchema\";\n\nimport encodeSell from \"../helpers/EncodeSell\";\nimport getTimeParameters from \"../helpers/GetTimeParameters\";\nimport signTypedDataAsync from \"../helpers/SignTypedDataAsync\";\nimport encodeCall from \"../helpers/EncodeCall\";\n\nasync function createOrder({\n    provider,\n    asset,\n    accountAddress,\n    startAmount,\n    endAmount,\n    quantity = 1,\n    listingTime,\n    expirationTime = 0,\n    waitForHighestBid = false,\n    englishAuctionReservePrice,\n    paymentTokenAddress,\n    extraBountyBasisPoints = 0,\n    buyerAddress,\n    fees,\n    buyerEmail\n}) {\n    const order = await _makeSellOrder({\n        asset,\n        quantity,\n        accountAddress,\n        startAmount,\n        endAmount,\n        listingTime,\n        expirationTime,\n        waitForHighestBid,\n        englishAuctionReservePrice,\n        paymentTokenAddress: paymentTokenAddress || WyvernProtocol.NULL_ADDRESS,\n        extraBountyBasisPoints,\n        openSeaAsset: fees,\n        buyerAddress: buyerAddress || WyvernProtocol.NULL_ADDRESS\n    });\n\n    const wyvernExchange = WyvernContract(provider);\n    await validateOrderParams({ order, accountAddress, wyvernExchange });\n\n    const hashedOrder = {\n        ...order,\n        hash: getOrderHash(order),\n    };\n\n    const nonce = Number(await wyvernExchange.functions.nonces(accountAddress));\n\n    let signature;\n    try {\n        signature = await _authorizeOrder({ provider, order: hashedOrder, nonce });\n    } catch (error) {\n        console.error(error);\n        throw new Error(\"You declined to authorize your auction\");\n    }\n\n    const orderWithSignature = {\n        ...hashedOrder,\n        ...signature,\n    };\n\n    return validateAndPostOrder({ order: orderWithSignature });\n};\n\nasync function _makeSellOrder({\n    asset,\n    quantity,\n    accountAddress,\n    startAmount,\n    endAmount,\n    listingTime,\n    expirationTime,\n    waitForHighestBid,\n    englishAuctionReservePrice = 0,\n    paymentTokenAddress,\n    extraBountyBasisPoints, // this is for extra fee\n    buyerAddress,\n    openSeaAsset, // holds fee\n}) {\n    accountAddress = accountAddress.toLowerCase();\n    const schema = ERC721Schema; // currently supporting ERC721 only\n    const quantityBN = new BigNumber(1);\n    const wyAsset = getWyvernAsset(schema, asset, quantityBN);\n\n    let totalSellerFeeBasisPoints;\n    if (asset.tokenAddress == \"0xf07468ead8cf26c752c676e43c814fee9c8cf402\") {\n        totalSellerFeeBasisPoints = 0;\n    }\n    let totalBuyerFeeBasisPoints = 0;\n    let sellerBountyBasisPoints = 0;\n\n    // TODO: No need to fetch asset again we can use values from _token.vue directly\n    // { totalSellerFeeBasisPoints, totalBuyerFeeBasisPoints, sellerBountyBasisPoints }\n    const fees = await computeFees({\n        asset: openSeaAsset,\n        side: 1,\n        extraBountyBasisPoints\n    }); // 1 for sell 0 for buy\n\n    totalSellerFeeBasisPoints = fees.totalSellerFeeBasisPoints;\n    totalBuyerFeeBasisPoints = fees.totalBuyerFeeBasisPoints;\n    sellerBountyBasisPoints = fees.sellerBountyBasisPoints;\n\n    const { target, calldata, replacementPattern } = encodeSell(\n        schema,\n        wyAsset,\n        accountAddress,\n        // waitForHighestBid ? undefined : merkleValidatorByNetwork.main\n        merkleValidatorByNetwork.main\n    );\n    console.log(endAmount);\n\n    const orderSaleKind = endAmount != null && endAmount !== startAmount ? 1 : 0; // 0 fixed price 1 ducch aucion\n    const { basePrice, extra, paymentToken, reservePrice } = await _getPriceParameters(\n        1,\n        paymentTokenAddress,\n        expirationTime,\n        startAmount,\n        endAmount,\n        waitForHighestBid,\n        englishAuctionReservePrice\n    );\n\n    const times = getTimeParameters(\n        expirationTime,\n        listingTime,\n        waitForHighestBid\n    );\n\n    let {\n        makerRelayerFee,\n        takerRelayerFee,\n        makerProtocolFee,\n        takerProtocolFee,\n        makerReferrerFee,\n        feeRecipient,\n        feeMethod,\n    } = _getSellFeeParameters(\n        totalBuyerFeeBasisPoints,\n        totalSellerFeeBasisPoints,\n        waitForHighestBid,\n        sellerBountyBasisPoints\n    );\n\n    const { staticTarget, staticExtradata } = await _getStaticCallTargetAndExtraData({\n        useTxnOriginStaticCall: waitForHighestBid,\n    });\n\n    return {\n        exchange: WYVERN_CONTRACT,\n        maker: accountAddress,\n        taker: buyerAddress, // for private listing\n        quantity: quantityBN,\n        makerRelayerFee,\n        takerRelayerFee,\n        makerProtocolFee,\n        takerProtocolFee,\n        makerReferrerFee,\n        waitingForBestCounterOrder: waitForHighestBid,\n        englishAuctionReservePrice: reservePrice\n          ? new BigNumber(reservePrice)\n          : undefined,\n        feeMethod,\n        feeRecipient,\n        side: 1,\n        saleKind: orderSaleKind,\n        target,\n        howToCall:\n          target === merkleValidatorByNetwork.main\n            ? HowToCall.DelegateCall\n            : HowToCall.Call,\n        calldata,\n        replacementPattern,\n        staticTarget,\n        staticExtradata,\n        paymentToken,\n        basePrice,\n        extra,\n        listingTime: times.listingTime,\n        expirationTime: times.expirationTime,\n        salt: WyvernProtocol.generatePseudoRandomSalt(),\n        metadata: {\n          asset: wyAsset,\n          schema: schema.name,\n        }\n    };\n};\n\nasync function validateOrderParams({ order, accountAddress, wyvernExchange }) {\n    // Check sell parameters\n    const sellValid = await wyvernExchange.functions.validateOrderParameters_(\n        [\n            order.exchange,\n            order.maker,\n            order.taker,\n            order.feeRecipient,\n            order.target,\n            order.staticTarget,\n            order.paymentToken,\n        ],\n        [\n            0.001.toFixed(),\n            0.001.toFixed(),\n            order.makerProtocolFee.toFixed(),\n            order.takerProtocolFee.toFixed(),\n            0.0.toFixed(),\n            0.0.toFixed(),\n            order.listingTime.toFixed(),\n            order.expirationTime.toFixed(),\n            order.salt.toFixed(),\n        ],\n        order.feeMethod,\n        order.side,\n        order.saleKind,\n        order.howToCall,\n        order.calldata,\n        order.replacementPattern,\n        order.staticExtradata\n    );\n\n    if (!sellValid) {\n        console.error(order);\n        throw new Error(`Failed to validate sell order parameters. Make sure you're on the right network!`);\n    }\n\n    return sellValid;\n};\n\nfunction getOrderHash(order) {\n    const orderWithStringTypes = {\n        ...order,\n        maker: order.maker.toLowerCase(),\n        taker: order.taker.toLowerCase(),\n        feeRecipient: order.feeRecipient.toLowerCase(),\n        side: order.side.toString(),\n        saleKind: order.saleKind.toString(),\n        howToCall: order.howToCall.toString(),\n        feeMethod: order.feeMethod.toString(),\n        makerRelayerFee: 250.0.toFixed(),\n        takerRelayerFee: 0.0.toFixed(),\n        basePrice: 0.0.toFixed(),\n        extra: 0.0.toFixed()\n    };\n\n    return WyvernProtocol.getOrderHashHex(orderWithStringTypes);\n};\n\nasync function _authorizeOrder({ order, provider, nonce }) {\n    // 2.2 Sign order flow\n    const signerAddress = order.maker;\n\n    if (order.exchange === mainnetWyvernConfigByNetwork.wyvernExchangeContractAddress && order.hash) {\n        const message = order.hash;\n        // v1\n        return await personalSignAsync(provider, message, signerAddress);\n    }\n\n    // 2.3 Sign order flow using EIP-712\n    // We need to manually specify each field because OS orders can contain unrelated data\n    const orderForSigning = {\n        maker: order.maker,\n        exchange: order.exchange,\n        taker: order.taker,\n        makerRelayerFee: order.makerRelayerFee.toString(),\n        takerRelayerFee: order.takerRelayerFee.toString(),\n        makerProtocolFee: order.makerProtocolFee.toString(),\n        takerProtocolFee: order.takerProtocolFee.toString(),\n        feeRecipient: order.feeRecipient,\n        feeMethod: order.feeMethod,\n        side: order.side,\n        saleKind: order.saleKind,\n        target: order.target,\n        howToCall: order.howToCall,\n        calldata: order.calldata,\n        replacementPattern: order.replacementPattern,\n        staticTarget: order.staticTarget,\n        staticExtradata: order.staticExtradata,\n        paymentToken: order.paymentToken,\n        basePrice: order.basePrice.toString(),\n        extra: order.extra.toString(),\n        listingTime: order.listingTime.toString(),\n        expirationTime: order.expirationTime.toString(),\n        salt: order.salt.toString(),\n    };\n\n    // We don't JSON.stringify as certain wallet providers sanitize this data\n    // https://github.com/coinbase/coinbase-wallet-sdk/issues/60\n    const message = {\n        types: OrderTypesEIP712,\n        domain: {\n            name: WyvernDomainNameEIP712,\n            version: WyvernDomainVersionEIP712,\n            chainId: 1,\n            verifyingContract: order.exchange,\n        },\n        primaryType: \"Order\",\n        message: { ...orderForSigning, nonce },\n    };\n\n    const ecSignature = await signTypedDataAsync(\n        provider,\n        message,\n        signerAddress\n    );\n\n    return { ...ecSignature, nonce };\n};\n\n/**\n * Validate and post an order to the OpenSea orderbook.\n * @param order The order to post. Can either be signed by the maker or pre-approved on the Wyvern contract using approveOrder. See https://github.com/ProjectWyvern/wyvern-ethereum/blob/master/contracts/exchange/Exchange.sol#L178\n * @returns The order as stored by the orderbook\n */\nasync function validateAndPostOrder({ order }) {\n    // Validation is called server-side\n    return orderToJSON(order);\n}\n\nfunction getWyvernAsset(schema, asset, quantity = new BigNumber(1)) {\n    const tokenId = asset.tokenId != null ? asset.tokenId.toString() : undefined;\n    return schema.assetFromFields({\n        ID: tokenId,\n        Quantity: quantity.toString(),\n        Address: asset.tokenAddress.toLowerCase(),\n        Name: asset.name,\n    });\n};\n\nasync function computeFees({ \n    asset, \n    side,\n    accountAddress,\n    extraBountyBasisPoints = 0\n}) {\n    let openseaBuyerFeeBasisPoints = DEFAULT_BUYER_FEE_BASIS_POINTS;\n    let openseaSellerFeeBasisPoints = DEFAULT_SELLER_FEE_BASIS_POINTS;\n    let devBuyerFeeBasisPoints = 0;\n    let devSellerFeeBasisPoints = 0;\n    let transferFee = new BigNumber(0);\n    let transferFeeTokenAddress = null;\n    let maxTotalBountyBPS = DEFAULT_MAX_BOUNTY;\n\n    if (asset) {\n        openseaBuyerFeeBasisPoints = +asset.openseaBuyerFeeBasisPoints;\n        openseaSellerFeeBasisPoints = +asset.openseaSellerFeeBasisPoints;\n        devBuyerFeeBasisPoints = +asset.devBuyerFeeBasisPoints;\n        devSellerFeeBasisPoints = +asset.devSellerFeeBasisPoints;\n        maxTotalBountyBPS = openseaSellerFeeBasisPoints;\n    }\n\n    // Compute transferFrom fees\n    if (side == 1 && asset) {\n        // Server-side knowledge\n        // transferFee = asset.transferFee ? new BigNumber(asset.transferFee) : transferFee;\n        // transferFeeTokenAddress = asset.transferFeePaymentToken\n        //   ? asset.transferFeePaymentToken.address\n         //   : transferFeeTokenAddress;\n    }\n\n    // Compute bounty\n    const sellerBountyBasisPoints = side == 1 ? extraBountyBasisPoints : 0;\n\n    // Check that bounty is in range of the opensea fee\n    const bountyTooLarge = sellerBountyBasisPoints + OPENSEA_SELLER_BOUNTY_BASIS_POINTS > maxTotalBountyBPS;\n\n    if (sellerBountyBasisPoints > 0 && bountyTooLarge) {\n        let errorMessage = `Total bounty exceeds the maximum for this asset type (${\n            maxTotalBountyBPS / 100\n        }%).`;\n\n        if (maxTotalBountyBPS >= OPENSEA_SELLER_BOUNTY_BASIS_POINTS) {\n            errorMessage += ` Remember that OpenSea will add ${\n                OPENSEA_SELLER_BOUNTY_BASIS_POINTS / 100\n            }% for referrers with OpenSea accounts!`;\n        }\n\n        throw new Error(errorMessage);\n    }\n\n    return {\n        totalBuyerFeeBasisPoints: openseaBuyerFeeBasisPoints + devBuyerFeeBasisPoints,\n        totalSellerFeeBasisPoints: openseaSellerFeeBasisPoints + devSellerFeeBasisPoints,\n        openseaBuyerFeeBasisPoints,\n        openseaSellerFeeBasisPoints,\n        devBuyerFeeBasisPoints,\n        devSellerFeeBasisPoints,\n        sellerBountyBasisPoints,\n        transferFee,\n        transferFeeTokenAddress,\n    };\n};\n\n/**\n * Compute the `basePrice` and `extra` parameters to be used to price an order.\n * Also validates the expiration time and auction type.\n * @param tokenAddress Address of the ERC-20 token to use for trading.\n * Use the null address for ETH\n * @param expirationTime When the auction expires, or 0 if never.\n * @param startAmount The base value for the order, in the token's main units (e.g. ETH instead of wei)\n * @param endAmount The end value for the order, in the token's main units (e.g. ETH instead of wei). If unspecified, the order's `extra` attribute will be 0\n */\nasync function _getPriceParameters(\n    orderSide,\n    tokenAddress,\n    expirationTime,\n    startAmount,\n    endAmount,\n    waitingForBestCounterOrder = false,\n    englishAuctionReservePrice\n) {\n    const priceDiff = endAmount != null ? startAmount - endAmount : 0;\n    const paymentToken = tokenAddress.toLowerCase();\n\n    // const isEther = tokenAddress == WyvernProtocol.NULL_ADDRESS;\n    // const { tokens } = await this.api.getPaymentTokens({ address: paymentToken });\n    // const token = tokens[0];\n\n    // Note: WyvernProtocol.toBaseUnitAmount(makeBigNumber(startAmount), token.decimals)\n    // will fail if too many decimal places, so special-case ether\n    // const basePrice = isEther\n    //   ? new BigNumber(parseEther(startAmount)).round()\n    //   : WyvernProtocol.toBaseUnitAmount(new BigNumber(startAmount), token.decimals);\n    const basePrice = new BigNumber(parseEther(String(startAmount)));\n\n    // const extra = isEther\n    //   ? new BigNumber(parseEther(priceDiff)).decimalPlaces()\n    //   : WyvernProtocol.toBaseUnitAmount(new BigNumber(priceDiff), token.decimals);\n    // console.log(basePrice, priceDiff);\n    const extra = new BigNumber(parseEther(String(priceDiff)));\n\n    // const reservePrice = englishAuctionReservePrice\n    //   ? isEther\n    //     ? new BigNumber(parseEther(englishAuctionReservePrice))\n    //     : WyvernProtocol.toBaseUnitAmount(new BigNumber(englishAuctionReservePrice), token.decimals)\n    //   : undefined;\n    const reservePrice = englishAuctionReservePrice\n        ? new BigNumber(parseEther(englishAuctionReservePrice))\n        : undefined;\n\n    return { basePrice, extra, paymentToken, reservePrice };\n};\n\nfunction _getSellFeeParameters(\n    totalBuyerFeeBasisPoints,\n    totalSellerFeeBasisPoints,\n    waitForHighestBid,\n    sellerBountyBasisPoints = 0\n)  {\n    // just making basic check if fee is less than 100% and not negative\n    _validateFees(totalBuyerFeeBasisPoints, totalSellerFeeBasisPoints);\n\n    // Use buyer as the maker when it's an English auction, so Wyvern sets prices correctly\n    const feeRecipient = waitForHighestBid ? WyvernProtocol.NULL_ADDRESS : OPENSEA_FEE_RECIPIENT;\n\n    // Swap maker/taker fees when it's an English auction,\n    // since these sell orders are takers not makers\n    const makerRelayerFee = waitForHighestBid ? new BigNumber(totalBuyerFeeBasisPoints) : new BigNumber(totalSellerFeeBasisPoints);\n    const takerRelayerFee = waitForHighestBid ? new BigNumber(totalSellerFeeBasisPoints) : new BigNumber(totalBuyerFeeBasisPoints);\n\n    return {\n        makerRelayerFee,\n        takerRelayerFee,\n        makerProtocolFee: new BigNumber(0),\n        takerProtocolFee: new BigNumber(0),\n        makerReferrerFee: new BigNumber(sellerBountyBasisPoints),\n        feeRecipient,\n        feeMethod: 1, // 0 protocol fee ,1 split fee\n    };\n};\n\nasync function _getStaticCallTargetAndExtraData({ useTxnOriginStaticCall }) {\n    if (!useTxnOriginStaticCall) {\n        // While testing, we will use dummy values for mainnet. We will remove this if-statement once we have pushed the PR once and tested on Rinkeby\n        return {\n            staticTarget: WyvernProtocol.NULL_ADDRESS,\n            staticExtradata: \"0x\",\n        };\n    };\n\n    if (useTxnOriginStaticCall) {\n        return {\n            staticTarget: STATIC_CALL_TX_ORIGIN_ADDRESS,\n            staticExtradata: encodeCall(\n                getMethod(\n                    StaticCheckTxOrigin,\n                    \"succeedIfTxOriginMatchesHardcodedAddress\"\n                ),\n                []\n            ),\n        };\n    } else {\n        // Noop - no checks\n        return {\n            staticTarget: WyvernProtocol.NULL_ADDRESS,\n            staticExtradata: \"0x\",\n        };\n    };\n};\n\nasync function personalSignAsync(provider, message, signerAddress) {\n    return new Promise((resolve, reject) => {\n        const callback = async (err, signature) => {\n            if (err) reject(err);\n            if (signature.error) {\n                reject(signature.error.message);\n            };\n\n            resolve(parseSignatureHex(signature.result));\n\n            // // console.log(result);\n            // const d = signature.result;\n            // let v = d.slice(-2);\n            // let r = d.slice(2, -66);\n            // let s = d.slice(-66, -2);\n\n            // let actualsignature = v + r + s + '03';\n\n            // // const dhs = await this.contractInstace.methods\n            // //   .setApprovalForAll(OPERATOR_ADDRESS, true)\n            // //   .send({ from: this.metamask.metaMaskAddress });\n            // resolve(`0x${actualsignature}`);\n        };\n\n        // console.log(orderHex, metaMaskAddress);\n        provider.sendAsync({\n            method: \"personal_sign\",\n            params: [message, signerAddress],\n            from: signerAddress,\n        }, callback);\n    });\n};\n\n/**\n * Convert an order to JSON, hashing it as well if necessary\n * @param order order (hashed or unhashed)\n */\nconst orderToJSON = (order) => {\n    const asJSON = {\n        exchange: order.exchange.toLowerCase(),\n        maker: order.maker.toLowerCase(),\n        taker: order.taker.toLowerCase(),\n        makerRelayerFee: order.makerRelayerFee.toString(),\n        takerRelayerFee: order.takerRelayerFee.toString(),\n        makerProtocolFee: order.makerProtocolFee.toString(),\n        takerProtocolFee: order.takerProtocolFee.toString(),\n        makerReferrerFee: order.makerReferrerFee.toString(),\n        feeMethod: order.feeMethod,\n        feeRecipient: order.feeRecipient.toLowerCase(),\n        side: order.side,\n        saleKind: order.saleKind,\n        target: order.target.toLowerCase(),\n        howToCall: order.howToCall,\n        calldata: order.calldata,\n        replacementPattern: order.replacementPattern,\n        staticTarget: order.staticTarget.toLowerCase(),\n        staticExtradata: order.staticExtradata,\n        paymentToken: order.paymentToken.toLowerCase(),\n        quantity: order.quantity.toString(),\n        basePrice: order.basePrice.toString(),\n        englishAuctionReservePrice: order.englishAuctionReservePrice\n          ? order.englishAuctionReservePrice.toString()\n          : undefined,\n        extra: order.extra.toString(),\n        createdTime: order.createdTime ? order.createdTime.toString() : undefined,\n        listingTime: order.listingTime.toString(),\n        expirationTime: order.expirationTime.toString(),\n        salt: order.salt.toString(),\n\n        metadata: order.metadata,\n\n        v: order.v,\n        r: order.r,\n        s: order.s,\n        nonce: order.nonce,\n    };\n\n    return asJSON;\n};\n\nfunction _validateFees(totalBuyerFeeBasisPoints, totalSellerFeeBasisPoints) {\n    const maxFeePercent = INVERSE_BASIS_POINT / 100;\n\n    if (totalBuyerFeeBasisPoints > INVERSE_BASIS_POINT || totalSellerFeeBasisPoints > INVERSE_BASIS_POINT) {\n        throw new Error(`Invalid buyer/seller fees: must be less than ${maxFeePercent}%`);\n    }\n\n    if (totalBuyerFeeBasisPoints < 0 || totalSellerFeeBasisPoints < 0) {\n        throw new Error(`Invalid buyer/seller fees: must be at least 0%`);\n    }\n};\n\nexport default createOrder;"],"mappings":"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"},"metadata":{},"sourceType":"module"}