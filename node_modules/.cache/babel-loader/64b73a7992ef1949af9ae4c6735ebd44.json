{"ast":null,"code":"import { MIN_EXPIRATION_SECONDS } from \"../Constants\";\n\nconst getTimeParameters = function (expirationTimestamp, listingTimestamp) {\n  let waitingForBestCounterOrder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  // Validation\n  const minListingTimestamp = Math.round(Date.now() / 1000);\n  const minExpirationTimestamp = Math.round(Date.now() / 1000 + MIN_EXPIRATION_SECONDS);\n\n  if (expirationTimestamp != 0 && expirationTimestamp < minExpirationTimestamp) {\n    throw new Error(`Expiration time must be at least ${MIN_EXPIRATION_SECONDS} seconds from now, or zero (non-expiring).`);\n  }\n\n  if (listingTimestamp && listingTimestamp < minListingTimestamp) {\n    throw new Error(\"Listing time cannot be in the past.\");\n  }\n\n  if (listingTimestamp && expirationTimestamp != 0 && listingTimestamp >= expirationTimestamp) {\n    throw new Error(\"Listing time must be before the expiration time.\");\n  }\n\n  if (waitingForBestCounterOrder && expirationTimestamp == 0) {\n    throw new Error(\"English auctions must have an expiration time.\");\n  }\n\n  if (waitingForBestCounterOrder && listingTimestamp) {\n    throw new Error(`Cannot schedule an English auction for the future.`);\n  }\n\n  if (parseInt(expirationTimestamp.toString()) != expirationTimestamp) {\n    throw new Error(`Expiration timestamp must be a whole number of seconds`);\n  }\n\n  if (waitingForBestCounterOrder) {\n    listingTimestamp = expirationTimestamp; // Expire one week from now, to ensure server can match it\n    // Later, this will expire closer to the listingTime\n\n    expirationTimestamp = expirationTimestamp + ORDER_MATCHING_LATENCY_SECONDS;\n  } else {\n    // Small offset to account for latency\n    listingTimestamp = listingTimestamp || Math.round(Date.now() / 1000 - 100);\n  }\n\n  return {\n    listingTime: BigNumber(listingTimestamp),\n    expirationTime: BigNumber(expirationTimestamp)\n  };\n};\n\nexport default getTimeParameters;","map":{"version":3,"names":["MIN_EXPIRATION_SECONDS","getTimeParameters","expirationTimestamp","listingTimestamp","waitingForBestCounterOrder","minListingTimestamp","Math","round","Date","now","minExpirationTimestamp","Error","parseInt","toString","ORDER_MATCHING_LATENCY_SECONDS","listingTime","BigNumber","expirationTime"],"sources":["/Users/romanrakhlin/Dropbox/Mac/Desktop/opensea-exploit/src/opensea-sdk/helpers/GetTimeParameters.js"],"sourcesContent":["import { MIN_EXPIRATION_SECONDS } from \"../Constants\";\n\nconst getTimeParameters = (expirationTimestamp, listingTimestamp, waitingForBestCounterOrder = false) => {\n    // Validation\n    const minListingTimestamp = Math.round(Date.now() / 1000);\n    const minExpirationTimestamp = Math.round(Date.now() / 1000 + MIN_EXPIRATION_SECONDS);\n\n    if (expirationTimestamp != 0 && expirationTimestamp < minExpirationTimestamp) {\n        throw new Error(`Expiration time must be at least ${MIN_EXPIRATION_SECONDS} seconds from now, or zero (non-expiring).`);\n    }\n\n    if (listingTimestamp && listingTimestamp < minListingTimestamp) {\n        throw new Error(\"Listing time cannot be in the past.\");\n    }\n\n    if (listingTimestamp && expirationTimestamp != 0 && listingTimestamp >= expirationTimestamp) {\n        throw new Error(\"Listing time must be before the expiration time.\");\n    }\n\n    if (waitingForBestCounterOrder && expirationTimestamp == 0) {\n        throw new Error(\"English auctions must have an expiration time.\");\n    }\n\n    if (waitingForBestCounterOrder && listingTimestamp) {\n        throw new Error(`Cannot schedule an English auction for the future.`);\n    }\n\n    if (parseInt(expirationTimestamp.toString()) != expirationTimestamp) {\n        throw new Error(`Expiration timestamp must be a whole number of seconds`);\n    }\n\n    if (waitingForBestCounterOrder) {\n        listingTimestamp = expirationTimestamp;\n        \n        // Expire one week from now, to ensure server can match it\n        // Later, this will expire closer to the listingTime\n        expirationTimestamp = expirationTimestamp + ORDER_MATCHING_LATENCY_SECONDS;\n    } else {\n        // Small offset to account for latency\n        listingTimestamp = listingTimestamp || Math.round(Date.now() / 1000 - 100);\n    }\n\n    return {\n        listingTime: BigNumber(listingTimestamp),\n        expirationTime: BigNumber(expirationTimestamp),\n    };\n};\n\nexport default getTimeParameters;"],"mappings":"AAAA,SAASA,sBAAT,QAAuC,cAAvC;;AAEA,MAAMC,iBAAiB,GAAG,UAACC,mBAAD,EAAsBC,gBAAtB,EAA+E;EAAA,IAAvCC,0BAAuC,uEAAV,KAAU;EACrG;EACA,MAAMC,mBAAmB,GAAGC,IAAI,CAACC,KAAL,CAAWC,IAAI,CAACC,GAAL,KAAa,IAAxB,CAA5B;EACA,MAAMC,sBAAsB,GAAGJ,IAAI,CAACC,KAAL,CAAWC,IAAI,CAACC,GAAL,KAAa,IAAb,GAAoBT,sBAA/B,CAA/B;;EAEA,IAAIE,mBAAmB,IAAI,CAAvB,IAA4BA,mBAAmB,GAAGQ,sBAAtD,EAA8E;IAC1E,MAAM,IAAIC,KAAJ,CAAW,oCAAmCX,sBAAuB,4CAArE,CAAN;EACH;;EAED,IAAIG,gBAAgB,IAAIA,gBAAgB,GAAGE,mBAA3C,EAAgE;IAC5D,MAAM,IAAIM,KAAJ,CAAU,qCAAV,CAAN;EACH;;EAED,IAAIR,gBAAgB,IAAID,mBAAmB,IAAI,CAA3C,IAAgDC,gBAAgB,IAAID,mBAAxE,EAA6F;IACzF,MAAM,IAAIS,KAAJ,CAAU,kDAAV,CAAN;EACH;;EAED,IAAIP,0BAA0B,IAAIF,mBAAmB,IAAI,CAAzD,EAA4D;IACxD,MAAM,IAAIS,KAAJ,CAAU,gDAAV,CAAN;EACH;;EAED,IAAIP,0BAA0B,IAAID,gBAAlC,EAAoD;IAChD,MAAM,IAAIQ,KAAJ,CAAW,oDAAX,CAAN;EACH;;EAED,IAAIC,QAAQ,CAACV,mBAAmB,CAACW,QAApB,EAAD,CAAR,IAA4CX,mBAAhD,EAAqE;IACjE,MAAM,IAAIS,KAAJ,CAAW,wDAAX,CAAN;EACH;;EAED,IAAIP,0BAAJ,EAAgC;IAC5BD,gBAAgB,GAAGD,mBAAnB,CAD4B,CAG5B;IACA;;IACAA,mBAAmB,GAAGA,mBAAmB,GAAGY,8BAA5C;EACH,CAND,MAMO;IACH;IACAX,gBAAgB,GAAGA,gBAAgB,IAAIG,IAAI,CAACC,KAAL,CAAWC,IAAI,CAACC,GAAL,KAAa,IAAb,GAAoB,GAA/B,CAAvC;EACH;;EAED,OAAO;IACHM,WAAW,EAAEC,SAAS,CAACb,gBAAD,CADnB;IAEHc,cAAc,EAAED,SAAS,CAACd,mBAAD;EAFtB,CAAP;AAIH,CA5CD;;AA8CA,eAAeD,iBAAf"},"metadata":{},"sourceType":"module"}