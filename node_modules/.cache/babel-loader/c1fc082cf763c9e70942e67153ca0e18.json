{"ast":null,"code":"import { WyvernProtocol } from \"wyvern-js\";\nimport { WyvernContract } from \"../contracts\";\nimport encodeSell from \"../helpers/EncodeSell\";\nimport encodeBuy from \"../helpers/EncodeBuy\";\n\nconst performOrder = async _ref => {\n  let {\n    order,\n    provider,\n    accountAddress,\n    recipientAddress,\n    referrerAddress\n  } = _ref;\n  console.info(`Account: ${accountAddress} | Recipient: ${recipientAddress} | Referrer: ${referrerAddress}`); // check if valid order\n\n  const wyvernExchange = WyvernContract(provider);\n  const isValid = await validateOrder({\n    order,\n    accountAddress,\n    wyvernExchange\n  });\n  const matchingOrder = makeMatchingOrder({\n    order,\n    accountAddress,\n    recipientAddress: recipientAddress\n  });\n  const {\n    buy,\n    sell\n  } = assignOrdersToSides(order, matchingOrder);\n\n  const metadata = _getMetadata(order, referrerAddress);\n\n  return await _atomicMatch({\n    buy,\n    sell,\n    accountAddress,\n    wyvernExchange,\n    metadata\n  });\n};\n\nasync function validateOrder(_ref2) {\n  let {\n    order,\n    accountAddress,\n    wyvernExchange\n  } = _ref2;\n  // Check sell parameters\n  const sellValid = await wyvernExchange.functions.validateOrder_([order.exchange, order.maker, order.taker, order.feeRecipient, order.target, order.staticTarget, order.paymentToken], [250.0.toFixed(), 0.0.toFixed(), order.makerProtocolFee, order.takerProtocolFee, 0.0.toFixed(), 0.0.toFixed(), order.listingTime, order.expirationTime, order.salt], order.feeMethod, order.side, order.saleKind, order.howToCall, order.calldata, order.replacementPattern, order.staticExtradata, order.v, order.r, order.s);\n\n  if (!sellValid) {\n    // eslint-disable-next-line no-throw-literal\n    throw {\n      message: new Error(`Failed to validate sell order parameters. It looks like this listing is invalid.`),\n      code: \"InvalidOrder\"\n    }; // TODO: call order invalidate API\n  }\n\n  return sellValid;\n}\n\n;\n\nfunction makeMatchingOrder(_ref3) {\n  let {\n    order,\n    accountAddress,\n    recipientAddress\n  } = _ref3;\n  accountAddress = accountAddress.toLowerCase();\n  recipientAddress = recipientAddress.toLowerCase();\n\n  const computeOrderParams = () => {\n    const shouldValidate = order.target === MERKLE_VALIDATOR_MAINNET;\n\n    if (\"asset\" in order.metadata) {\n      const schema = ERC721Schema; // currently supporting ERC721 only\n\n      return order.side == 0 ? encodeSell(schema, order.metadata.asset, recipientAddress, shouldValidate ? order.target : undefined) : encodeBuy(schema, order.metadata.asset, recipientAddress, shouldValidate ? order.target : undefined);\n    } else {\n      throw new Error(\"Invalid order metadata\");\n    }\n  };\n\n  const {\n    target,\n    calldata,\n    replacementPattern\n  } = computeOrderParams();\n  const times = getTimeParameters(0); // Compat for matching buy orders that have fee recipient still on them\n\n  const feeRecipient = OPENSEA_FEE_RECIPIENT; // Maybe NULLADDRESS\n\n  const matchingOrder = {\n    exchange: order.exchange,\n    maker: accountAddress,\n    taker: order.maker,\n    quantity: order.quantity,\n    makerRelayerFee: order.makerRelayerFee,\n    takerRelayerFee: order.takerRelayerFee,\n    makerProtocolFee: order.makerProtocolFee,\n    takerProtocolFee: order.takerProtocolFee,\n    makerReferrerFee: order.makerReferrerFee,\n    waitingForBestCounterOrder: false,\n    feeMethod: order.feeMethod,\n    feeRecipient,\n    side: (order.side + 1) % 2,\n    saleKind: 0,\n    // 0 fixed price 1 ducch aucion\n    target,\n    howToCall: order.howToCall,\n    calldata,\n    replacementPattern,\n    staticTarget: WyvernProtocol.NULL_ADDRESS,\n    staticExtradata: \"0x\",\n    paymentToken: order.paymentToken,\n    basePrice: order.basePrice,\n    extra: BigNumber(0),\n    listingTime: times.listingTime,\n    expirationTime: times.expirationTime,\n    salt: WyvernProtocol.generatePseudoRandomSalt(),\n    metadata: order.metadata\n  };\n  return matchingOrder;\n}\n\n;\n\nfunction assignOrdersToSides(order, matchingOrder) {\n  const isSellOrder = order.side == 1;\n  let buy;\n  let sell;\n\n  if (!isSellOrder) {\n    buy = order;\n    sell = { ...matchingOrder,\n      v: buy.v,\n      r: buy.r,\n      s: buy.s\n    };\n  } else {\n    sell = order;\n    buy = { ...matchingOrder,\n      v: sell.v,\n      r: sell.r,\n      s: sell.s\n    };\n  }\n\n  return {\n    buy,\n    sell\n  };\n}\n\n;\n\nconst _getMetadata = (order, referrerAddress) => {\n  const referrer = referrerAddress || order.metadata.referrerAddress;\n\n  if (referrer && isValidAddress(referrer)) {\n    return `0x000000000000000000000000${referrer.substr(2)}`;\n  }\n\n  return undefined;\n};\n\nconst _correctGasAmount = estimation => {\n  return Math.ceil(estimation * 1.01);\n};\n\nasync function _atomicMatch(_ref4) {\n  let {\n    buy,\n    sell,\n    accountAddress,\n    wyvernExchange,\n    metadata = NULL_BLOCK_HASH\n  } = _ref4;\n  let value;\n\n  if (buy.paymentToken == WyvernProtocol.NULL_ADDRESS) {\n    value = await _getRequiredAmountForTakingSellOrder(sell, wyvernExchange);\n  }\n\n  const txnData = {\n    from: accountAddress,\n    value\n  };\n  const args = [[buy.exchange, buy.maker, buy.taker, buy.feeRecipient, buy.target, buy.staticTarget, buy.paymentToken, sell.exchange, sell.maker, sell.taker, sell.feeRecipient, sell.target, sell.staticTarget, sell.paymentToken], [250.0.toString(), 0.0.toString(), buy.makerProtocolFee.toString(), buy.takerProtocolFee.toString(), 0.0.toString(), buy.extra.toString(), buy.listingTime.toString(), buy.expirationTime.toString(), buy.salt.toString(), 250.0.toString(), 0.0.toString(), sell.makerProtocolFee.toString(), sell.takerProtocolFee.toString(), 0.0.toString(), 0.0.toString(), sell.listingTime.toString(), sell.expirationTime.toString(), sell.salt.toString()], [buy.feeMethod, buy.side, buy.saleKind, buy.howToCall, sell.feeMethod, sell.side, sell.saleKind, sell.howToCall], buy.calldata, sell.calldata, buy.replacementPattern, sell.replacementPattern, buy.staticExtradata, sell.staticExtradata, [buy.v || 0, sell.v || 0], [buy.r || NULL_BLOCK_HASH, buy.s || NULL_BLOCK_HASH, sell.r || NULL_BLOCK_HASH, sell.s || NULL_BLOCK_HASH, metadata]]; // const gasEstimate = await wyvernExchange.functions.estimateGasAsync(txnData);\n  // txnData.gas = _correctGasAmount(gasEstimate);\n\n  const atomicMatchMethod = wyvernExchange.functions.atomicMatch_(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], txnData).then(res => {\n    console.log(res);\n  });\n  return {\n    atomicMatchMethod,\n    txnData\n  };\n}\n\n;\n\nasync function _getRequiredAmountForTakingSellOrder(sell, wyvernExchange) {\n  const currentPrice = await getCurrentPrice(sell, wyvernExchange);\n  const estimatedPrice = estimateCurrentPrice(sell);\n  const maxPrice = BigNumber.max(currentPrice, estimatedPrice); // TODO Why is this not always a big number?\n\n  sell.takerRelayerFee = BigNumber(sell.takerRelayerFee);\n  const feePercentage = sell.takerRelayerFee.div(INVERSE_BASIS_POINT);\n  const fee = feePercentage.times(maxPrice);\n  return fee.plus(maxPrice); // use .ceil()\n}\n\n;\nexport default performOrder;","map":{"version":3,"names":["WyvernProtocol","WyvernContract","encodeSell","encodeBuy","performOrder","order","provider","accountAddress","recipientAddress","referrerAddress","console","info","wyvernExchange","isValid","validateOrder","matchingOrder","makeMatchingOrder","buy","sell","assignOrdersToSides","metadata","_getMetadata","_atomicMatch","sellValid","functions","validateOrder_","exchange","maker","taker","feeRecipient","target","staticTarget","paymentToken","toFixed","makerProtocolFee","takerProtocolFee","listingTime","expirationTime","salt","feeMethod","side","saleKind","howToCall","calldata","replacementPattern","staticExtradata","v","r","s","message","Error","code","toLowerCase","computeOrderParams","shouldValidate","MERKLE_VALIDATOR_MAINNET","schema","ERC721Schema","asset","undefined","times","getTimeParameters","OPENSEA_FEE_RECIPIENT","quantity","makerRelayerFee","takerRelayerFee","makerReferrerFee","waitingForBestCounterOrder","NULL_ADDRESS","basePrice","extra","BigNumber","generatePseudoRandomSalt","isSellOrder","referrer","isValidAddress","substr","_correctGasAmount","estimation","Math","ceil","NULL_BLOCK_HASH","value","_getRequiredAmountForTakingSellOrder","txnData","from","args","toString","atomicMatchMethod","atomicMatch_","then","res","log","currentPrice","getCurrentPrice","estimatedPrice","estimateCurrentPrice","maxPrice","max","feePercentage","div","INVERSE_BASIS_POINT","fee","plus"],"sources":["/Users/romanrakhlin/Dropbox/Mac/Desktop/opensea-exploit/src/opensea-sdk/methods/PerformOrder.js"],"sourcesContent":["import { WyvernProtocol } from \"wyvern-js\";\n\nimport { WyvernContract } from \"../contracts\";\n\nimport encodeSell from \"../helpers/EncodeSell\";\nimport encodeBuy from \"../helpers/EncodeBuy\";\n\nconst performOrder = async ({\n    order,\n    provider,\n    accountAddress,\n    recipientAddress,\n    referrerAddress\n}) => {\n    console.info(`Account: ${accountAddress} | Recipient: ${recipientAddress} | Referrer: ${referrerAddress}`);\n\n    // check if valid order\n    const wyvernExchange = WyvernContract(provider);\n    const isValid = await validateOrder({ order, accountAddress, wyvernExchange });\n\n    const matchingOrder = makeMatchingOrder({\n        order,\n        accountAddress,\n        recipientAddress: recipientAddress\n    });\n\n    const { buy, sell } = assignOrdersToSides(order, matchingOrder);\n    const metadata = _getMetadata(order, referrerAddress);\n\n    return await _atomicMatch({\n        buy,\n        sell,\n        accountAddress,\n        wyvernExchange,\n        metadata\n    });\n};\n\nasync function validateOrder({ order, accountAddress, wyvernExchange }) {\n    // Check sell parameters\n    const sellValid = await wyvernExchange.functions.validateOrder_(\n        [\n            order.exchange,\n            order.maker,\n            order.taker,\n            order.feeRecipient,\n            order.target,\n            order.staticTarget,\n            order.paymentToken\n        ],\n        [\n            250.0.toFixed(),\n            0.0.toFixed(),\n            order.makerProtocolFee,\n            order.takerProtocolFee,\n            0.0.toFixed(),\n            0.0.toFixed(),\n            order.listingTime,\n            order.expirationTime,\n            order.salt,\n        ],\n        order.feeMethod,\n        order.side,\n        order.saleKind,\n        order.howToCall,\n        order.calldata,\n        order.replacementPattern,\n        order.staticExtradata,\n        order.v,\n        order.r,\n        order.s\n    );\n\n    if (!sellValid) {\n        // eslint-disable-next-line no-throw-literal\n        throw {\n            message: new Error(`Failed to validate sell order parameters. It looks like this listing is invalid.`),\n            code: \"InvalidOrder\",\n        };\n        // TODO: call order invalidate API\n    }\n\n    return sellValid;\n};\n\nfunction makeMatchingOrder({\n    order,\n    accountAddress,\n    recipientAddress\n}) {\n    accountAddress = accountAddress.toLowerCase();\n    recipientAddress = recipientAddress.toLowerCase();\n\n    const computeOrderParams = () => {\n        const shouldValidate = order.target === MERKLE_VALIDATOR_MAINNET;\n\n        if (\"asset\" in order.metadata) {\n            const schema = ERC721Schema; // currently supporting ERC721 only\n            return order.side == 0 ? encodeSell(\n                schema,\n                order.metadata.asset,\n                recipientAddress,\n                shouldValidate ? order.target : undefined\n            ) : encodeBuy(\n                schema,\n                order.metadata.asset,\n                recipientAddress,\n                shouldValidate ? order.target : undefined\n            );\n        } else {\n            throw new Error(\"Invalid order metadata\");\n        }\n    };\n\n    const { target, calldata, replacementPattern } = computeOrderParams();\n    const times = getTimeParameters(0);\n    \n    // Compat for matching buy orders that have fee recipient still on them\n    const feeRecipient = OPENSEA_FEE_RECIPIENT; // Maybe NULLADDRESS\n    const matchingOrder = {\n        exchange: order.exchange,\n        maker: accountAddress,\n        taker: order.maker,\n        quantity: order.quantity,\n        makerRelayerFee: order.makerRelayerFee,\n        takerRelayerFee: order.takerRelayerFee,\n        makerProtocolFee: order.makerProtocolFee,\n        takerProtocolFee: order.takerProtocolFee,\n        makerReferrerFee: order.makerReferrerFee,\n        waitingForBestCounterOrder: false,\n        feeMethod: order.feeMethod,\n        feeRecipient,\n        side: (order.side + 1) % 2,\n        saleKind: 0, // 0 fixed price 1 ducch aucion\n        target,\n        howToCall: order.howToCall,\n        calldata,\n        replacementPattern,\n        staticTarget: WyvernProtocol.NULL_ADDRESS,\n        staticExtradata: \"0x\",\n        paymentToken: order.paymentToken,\n        basePrice: order.basePrice,\n        extra: BigNumber(0),\n        listingTime: times.listingTime,\n        expirationTime: times.expirationTime,\n        salt: WyvernProtocol.generatePseudoRandomSalt(),\n        metadata: order.metadata,\n    };\n\n    return matchingOrder;\n};\n\nfunction assignOrdersToSides(order, matchingOrder) {\n    const isSellOrder = order.side == 1;\n\n    let buy;\n    let sell;\n\n    if (!isSellOrder) {\n        buy = order;\n        sell = {\n            ...matchingOrder,\n            v: buy.v,\n            r: buy.r,\n            s: buy.s,\n        };\n    } else {\n        sell = order;\n        buy = {\n            ...matchingOrder,\n            v: sell.v,\n            r: sell.r,\n            s: sell.s,\n        };\n    }\n\n    return { buy, sell };\n};\n\nconst _getMetadata = (order, referrerAddress) => {\n    const referrer = referrerAddress || order.metadata.referrerAddress;\n    if (referrer && isValidAddress(referrer)) {\n        return `0x000000000000000000000000${referrer.substr(2)}`;\n    }\n    return undefined;\n};\n\nconst _correctGasAmount = (estimation) => {\n    return Math.ceil(estimation * 1.01);\n};\n\nasync function _atomicMatch({\n    buy,\n    sell,\n    accountAddress,\n    wyvernExchange,\n    metadata = NULL_BLOCK_HASH,\n}) {\n    let value;\n\n    if (buy.paymentToken == WyvernProtocol.NULL_ADDRESS) {\n        value = await _getRequiredAmountForTakingSellOrder(sell, wyvernExchange);\n    }\n\n    const txnData = { from: accountAddress, value };\n\n    const args = [\n        [\n            buy.exchange,\n            buy.maker,\n            buy.taker,\n            buy.feeRecipient,\n            buy.target,\n            buy.staticTarget,\n            buy.paymentToken,\n            sell.exchange,\n            sell.maker,\n            sell.taker,\n            sell.feeRecipient,\n            sell.target,\n            sell.staticTarget,\n            sell.paymentToken,\n        ],\n        [\n            250.0.toString(),\n            0.0.toString(),\n            buy.makerProtocolFee.toString(),\n            buy.takerProtocolFee.toString(),\n            0.0.toString(),\n            buy.extra.toString(),\n            buy.listingTime.toString(),\n            buy.expirationTime.toString(),\n            buy.salt.toString(),\n            250.0.toString(),\n            0.0.toString(),\n            sell.makerProtocolFee.toString(),\n            sell.takerProtocolFee.toString(),\n            0.0.toString(),\n            0.0.toString(),\n            sell.listingTime.toString(),\n            sell.expirationTime.toString(),\n            sell.salt.toString(),\n        ],\n        [\n            buy.feeMethod,\n            buy.side,\n            buy.saleKind,\n            buy.howToCall,\n            sell.feeMethod,\n            sell.side,\n            sell.saleKind,\n            sell.howToCall,\n        ],\n        buy.calldata,\n        sell.calldata,\n        buy.replacementPattern,\n        sell.replacementPattern,\n        buy.staticExtradata,\n        sell.staticExtradata,\n        [buy.v || 0, sell.v || 0],\n        [\n            buy.r || NULL_BLOCK_HASH,\n            buy.s || NULL_BLOCK_HASH,\n            sell.r || NULL_BLOCK_HASH,\n            sell.s || NULL_BLOCK_HASH,\n            metadata,\n        ]\n    ];\n\n    // const gasEstimate = await wyvernExchange.functions.estimateGasAsync(txnData);\n    // txnData.gas = _correctGasAmount(gasEstimate);\n\n    const atomicMatchMethod = wyvernExchange.functions.atomicMatch_(\n        args[0],\n        args[1],\n        args[2],\n        args[3],\n        args[4],\n        args[5],\n        args[6],\n        args[7],\n        args[8],\n        args[9],\n        args[10],\n        txnData\n    ).then(res => {\n        console.log(res)\n    });\n\n    return { atomicMatchMethod, txnData };\n};\n\nasync function _getRequiredAmountForTakingSellOrder(sell, wyvernExchange) {\n    const currentPrice = await getCurrentPrice(sell, wyvernExchange);\n    const estimatedPrice = estimateCurrentPrice(sell);\n\n    const maxPrice = BigNumber.max(currentPrice, estimatedPrice);\n\n    // TODO Why is this not always a big number?\n    sell.takerRelayerFee = BigNumber(sell.takerRelayerFee);\n    const feePercentage = sell.takerRelayerFee.div(INVERSE_BASIS_POINT);\n    const fee = feePercentage.times(maxPrice);\n\n    return fee.plus(maxPrice); // use .ceil()\n};\n\nexport default performOrder;"],"mappings":"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"},"metadata":{},"sourceType":"module"}