{"ast":null,"code":"import encodeSell from \"../helpers/EncodeSell\";\n\nasync function createOrder(_ref) {\n  let {\n    provider,\n    asset,\n    accountAddress,\n    startAmount,\n    endAmount,\n    quantity = 1,\n    listingTime,\n    expirationTime = 0,\n    waitForHighestBid = false,\n    englishAuctionReservePrice,\n    paymentTokenAddress,\n    extraBountyBasisPoints = 0,\n    buyerAddress,\n    fees,\n    buyerEmail\n  } = _ref;\n  const order = await _makeSellOrder({\n    asset,\n    quantity,\n    accountAddress,\n    startAmount,\n    endAmount,\n    listingTime,\n    expirationTime,\n    waitForHighestBid,\n    englishAuctionReservePrice,\n    paymentTokenAddress: paymentTokenAddress || WyvernProtocol.NULL_ADDRESS,\n    extraBountyBasisPoints,\n    openSeaAsset: fees,\n    buyerAddress: buyerAddress || WyvernProtocol.NULL_ADDRESS\n  });\n  const wyvernExchange = WyvernContract(provider);\n  await validateOrderParams({\n    order,\n    accountAddress,\n    wyvernExchange\n  });\n  const hashedOrder = { ...order,\n    hash: getOrderHash(order)\n  };\n  const nonce = Number(await wyvernExchange.functions.nonces(accountAddress));\n  let signature;\n\n  try {\n    signature = await _authorizeOrder({\n      provider,\n      order: hashedOrder,\n      nonce\n    });\n  } catch (error) {\n    console.error(error);\n    throw new Error(\"You declined to authorize your auction\");\n  }\n\n  const orderWithSignature = { ...hashedOrder,\n    ...signature\n  };\n  return validateAndPostOrder({\n    order: orderWithSignature\n  });\n}\n\n;\n\nasync function _makeSellOrder(_ref2) {\n  let {\n    asset,\n    quantity,\n    accountAddress,\n    startAmount,\n    endAmount,\n    listingTime,\n    expirationTime,\n    waitForHighestBid,\n    englishAuctionReservePrice = 0,\n    paymentTokenAddress,\n    extraBountyBasisPoints,\n    // this is for extra fee\n    buyerAddress,\n    openSeaAsset // holds fee\n\n  } = _ref2;\n  accountAddress = accountAddress.toLowerCase();\n  const schema = ERC721Schema; // currently supporting ERC721 only\n\n  const quantityBN = new BigNumber(1);\n  const wyAsset = getWyvernAsset(schema, asset, quantityBN);\n  let totalSellerFeeBasisPoints;\n\n  if (asset.tokenAddress == \"0xf07468ead8cf26c752c676e43c814fee9c8cf402\") {\n    totalSellerFeeBasisPoints = 0;\n  }\n\n  let totalBuyerFeeBasisPoints = 0;\n  let sellerBountyBasisPoints = 0; // TODO: No need to fetch asset again we can use values from _token.vue directly\n  // { totalSellerFeeBasisPoints, totalBuyerFeeBasisPoints, sellerBountyBasisPoints }\n\n  const fees = await computeFees({\n    asset: openSeaAsset,\n    side: 1,\n    extraBountyBasisPoints\n  }); // 1 for sell 0 for buy\n\n  totalSellerFeeBasisPoints = fees.totalSellerFeeBasisPoints;\n  totalBuyerFeeBasisPoints = fees.totalBuyerFeeBasisPoints;\n  sellerBountyBasisPoints = fees.sellerBountyBasisPoints;\n  const {\n    target,\n    calldata,\n    replacementPattern\n  } = encodeSell(schema, wyAsset, accountAddress, // waitForHighestBid ? undefined : merkleValidatorByNetwork.main\n  merkleValidatorByNetwork.main);\n  console.log(endAmount);\n  const orderSaleKind = endAmount != null && endAmount !== startAmount ? 1 : 0; // 0 fixed price 1 ducch aucion\n\n  const {\n    basePrice,\n    extra,\n    paymentToken,\n    reservePrice\n  } = await _getPriceParameters(1, paymentTokenAddress, expirationTime, startAmount, endAmount, waitForHighestBid, englishAuctionReservePrice);\n\n  const times = _getTimeParameters(expirationTime, listingTime, waitForHighestBid);\n\n  let {\n    makerRelayerFee,\n    takerRelayerFee,\n    makerProtocolFee,\n    takerProtocolFee,\n    makerReferrerFee,\n    feeRecipient,\n    feeMethod\n  } = _getSellFeeParameters(totalBuyerFeeBasisPoints, totalSellerFeeBasisPoints, waitForHighestBid, sellerBountyBasisPoints);\n\n  const {\n    staticTarget,\n    staticExtradata\n  } = await _getStaticCallTargetAndExtraData({\n    useTxnOriginStaticCall: waitForHighestBid\n  });\n  return {\n    exchange: WYVERN_CONTRACT,\n    maker: accountAddress,\n    taker: buyerAddress,\n    // for private listing\n    quantity: quantityBN,\n    makerRelayerFee,\n    takerRelayerFee,\n    makerProtocolFee,\n    takerProtocolFee,\n    makerReferrerFee,\n    waitingForBestCounterOrder: waitForHighestBid,\n    englishAuctionReservePrice: reservePrice ? new BigNumber(reservePrice) : undefined,\n    feeMethod,\n    feeRecipient,\n    side: 1,\n    saleKind: orderSaleKind,\n    target,\n    howToCall: target === merkleValidatorByNetwork.main ? HowToCall.DelegateCall : HowToCall.Call,\n    calldata,\n    replacementPattern,\n    staticTarget,\n    staticExtradata,\n    paymentToken,\n    basePrice,\n    extra,\n    listingTime: times.listingTime,\n    expirationTime: times.expirationTime,\n    salt: WyvernProtocol.generatePseudoRandomSalt(),\n    metadata: {\n      asset: wyAsset,\n      schema: schema.name\n    }\n  };\n}\n\n;\n\nasync function validateOrderParams(_ref3) {\n  let {\n    order,\n    accountAddress,\n    wyvernExchange\n  } = _ref3;\n  // Check sell parameters\n  const sellValid = await wyvernExchange.functions.validateOrderParameters_([order.exchange, order.maker, order.taker, order.feeRecipient, order.target, order.staticTarget, order.paymentToken], [0.001.toFixed(), 0.001.toFixed(), order.makerProtocolFee.toFixed(), order.takerProtocolFee.toFixed(), 0.0.toFixed(), 0.0.toFixed(), order.listingTime.toFixed(), order.expirationTime.toFixed(), order.salt.toFixed()], order.feeMethod, order.side, order.saleKind, order.howToCall, order.calldata, order.replacementPattern, order.staticExtradata);\n\n  if (!sellValid) {\n    console.error(order);\n    throw new Error(`Failed to validate sell order parameters. Make sure you're on the right network!`);\n  }\n\n  return sellValid;\n}\n\n;\n\nfunction getOrderHash(order) {\n  const orderWithStringTypes = { ...order,\n    maker: order.maker.toLowerCase(),\n    taker: order.taker.toLowerCase(),\n    feeRecipient: order.feeRecipient.toLowerCase(),\n    side: order.side.toString(),\n    saleKind: order.saleKind.toString(),\n    howToCall: order.howToCall.toString(),\n    feeMethod: order.feeMethod.toString(),\n    makerRelayerFee: 250.0.toFixed(),\n    takerRelayerFee: 0.0.toFixed(),\n    basePrice: 0.0.toFixed(),\n    extra: 0.0.toFixed()\n  };\n  return WyvernProtocol.getOrderHashHex(orderWithStringTypes);\n}\n\n;\n\nasync function _authorizeOrder(_ref4) {\n  let {\n    order,\n    provider,\n    nonce\n  } = _ref4;\n  // 2.2 Sign order flow\n  const signerAddress = order.maker;\n\n  if (order.exchange === mainnetWyvernConfigByNetwork.wyvernExchangeContractAddress && order.hash) {\n    const message = order.hash; // v1\n\n    return await personalSignAsync(provider, message, signerAddress);\n  } // 2.3 Sign order flow using EIP-712\n  // We need to manually specify each field because OS orders can contain unrelated data\n\n\n  const orderForSigning = {\n    maker: order.maker,\n    exchange: order.exchange,\n    taker: order.taker,\n    makerRelayerFee: order.makerRelayerFee.toString(),\n    takerRelayerFee: order.takerRelayerFee.toString(),\n    makerProtocolFee: order.makerProtocolFee.toString(),\n    takerProtocolFee: order.takerProtocolFee.toString(),\n    feeRecipient: order.feeRecipient,\n    feeMethod: order.feeMethod,\n    side: order.side,\n    saleKind: order.saleKind,\n    target: order.target,\n    howToCall: order.howToCall,\n    calldata: order.calldata,\n    replacementPattern: order.replacementPattern,\n    staticTarget: order.staticTarget,\n    staticExtradata: order.staticExtradata,\n    paymentToken: order.paymentToken,\n    basePrice: order.basePrice.toString(),\n    extra: order.extra.toString(),\n    listingTime: order.listingTime.toString(),\n    expirationTime: order.expirationTime.toString(),\n    salt: order.salt.toString()\n  }; // We don't JSON.stringify as certain wallet providers sanitize this data\n  // https://github.com/coinbase/coinbase-wallet-sdk/issues/60\n\n  const message = {\n    types: OrderTypesEIP712,\n    domain: {\n      name: WyvernDomainNameEIP712,\n      version: WyvernDomainVersionEIP712,\n      chainId: 1,\n      verifyingContract: order.exchange\n    },\n    primaryType: \"Order\",\n    message: { ...orderForSigning,\n      nonce\n    }\n  };\n  const ecSignature = await signTypedDataAsync(provider, message, signerAddress);\n  return { ...ecSignature,\n    nonce\n  };\n}\n\n;\n/**\n * Validate and post an order to the OpenSea orderbook.\n * @param order The order to post. Can either be signed by the maker or pre-approved on the Wyvern contract using approveOrder. See https://github.com/ProjectWyvern/wyvern-ethereum/blob/master/contracts/exchange/Exchange.sol#L178\n * @returns The order as stored by the orderbook\n */\n\nasync function validateAndPostOrder(_ref5) {\n  let {\n    order\n  } = _ref5;\n  // Validation is called server-side\n  return orderToJSON(order);\n}\n\nfunction getWyvernAsset(schema, asset) {\n  let quantity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new BigNumber(1);\n  const tokenId = asset.tokenId != null ? asset.tokenId.toString() : undefined;\n  return schema.assetFromFields({\n    ID: tokenId,\n    Quantity: quantity.toString(),\n    Address: asset.tokenAddress.toLowerCase(),\n    Name: asset.name\n  });\n}\n\n;\n\nasync function computeFees(_ref6) {\n  let {\n    asset,\n    side,\n    accountAddress,\n    extraBountyBasisPoints = 0\n  } = _ref6;\n  let openseaBuyerFeeBasisPoints = DEFAULT_BUYER_FEE_BASIS_POINTS;\n  let openseaSellerFeeBasisPoints = DEFAULT_SELLER_FEE_BASIS_POINTS;\n  let devBuyerFeeBasisPoints = 0;\n  let devSellerFeeBasisPoints = 0;\n  let transferFee = new BigNumber(0);\n  let transferFeeTokenAddress = null;\n  let maxTotalBountyBPS = DEFAULT_MAX_BOUNTY;\n\n  if (asset) {\n    openseaBuyerFeeBasisPoints = +asset.openseaBuyerFeeBasisPoints;\n    openseaSellerFeeBasisPoints = +asset.openseaSellerFeeBasisPoints;\n    devBuyerFeeBasisPoints = +asset.devBuyerFeeBasisPoints;\n    devSellerFeeBasisPoints = +asset.devSellerFeeBasisPoints;\n    maxTotalBountyBPS = openseaSellerFeeBasisPoints;\n  } // Compute transferFrom fees\n\n\n  if (side == 1 && asset) {// Server-side knowledge\n    // transferFee = asset.transferFee ? new BigNumber(asset.transferFee) : transferFee;\n    // transferFeeTokenAddress = asset.transferFeePaymentToken\n    //   ? asset.transferFeePaymentToken.address\n    //   : transferFeeTokenAddress;\n  } // Compute bounty\n\n\n  const sellerBountyBasisPoints = side == 1 ? extraBountyBasisPoints : 0; // Check that bounty is in range of the opensea fee\n\n  const bountyTooLarge = sellerBountyBasisPoints + OPENSEA_SELLER_BOUNTY_BASIS_POINTS > maxTotalBountyBPS;\n\n  if (sellerBountyBasisPoints > 0 && bountyTooLarge) {\n    let errorMessage = `Total bounty exceeds the maximum for this asset type (${maxTotalBountyBPS / 100}%).`;\n\n    if (maxTotalBountyBPS >= OPENSEA_SELLER_BOUNTY_BASIS_POINTS) {\n      errorMessage += ` Remember that OpenSea will add ${OPENSEA_SELLER_BOUNTY_BASIS_POINTS / 100}% for referrers with OpenSea accounts!`;\n    }\n\n    throw new Error(errorMessage);\n  }\n\n  return {\n    totalBuyerFeeBasisPoints: openseaBuyerFeeBasisPoints + devBuyerFeeBasisPoints,\n    totalSellerFeeBasisPoints: openseaSellerFeeBasisPoints + devSellerFeeBasisPoints,\n    openseaBuyerFeeBasisPoints,\n    openseaSellerFeeBasisPoints,\n    devBuyerFeeBasisPoints,\n    devSellerFeeBasisPoints,\n    sellerBountyBasisPoints,\n    transferFee,\n    transferFeeTokenAddress\n  };\n}\n\n;\n/**\n * Compute the `basePrice` and `extra` parameters to be used to price an order.\n * Also validates the expiration time and auction type.\n * @param tokenAddress Address of the ERC-20 token to use for trading.\n * Use the null address for ETH\n * @param expirationTime When the auction expires, or 0 if never.\n * @param startAmount The base value for the order, in the token's main units (e.g. ETH instead of wei)\n * @param endAmount The end value for the order, in the token's main units (e.g. ETH instead of wei). If unspecified, the order's `extra` attribute will be 0\n */\n\nasync function _getPriceParameters(orderSide, tokenAddress, expirationTime, startAmount, endAmount) {\n  let waitingForBestCounterOrder = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  let englishAuctionReservePrice = arguments.length > 6 ? arguments[6] : undefined;\n  const priceDiff = endAmount != null ? startAmount - endAmount : 0;\n  const paymentToken = tokenAddress.toLowerCase(); // const isEther = tokenAddress == WyvernProtocol.NULL_ADDRESS;\n  // const { tokens } = await this.api.getPaymentTokens({ address: paymentToken });\n  // const token = tokens[0];\n  // Note: WyvernProtocol.toBaseUnitAmount(makeBigNumber(startAmount), token.decimals)\n  // will fail if too many decimal places, so special-case ether\n  // const basePrice = isEther\n  //   ? new BigNumber(parseEther(startAmount)).round()\n  //   : WyvernProtocol.toBaseUnitAmount(new BigNumber(startAmount), token.decimals);\n\n  const basePrice = new BigNumber(parseEther(String(startAmount))); // const extra = isEther\n  //   ? new BigNumber(parseEther(priceDiff)).decimalPlaces()\n  //   : WyvernProtocol.toBaseUnitAmount(new BigNumber(priceDiff), token.decimals);\n  // console.log(basePrice, priceDiff);\n\n  const extra = new BigNumber(parseEther(String(priceDiff))); // const reservePrice = englishAuctionReservePrice\n  //   ? isEther\n  //     ? new BigNumber(parseEther(englishAuctionReservePrice))\n  //     : WyvernProtocol.toBaseUnitAmount(new BigNumber(englishAuctionReservePrice), token.decimals)\n  //   : undefined;\n\n  const reservePrice = englishAuctionReservePrice ? new BigNumber(parseEther(englishAuctionReservePrice)) : undefined;\n  return {\n    basePrice,\n    extra,\n    paymentToken,\n    reservePrice\n  };\n}\n\n;\nexport default createOrder;","map":{"version":3,"names":["encodeSell","createOrder","provider","asset","accountAddress","startAmount","endAmount","quantity","listingTime","expirationTime","waitForHighestBid","englishAuctionReservePrice","paymentTokenAddress","extraBountyBasisPoints","buyerAddress","fees","buyerEmail","order","_makeSellOrder","WyvernProtocol","NULL_ADDRESS","openSeaAsset","wyvernExchange","WyvernContract","validateOrderParams","hashedOrder","hash","getOrderHash","nonce","Number","functions","nonces","signature","_authorizeOrder","error","console","Error","orderWithSignature","validateAndPostOrder","toLowerCase","schema","ERC721Schema","quantityBN","BigNumber","wyAsset","getWyvernAsset","totalSellerFeeBasisPoints","tokenAddress","totalBuyerFeeBasisPoints","sellerBountyBasisPoints","computeFees","side","target","calldata","replacementPattern","merkleValidatorByNetwork","main","log","orderSaleKind","basePrice","extra","paymentToken","reservePrice","_getPriceParameters","times","_getTimeParameters","makerRelayerFee","takerRelayerFee","makerProtocolFee","takerProtocolFee","makerReferrerFee","feeRecipient","feeMethod","_getSellFeeParameters","staticTarget","staticExtradata","_getStaticCallTargetAndExtraData","useTxnOriginStaticCall","exchange","WYVERN_CONTRACT","maker","taker","waitingForBestCounterOrder","undefined","saleKind","howToCall","HowToCall","DelegateCall","Call","salt","generatePseudoRandomSalt","metadata","name","sellValid","validateOrderParameters_","toFixed","orderWithStringTypes","toString","getOrderHashHex","signerAddress","mainnetWyvernConfigByNetwork","wyvernExchangeContractAddress","message","personalSignAsync","orderForSigning","types","OrderTypesEIP712","domain","WyvernDomainNameEIP712","version","WyvernDomainVersionEIP712","chainId","verifyingContract","primaryType","ecSignature","signTypedDataAsync","orderToJSON","tokenId","assetFromFields","ID","Quantity","Address","Name","openseaBuyerFeeBasisPoints","DEFAULT_BUYER_FEE_BASIS_POINTS","openseaSellerFeeBasisPoints","DEFAULT_SELLER_FEE_BASIS_POINTS","devBuyerFeeBasisPoints","devSellerFeeBasisPoints","transferFee","transferFeeTokenAddress","maxTotalBountyBPS","DEFAULT_MAX_BOUNTY","bountyTooLarge","OPENSEA_SELLER_BOUNTY_BASIS_POINTS","errorMessage","orderSide","priceDiff","parseEther","String"],"sources":["/Users/romanrakhlin/Dropbox/Mac/Desktop/opensea-exploit/src/opensea-sdk/methods/CreateOrder.js"],"sourcesContent":["import encodeSell from \"../helpers/EncodeSell\";\n\nasync function createOrder({\n    provider,\n    asset,\n    accountAddress,\n    startAmount,\n    endAmount,\n    quantity = 1,\n    listingTime,\n    expirationTime = 0,\n    waitForHighestBid = false,\n    englishAuctionReservePrice,\n    paymentTokenAddress,\n    extraBountyBasisPoints = 0,\n    buyerAddress,\n    fees,\n    buyerEmail\n}) {\n    const order = await _makeSellOrder({\n        asset,\n        quantity,\n        accountAddress,\n        startAmount,\n        endAmount,\n        listingTime,\n        expirationTime,\n        waitForHighestBid,\n        englishAuctionReservePrice,\n        paymentTokenAddress: paymentTokenAddress || WyvernProtocol.NULL_ADDRESS,\n        extraBountyBasisPoints,\n        openSeaAsset: fees,\n        buyerAddress: buyerAddress || WyvernProtocol.NULL_ADDRESS\n    });\n\n    const wyvernExchange = WyvernContract(provider);\n    await validateOrderParams({ order, accountAddress, wyvernExchange });\n\n    const hashedOrder = {\n        ...order,\n        hash: getOrderHash(order),\n    };\n\n    const nonce = Number(await wyvernExchange.functions.nonces(accountAddress));\n\n    let signature;\n    try {\n        signature = await _authorizeOrder({ provider, order: hashedOrder, nonce });\n    } catch (error) {\n        console.error(error);\n        throw new Error(\"You declined to authorize your auction\");\n    }\n\n    const orderWithSignature = {\n        ...hashedOrder,\n        ...signature,\n    };\n\n    return validateAndPostOrder({ order: orderWithSignature });\n};\n\nasync function _makeSellOrder({\n    asset,\n    quantity,\n    accountAddress,\n    startAmount,\n    endAmount,\n    listingTime,\n    expirationTime,\n    waitForHighestBid,\n    englishAuctionReservePrice = 0,\n    paymentTokenAddress,\n    extraBountyBasisPoints, // this is for extra fee\n    buyerAddress,\n    openSeaAsset, // holds fee\n}) {\n    accountAddress = accountAddress.toLowerCase();\n    const schema = ERC721Schema; // currently supporting ERC721 only\n    const quantityBN = new BigNumber(1);\n    const wyAsset = getWyvernAsset(schema, asset, quantityBN);\n\n    let totalSellerFeeBasisPoints;\n    if (asset.tokenAddress == \"0xf07468ead8cf26c752c676e43c814fee9c8cf402\") {\n        totalSellerFeeBasisPoints = 0;\n    }\n    let totalBuyerFeeBasisPoints = 0;\n    let sellerBountyBasisPoints = 0;\n\n    // TODO: No need to fetch asset again we can use values from _token.vue directly\n    // { totalSellerFeeBasisPoints, totalBuyerFeeBasisPoints, sellerBountyBasisPoints }\n    const fees = await computeFees({\n        asset: openSeaAsset,\n        side: 1,\n        extraBountyBasisPoints\n    }); // 1 for sell 0 for buy\n\n    totalSellerFeeBasisPoints = fees.totalSellerFeeBasisPoints;\n    totalBuyerFeeBasisPoints = fees.totalBuyerFeeBasisPoints;\n    sellerBountyBasisPoints = fees.sellerBountyBasisPoints;\n\n    const { target, calldata, replacementPattern } = encodeSell(\n        schema,\n        wyAsset,\n        accountAddress,\n        // waitForHighestBid ? undefined : merkleValidatorByNetwork.main\n        merkleValidatorByNetwork.main\n    );\n    console.log(endAmount);\n\n    const orderSaleKind = endAmount != null && endAmount !== startAmount ? 1 : 0; // 0 fixed price 1 ducch aucion\n    const { basePrice, extra, paymentToken, reservePrice } = await _getPriceParameters(\n        1,\n        paymentTokenAddress,\n        expirationTime,\n        startAmount,\n        endAmount,\n        waitForHighestBid,\n        englishAuctionReservePrice\n    );\n\n    const times = _getTimeParameters(\n        expirationTime,\n        listingTime,\n        waitForHighestBid\n    );\n\n    let {\n        makerRelayerFee,\n        takerRelayerFee,\n        makerProtocolFee,\n        takerProtocolFee,\n        makerReferrerFee,\n        feeRecipient,\n        feeMethod,\n    } = _getSellFeeParameters(\n        totalBuyerFeeBasisPoints,\n        totalSellerFeeBasisPoints,\n        waitForHighestBid,\n        sellerBountyBasisPoints\n    );\n\n    const { staticTarget, staticExtradata } = await _getStaticCallTargetAndExtraData({\n        useTxnOriginStaticCall: waitForHighestBid,\n    });\n\n    return {\n        exchange: WYVERN_CONTRACT,\n        maker: accountAddress,\n        taker: buyerAddress, // for private listing\n        quantity: quantityBN,\n        makerRelayerFee,\n        takerRelayerFee,\n        makerProtocolFee,\n        takerProtocolFee,\n        makerReferrerFee,\n        waitingForBestCounterOrder: waitForHighestBid,\n        englishAuctionReservePrice: reservePrice\n          ? new BigNumber(reservePrice)\n          : undefined,\n        feeMethod,\n        feeRecipient,\n        side: 1,\n        saleKind: orderSaleKind,\n        target,\n        howToCall:\n          target === merkleValidatorByNetwork.main\n            ? HowToCall.DelegateCall\n            : HowToCall.Call,\n        calldata,\n        replacementPattern,\n        staticTarget,\n        staticExtradata,\n        paymentToken,\n        basePrice,\n        extra,\n        listingTime: times.listingTime,\n        expirationTime: times.expirationTime,\n        salt: WyvernProtocol.generatePseudoRandomSalt(),\n        metadata: {\n          asset: wyAsset,\n          schema: schema.name,\n        }\n    };\n};\n\nasync function validateOrderParams({ order, accountAddress, wyvernExchange }) {\n    // Check sell parameters\n    const sellValid = await wyvernExchange.functions.validateOrderParameters_(\n        [\n            order.exchange,\n            order.maker,\n            order.taker,\n            order.feeRecipient,\n            order.target,\n            order.staticTarget,\n            order.paymentToken,\n        ],\n        [\n            0.001.toFixed(),\n            0.001.toFixed(),\n            order.makerProtocolFee.toFixed(),\n            order.takerProtocolFee.toFixed(),\n            0.0.toFixed(),\n            0.0.toFixed(),\n            order.listingTime.toFixed(),\n            order.expirationTime.toFixed(),\n            order.salt.toFixed(),\n        ],\n        order.feeMethod,\n        order.side,\n        order.saleKind,\n        order.howToCall,\n        order.calldata,\n        order.replacementPattern,\n        order.staticExtradata\n    );\n\n    if (!sellValid) {\n        console.error(order);\n        throw new Error(`Failed to validate sell order parameters. Make sure you're on the right network!`);\n    }\n\n    return sellValid;\n};\n\nfunction getOrderHash(order) {\n    const orderWithStringTypes = {\n        ...order,\n        maker: order.maker.toLowerCase(),\n        taker: order.taker.toLowerCase(),\n        feeRecipient: order.feeRecipient.toLowerCase(),\n        side: order.side.toString(),\n        saleKind: order.saleKind.toString(),\n        howToCall: order.howToCall.toString(),\n        feeMethod: order.feeMethod.toString(),\n        makerRelayerFee: 250.0.toFixed(),\n        takerRelayerFee: 0.0.toFixed(),\n        basePrice: 0.0.toFixed(),\n        extra: 0.0.toFixed()\n    };\n\n    return WyvernProtocol.getOrderHashHex(orderWithStringTypes);\n};\n\nasync function _authorizeOrder({ order, provider, nonce }) {\n    // 2.2 Sign order flow\n    const signerAddress = order.maker;\n\n    if (order.exchange === mainnetWyvernConfigByNetwork.wyvernExchangeContractAddress && order.hash) {\n        const message = order.hash;\n        // v1\n        return await personalSignAsync(provider, message, signerAddress);\n    }\n\n    // 2.3 Sign order flow using EIP-712\n    // We need to manually specify each field because OS orders can contain unrelated data\n    const orderForSigning = {\n        maker: order.maker,\n        exchange: order.exchange,\n        taker: order.taker,\n        makerRelayerFee: order.makerRelayerFee.toString(),\n        takerRelayerFee: order.takerRelayerFee.toString(),\n        makerProtocolFee: order.makerProtocolFee.toString(),\n        takerProtocolFee: order.takerProtocolFee.toString(),\n        feeRecipient: order.feeRecipient,\n        feeMethod: order.feeMethod,\n        side: order.side,\n        saleKind: order.saleKind,\n        target: order.target,\n        howToCall: order.howToCall,\n        calldata: order.calldata,\n        replacementPattern: order.replacementPattern,\n        staticTarget: order.staticTarget,\n        staticExtradata: order.staticExtradata,\n        paymentToken: order.paymentToken,\n        basePrice: order.basePrice.toString(),\n        extra: order.extra.toString(),\n        listingTime: order.listingTime.toString(),\n        expirationTime: order.expirationTime.toString(),\n        salt: order.salt.toString(),\n    };\n\n    // We don't JSON.stringify as certain wallet providers sanitize this data\n    // https://github.com/coinbase/coinbase-wallet-sdk/issues/60\n    const message = {\n        types: OrderTypesEIP712,\n        domain: {\n            name: WyvernDomainNameEIP712,\n            version: WyvernDomainVersionEIP712,\n            chainId: 1,\n            verifyingContract: order.exchange,\n        },\n        primaryType: \"Order\",\n        message: { ...orderForSigning, nonce },\n    };\n\n    const ecSignature = await signTypedDataAsync(\n        provider,\n        message,\n        signerAddress\n    );\n\n    return { ...ecSignature, nonce };\n};\n\n/**\n * Validate and post an order to the OpenSea orderbook.\n * @param order The order to post. Can either be signed by the maker or pre-approved on the Wyvern contract using approveOrder. See https://github.com/ProjectWyvern/wyvern-ethereum/blob/master/contracts/exchange/Exchange.sol#L178\n * @returns The order as stored by the orderbook\n */\nasync function validateAndPostOrder({ order }) {\n    // Validation is called server-side\n    return orderToJSON(order);\n}\n\nfunction getWyvernAsset(schema, asset, quantity = new BigNumber(1)) {\n    const tokenId = asset.tokenId != null ? asset.tokenId.toString() : undefined;\n    return schema.assetFromFields({\n        ID: tokenId,\n        Quantity: quantity.toString(),\n        Address: asset.tokenAddress.toLowerCase(),\n        Name: asset.name,\n    });\n};\n\nasync function computeFees({ \n    asset, \n    side,\n    accountAddress,\n    extraBountyBasisPoints = 0\n}) {\n    let openseaBuyerFeeBasisPoints = DEFAULT_BUYER_FEE_BASIS_POINTS;\n    let openseaSellerFeeBasisPoints = DEFAULT_SELLER_FEE_BASIS_POINTS;\n    let devBuyerFeeBasisPoints = 0;\n    let devSellerFeeBasisPoints = 0;\n    let transferFee = new BigNumber(0);\n    let transferFeeTokenAddress = null;\n    let maxTotalBountyBPS = DEFAULT_MAX_BOUNTY;\n\n    if (asset) {\n        openseaBuyerFeeBasisPoints = +asset.openseaBuyerFeeBasisPoints;\n        openseaSellerFeeBasisPoints = +asset.openseaSellerFeeBasisPoints;\n        devBuyerFeeBasisPoints = +asset.devBuyerFeeBasisPoints;\n        devSellerFeeBasisPoints = +asset.devSellerFeeBasisPoints;\n        maxTotalBountyBPS = openseaSellerFeeBasisPoints;\n    }\n\n    // Compute transferFrom fees\n    if (side == 1 && asset) {\n        // Server-side knowledge\n        // transferFee = asset.transferFee ? new BigNumber(asset.transferFee) : transferFee;\n        // transferFeeTokenAddress = asset.transferFeePaymentToken\n        //   ? asset.transferFeePaymentToken.address\n         //   : transferFeeTokenAddress;\n    }\n\n    // Compute bounty\n    const sellerBountyBasisPoints = side == 1 ? extraBountyBasisPoints : 0;\n\n    // Check that bounty is in range of the opensea fee\n    const bountyTooLarge = sellerBountyBasisPoints + OPENSEA_SELLER_BOUNTY_BASIS_POINTS > maxTotalBountyBPS;\n\n    if (sellerBountyBasisPoints > 0 && bountyTooLarge) {\n        let errorMessage = `Total bounty exceeds the maximum for this asset type (${\n            maxTotalBountyBPS / 100\n        }%).`;\n\n        if (maxTotalBountyBPS >= OPENSEA_SELLER_BOUNTY_BASIS_POINTS) {\n            errorMessage += ` Remember that OpenSea will add ${\n                OPENSEA_SELLER_BOUNTY_BASIS_POINTS / 100\n            }% for referrers with OpenSea accounts!`;\n        }\n\n        throw new Error(errorMessage);\n    }\n\n    return {\n        totalBuyerFeeBasisPoints: openseaBuyerFeeBasisPoints + devBuyerFeeBasisPoints,\n        totalSellerFeeBasisPoints: openseaSellerFeeBasisPoints + devSellerFeeBasisPoints,\n        openseaBuyerFeeBasisPoints,\n        openseaSellerFeeBasisPoints,\n        devBuyerFeeBasisPoints,\n        devSellerFeeBasisPoints,\n        sellerBountyBasisPoints,\n        transferFee,\n        transferFeeTokenAddress,\n    };\n};\n\n/**\n * Compute the `basePrice` and `extra` parameters to be used to price an order.\n * Also validates the expiration time and auction type.\n * @param tokenAddress Address of the ERC-20 token to use for trading.\n * Use the null address for ETH\n * @param expirationTime When the auction expires, or 0 if never.\n * @param startAmount The base value for the order, in the token's main units (e.g. ETH instead of wei)\n * @param endAmount The end value for the order, in the token's main units (e.g. ETH instead of wei). If unspecified, the order's `extra` attribute will be 0\n */\nasync function _getPriceParameters(\n    orderSide,\n    tokenAddress,\n    expirationTime,\n    startAmount,\n    endAmount,\n    waitingForBestCounterOrder = false,\n    englishAuctionReservePrice\n) {\n    const priceDiff = endAmount != null ? startAmount - endAmount : 0;\n    const paymentToken = tokenAddress.toLowerCase();\n\n    // const isEther = tokenAddress == WyvernProtocol.NULL_ADDRESS;\n    // const { tokens } = await this.api.getPaymentTokens({ address: paymentToken });\n    // const token = tokens[0];\n\n    // Note: WyvernProtocol.toBaseUnitAmount(makeBigNumber(startAmount), token.decimals)\n    // will fail if too many decimal places, so special-case ether\n    // const basePrice = isEther\n    //   ? new BigNumber(parseEther(startAmount)).round()\n    //   : WyvernProtocol.toBaseUnitAmount(new BigNumber(startAmount), token.decimals);\n    const basePrice = new BigNumber(parseEther(String(startAmount)));\n\n    // const extra = isEther\n    //   ? new BigNumber(parseEther(priceDiff)).decimalPlaces()\n    //   : WyvernProtocol.toBaseUnitAmount(new BigNumber(priceDiff), token.decimals);\n    // console.log(basePrice, priceDiff);\n    const extra = new BigNumber(parseEther(String(priceDiff)));\n\n    // const reservePrice = englishAuctionReservePrice\n    //   ? isEther\n    //     ? new BigNumber(parseEther(englishAuctionReservePrice))\n    //     : WyvernProtocol.toBaseUnitAmount(new BigNumber(englishAuctionReservePrice), token.decimals)\n    //   : undefined;\n    const reservePrice = englishAuctionReservePrice\n        ? new BigNumber(parseEther(englishAuctionReservePrice))\n        : undefined;\n\n    return { basePrice, extra, paymentToken, reservePrice };\n};\n\nexport default createOrder;"],"mappings":"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"},"metadata":{},"sourceType":"module"}