{"ast":null,"code":"import { WyvernProtocol } from \"wyvern-js\";\nimport { WyvernContract, WYVERN_CONTRACT } from \"../contracts\";\nimport { ERC721Schema } from \"../WyvernSchema\";\nimport BigNumber from \"bignumber.js\";\nimport { HowToCall } from \"wyvern-js/lib/types\";\nimport encodeSell from \"../helpers/EncodeSell\";\nimport getTimeParameters from \"../helpers/GetTimeParameters\";\nimport signTypedDataAsync from \"../helpers/SignTypedDataAsync\";\nimport encodeCall from \"../helpers/EncodeCall\";\nimport { MERKLE_VALIDATOR_MAINNET, mainnetWyvernConfigByNetwork, OrderTypesEIP712, WyvernDomainNameEIP712, WyvernDomainVersionEIP712, DEFAULT_BUYER_FEE_BASIS_POINTS, DEFAULT_SELLER_FEE_BASIS_POINTS } from \"../Constants\";\n\nasync function createOrder(_ref) {\n  let {\n    provider,\n    asset,\n    accountAddress,\n    startAmount,\n    endAmount,\n    quantity = 1,\n    listingTime,\n    expirationTime = 0,\n    waitForHighestBid = false,\n    englishAuctionReservePrice,\n    paymentTokenAddress,\n    extraBountyBasisPoints = 0,\n    buyerAddress,\n    fees,\n    buyerEmail\n  } = _ref;\n  const order = await _makeSellOrder({\n    asset,\n    quantity,\n    accountAddress,\n    startAmount,\n    endAmount,\n    listingTime,\n    expirationTime,\n    waitForHighestBid,\n    englishAuctionReservePrice,\n    paymentTokenAddress: paymentTokenAddress || WyvernProtocol.NULL_ADDRESS,\n    extraBountyBasisPoints,\n    openSeaAsset: fees,\n    buyerAddress: buyerAddress || WyvernProtocol.NULL_ADDRESS\n  });\n  const wyvernExchange = WyvernContract(provider);\n  await validateOrderParams({\n    order,\n    accountAddress,\n    wyvernExchange\n  });\n  const hashedOrder = { ...order,\n    hash: getOrderHash(order)\n  };\n  const nonce = Number(await wyvernExchange.functions.nonces(accountAddress));\n  let signature;\n\n  try {\n    signature = await _authorizeOrder({\n      provider,\n      order: hashedOrder,\n      nonce\n    });\n  } catch (error) {\n    console.error(error);\n    throw new Error(\"You declined to authorize your auction\");\n  }\n\n  const orderWithSignature = { ...hashedOrder,\n    ...signature\n  };\n  return validateAndPostOrder({\n    order: orderWithSignature\n  });\n}\n\n;\n\nasync function _makeSellOrder(_ref2) {\n  let {\n    asset,\n    quantity,\n    accountAddress,\n    startAmount,\n    endAmount,\n    listingTime,\n    expirationTime,\n    waitForHighestBid,\n    englishAuctionReservePrice = 0,\n    paymentTokenAddress,\n    extraBountyBasisPoints,\n    // this is for extra fee\n    buyerAddress,\n    openSeaAsset // holds fee\n\n  } = _ref2;\n  accountAddress = accountAddress.toLowerCase();\n  const schema = ERC721Schema; // currently supporting ERC721 only\n\n  const quantityBN = new BigNumber(1);\n  const wyAsset = getWyvernAsset(schema, asset, quantityBN);\n  let totalSellerFeeBasisPoints;\n\n  if (asset.tokenAddress == \"0xf07468ead8cf26c752c676e43c814fee9c8cf402\") {\n    totalSellerFeeBasisPoints = 0;\n  }\n\n  let totalBuyerFeeBasisPoints = 0;\n  let sellerBountyBasisPoints = 0; // TODO: No need to fetch asset again we can use values from _token.vue directly\n  // { totalSellerFeeBasisPoints, totalBuyerFeeBasisPoints, sellerBountyBasisPoints }\n\n  const fees = await computeFees({\n    asset: openSeaAsset,\n    side: 1,\n    extraBountyBasisPoints\n  }); // 1 for sell 0 for buy\n\n  totalSellerFeeBasisPoints = fees.totalSellerFeeBasisPoints;\n  totalBuyerFeeBasisPoints = fees.totalBuyerFeeBasisPoints;\n  sellerBountyBasisPoints = fees.sellerBountyBasisPoints;\n  const {\n    target,\n    calldata,\n    replacementPattern\n  } = encodeSell(schema, wyAsset, accountAddress, // waitForHighestBid ? undefined : MERKLE_VALIDATOR_MAINNET\n  MERKLE_VALIDATOR_MAINNET);\n  console.log(endAmount);\n  const orderSaleKind = endAmount != null && endAmount !== startAmount ? 1 : 0; // 0 fixed price 1 ducch aucion\n\n  const {\n    basePrice,\n    extra,\n    paymentToken,\n    reservePrice\n  } = await _getPriceParameters(1, paymentTokenAddress, expirationTime, startAmount, endAmount, waitForHighestBid, englishAuctionReservePrice);\n  const times = getTimeParameters(expirationTime, listingTime, waitForHighestBid);\n\n  let {\n    makerRelayerFee,\n    takerRelayerFee,\n    makerProtocolFee,\n    takerProtocolFee,\n    makerReferrerFee,\n    feeRecipient,\n    feeMethod\n  } = _getSellFeeParameters(totalBuyerFeeBasisPoints, totalSellerFeeBasisPoints, waitForHighestBid, sellerBountyBasisPoints);\n\n  const {\n    staticTarget,\n    staticExtradata\n  } = await _getStaticCallTargetAndExtraData({\n    useTxnOriginStaticCall: waitForHighestBid\n  });\n  return {\n    exchange: WYVERN_CONTRACT,\n    maker: accountAddress,\n    taker: buyerAddress,\n    // for private listing\n    quantity: quantityBN,\n    makerRelayerFee,\n    takerRelayerFee,\n    makerProtocolFee,\n    takerProtocolFee,\n    makerReferrerFee,\n    waitingForBestCounterOrder: waitForHighestBid,\n    englishAuctionReservePrice: reservePrice ? new BigNumber(reservePrice) : undefined,\n    feeMethod,\n    feeRecipient,\n    side: 1,\n    saleKind: orderSaleKind,\n    target,\n    howToCall: target === MERKLE_VALIDATOR_MAINNET ? HowToCall.DelegateCall : HowToCall.Call,\n    calldata,\n    replacementPattern,\n    staticTarget,\n    staticExtradata,\n    paymentToken,\n    basePrice,\n    extra,\n    listingTime: times.listingTime,\n    expirationTime: times.expirationTime,\n    salt: WyvernProtocol.generatePseudoRandomSalt(),\n    metadata: {\n      asset: wyAsset,\n      schema: schema.name\n    }\n  };\n}\n\n;\n\nasync function validateOrderParams(_ref3) {\n  let {\n    order,\n    accountAddress,\n    wyvernExchange\n  } = _ref3;\n  // Check sell parameters\n  const sellValid = await wyvernExchange.functions.validateOrderParameters_([order.exchange, order.maker, order.taker, order.feeRecipient, order.target, order.staticTarget, order.paymentToken], [0.001.toFixed(), 0.001.toFixed(), order.makerProtocolFee.toFixed(), order.takerProtocolFee.toFixed(), 0.0.toFixed(), 0.0.toFixed(), order.listingTime.toFixed(), order.expirationTime.toFixed(), order.salt.toFixed()], order.feeMethod, order.side, order.saleKind, order.howToCall, order.calldata, order.replacementPattern, order.staticExtradata);\n\n  if (!sellValid) {\n    console.error(order);\n    throw new Error(`Failed to validate sell order parameters. Make sure you're on the right network!`);\n  }\n\n  return sellValid;\n}\n\n;\n\nfunction getOrderHash(order) {\n  const orderWithStringTypes = { ...order,\n    maker: order.maker.toLowerCase(),\n    taker: order.taker.toLowerCase(),\n    feeRecipient: order.feeRecipient.toLowerCase(),\n    side: order.side.toString(),\n    saleKind: order.saleKind.toString(),\n    howToCall: order.howToCall.toString(),\n    feeMethod: order.feeMethod.toString(),\n    makerRelayerFee: 250.0.toFixed(),\n    takerRelayerFee: 0.0.toFixed(),\n    basePrice: 0.0.toFixed(),\n    extra: 0.0.toFixed()\n  };\n  return WyvernProtocol.getOrderHashHex(orderWithStringTypes);\n}\n\n;\n\nasync function _authorizeOrder(_ref4) {\n  let {\n    order,\n    provider,\n    nonce\n  } = _ref4;\n  // 2.2 Sign order flow\n  const signerAddress = order.maker;\n\n  if (order.exchange === mainnetWyvernConfigByNetwork.wyvernExchangeContractAddress && order.hash) {\n    const message = order.hash; // v1\n\n    return await personalSignAsync(provider, message, signerAddress);\n  } // 2.3 Sign order flow using EIP-712\n  // We need to manually specify each field because OS orders can contain unrelated data\n\n\n  const orderForSigning = {\n    maker: order.maker,\n    exchange: order.exchange,\n    taker: order.taker,\n    makerRelayerFee: order.makerRelayerFee.toString(),\n    takerRelayerFee: order.takerRelayerFee.toString(),\n    makerProtocolFee: order.makerProtocolFee.toString(),\n    takerProtocolFee: order.takerProtocolFee.toString(),\n    feeRecipient: order.feeRecipient,\n    feeMethod: order.feeMethod,\n    side: order.side,\n    saleKind: order.saleKind,\n    target: order.target,\n    howToCall: order.howToCall,\n    calldata: order.calldata,\n    replacementPattern: order.replacementPattern,\n    staticTarget: order.staticTarget,\n    staticExtradata: order.staticExtradata,\n    paymentToken: order.paymentToken,\n    basePrice: order.basePrice.toString(),\n    extra: order.extra.toString(),\n    listingTime: order.listingTime.toString(),\n    expirationTime: order.expirationTime.toString(),\n    salt: order.salt.toString()\n  }; // We don't JSON.stringify as certain wallet providers sanitize this data\n  // https://github.com/coinbase/coinbase-wallet-sdk/issues/60\n\n  const message = {\n    types: OrderTypesEIP712,\n    domain: {\n      name: WyvernDomainNameEIP712,\n      version: WyvernDomainVersionEIP712,\n      chainId: 1,\n      verifyingContract: order.exchange\n    },\n    primaryType: \"Order\",\n    message: { ...orderForSigning,\n      nonce\n    }\n  };\n  const ecSignature = await signTypedDataAsync(provider, message, signerAddress);\n  return { ...ecSignature,\n    nonce\n  };\n}\n\n;\n/**\n * Validate and post an order to the OpenSea orderbook.\n * @param order The order to post. Can either be signed by the maker or pre-approved on the Wyvern contract using approveOrder. See https://github.com/ProjectWyvern/wyvern-ethereum/blob/master/contracts/exchange/Exchange.sol#L178\n * @returns The order as stored by the orderbook\n */\n\nasync function validateAndPostOrder(_ref5) {\n  let {\n    order\n  } = _ref5;\n  // Validation is called server-side\n  return orderToJSON(order);\n}\n\nfunction getWyvernAsset(schema, asset) {\n  let quantity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new BigNumber(1);\n  const tokenId = asset.tokenId != null ? asset.tokenId.toString() : undefined;\n  return schema.assetFromFields({\n    ID: tokenId,\n    Quantity: quantity.toString(),\n    Address: asset.tokenAddress.toLowerCase(),\n    Name: asset.name\n  });\n}\n\n;\n\nasync function computeFees(_ref6) {\n  let {\n    asset,\n    side,\n    accountAddress,\n    extraBountyBasisPoints = 0\n  } = _ref6;\n  let openseaBuyerFeeBasisPoints = DEFAULT_BUYER_FEE_BASIS_POINTS;\n  let openseaSellerFeeBasisPoints = DEFAULT_SELLER_FEE_BASIS_POINTS;\n  let devBuyerFeeBasisPoints = 0;\n  let devSellerFeeBasisPoints = 0;\n  let transferFee = new BigNumber(0);\n  let transferFeeTokenAddress = null;\n  let maxTotalBountyBPS = DEFAULT_MAX_BOUNTY;\n\n  if (asset) {\n    openseaBuyerFeeBasisPoints = +asset.openseaBuyerFeeBasisPoints;\n    openseaSellerFeeBasisPoints = +asset.openseaSellerFeeBasisPoints;\n    devBuyerFeeBasisPoints = +asset.devBuyerFeeBasisPoints;\n    devSellerFeeBasisPoints = +asset.devSellerFeeBasisPoints;\n    maxTotalBountyBPS = openseaSellerFeeBasisPoints;\n  } // Compute transferFrom fees\n\n\n  if (side == 1 && asset) {// Server-side knowledge\n    // transferFee = asset.transferFee ? new BigNumber(asset.transferFee) : transferFee;\n    // transferFeeTokenAddress = asset.transferFeePaymentToken\n    //   ? asset.transferFeePaymentToken.address\n    //   : transferFeeTokenAddress;\n  } // Compute bounty\n\n\n  const sellerBountyBasisPoints = side == 1 ? extraBountyBasisPoints : 0; // Check that bounty is in range of the opensea fee\n\n  const bountyTooLarge = sellerBountyBasisPoints + OPENSEA_SELLER_BOUNTY_BASIS_POINTS > maxTotalBountyBPS;\n\n  if (sellerBountyBasisPoints > 0 && bountyTooLarge) {\n    let errorMessage = `Total bounty exceeds the maximum for this asset type (${maxTotalBountyBPS / 100}%).`;\n\n    if (maxTotalBountyBPS >= OPENSEA_SELLER_BOUNTY_BASIS_POINTS) {\n      errorMessage += ` Remember that OpenSea will add ${OPENSEA_SELLER_BOUNTY_BASIS_POINTS / 100}% for referrers with OpenSea accounts!`;\n    }\n\n    throw new Error(errorMessage);\n  }\n\n  return {\n    totalBuyerFeeBasisPoints: openseaBuyerFeeBasisPoints + devBuyerFeeBasisPoints,\n    totalSellerFeeBasisPoints: openseaSellerFeeBasisPoints + devSellerFeeBasisPoints,\n    openseaBuyerFeeBasisPoints,\n    openseaSellerFeeBasisPoints,\n    devBuyerFeeBasisPoints,\n    devSellerFeeBasisPoints,\n    sellerBountyBasisPoints,\n    transferFee,\n    transferFeeTokenAddress\n  };\n}\n\n;\n/**\n * Compute the `basePrice` and `extra` parameters to be used to price an order.\n * Also validates the expiration time and auction type.\n * @param tokenAddress Address of the ERC-20 token to use for trading.\n * Use the null address for ETH\n * @param expirationTime When the auction expires, or 0 if never.\n * @param startAmount The base value for the order, in the token's main units (e.g. ETH instead of wei)\n * @param endAmount The end value for the order, in the token's main units (e.g. ETH instead of wei). If unspecified, the order's `extra` attribute will be 0\n */\n\nasync function _getPriceParameters(orderSide, tokenAddress, expirationTime, startAmount, endAmount) {\n  let waitingForBestCounterOrder = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  let englishAuctionReservePrice = arguments.length > 6 ? arguments[6] : undefined;\n  const priceDiff = endAmount != null ? startAmount - endAmount : 0;\n  const paymentToken = tokenAddress.toLowerCase(); // const isEther = tokenAddress == WyvernProtocol.NULL_ADDRESS;\n  // const { tokens } = await this.api.getPaymentTokens({ address: paymentToken });\n  // const token = tokens[0];\n  // Note: WyvernProtocol.toBaseUnitAmount(makeBigNumber(startAmount), token.decimals)\n  // will fail if too many decimal places, so special-case ether\n  // const basePrice = isEther\n  //   ? new BigNumber(parseEther(startAmount)).round()\n  //   : WyvernProtocol.toBaseUnitAmount(new BigNumber(startAmount), token.decimals);\n\n  const basePrice = new BigNumber(parseEther(String(startAmount))); // const extra = isEther\n  //   ? new BigNumber(parseEther(priceDiff)).decimalPlaces()\n  //   : WyvernProtocol.toBaseUnitAmount(new BigNumber(priceDiff), token.decimals);\n  // console.log(basePrice, priceDiff);\n\n  const extra = new BigNumber(parseEther(String(priceDiff))); // const reservePrice = englishAuctionReservePrice\n  //   ? isEther\n  //     ? new BigNumber(parseEther(englishAuctionReservePrice))\n  //     : WyvernProtocol.toBaseUnitAmount(new BigNumber(englishAuctionReservePrice), token.decimals)\n  //   : undefined;\n\n  const reservePrice = englishAuctionReservePrice ? new BigNumber(parseEther(englishAuctionReservePrice)) : undefined;\n  return {\n    basePrice,\n    extra,\n    paymentToken,\n    reservePrice\n  };\n}\n\n;\n\nfunction _getSellFeeParameters(totalBuyerFeeBasisPoints, totalSellerFeeBasisPoints, waitForHighestBid) {\n  let sellerBountyBasisPoints = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n  // just making basic check if fee is less than 100% and not negative\n  _validateFees(totalBuyerFeeBasisPoints, totalSellerFeeBasisPoints); // Use buyer as the maker when it's an English auction, so Wyvern sets prices correctly\n\n\n  const feeRecipient = waitForHighestBid ? WyvernProtocol.NULL_ADDRESS : OPENSEA_FEE_RECIPIENT; // Swap maker/taker fees when it's an English auction,\n  // since these sell orders are takers not makers\n\n  const makerRelayerFee = waitForHighestBid ? new BigNumber(totalBuyerFeeBasisPoints) : new BigNumber(totalSellerFeeBasisPoints);\n  const takerRelayerFee = waitForHighestBid ? new BigNumber(totalSellerFeeBasisPoints) : new BigNumber(totalBuyerFeeBasisPoints);\n  return {\n    makerRelayerFee,\n    takerRelayerFee,\n    makerProtocolFee: new BigNumber(0),\n    takerProtocolFee: new BigNumber(0),\n    makerReferrerFee: new BigNumber(sellerBountyBasisPoints),\n    feeRecipient,\n    feeMethod: 1 // 0 protocol fee ,1 split fee\n\n  };\n}\n\n;\n\nasync function _getStaticCallTargetAndExtraData(_ref7) {\n  let {\n    useTxnOriginStaticCall\n  } = _ref7;\n\n  if (!useTxnOriginStaticCall) {\n    // While testing, we will use dummy values for mainnet. We will remove this if-statement once we have pushed the PR once and tested on Rinkeby\n    return {\n      staticTarget: WyvernProtocol.NULL_ADDRESS,\n      staticExtradata: \"0x\"\n    };\n  }\n\n  ;\n\n  if (useTxnOriginStaticCall) {\n    return {\n      staticTarget: STATIC_CALL_TX_ORIGIN_ADDRESS,\n      staticExtradata: encodeCall(getMethod(StaticCheckTxOrigin, \"succeedIfTxOriginMatchesHardcodedAddress\"), [])\n    };\n  } else {\n    // Noop - no checks\n    return {\n      staticTarget: WyvernProtocol.NULL_ADDRESS,\n      staticExtradata: \"0x\"\n    };\n  }\n\n  ;\n}\n\n;\n\nasync function personalSignAsync(provider, message, signerAddress) {\n  return new Promise((resolve, reject) => {\n    const callback = async (err, signature) => {\n      if (err) reject(err);\n\n      if (signature.error) {\n        reject(signature.error.message);\n      }\n\n      ;\n      resolve(parseSignatureHex(signature.result)); // // console.log(result);\n      // const d = signature.result;\n      // let v = d.slice(-2);\n      // let r = d.slice(2, -66);\n      // let s = d.slice(-66, -2);\n      // let actualsignature = v + r + s + '03';\n      // // const dhs = await this.contractInstace.methods\n      // //   .setApprovalForAll(OPERATOR_ADDRESS, true)\n      // //   .send({ from: this.metamask.metaMaskAddress });\n      // resolve(`0x${actualsignature}`);\n    }; // console.log(orderHex, metaMaskAddress);\n\n\n    provider.sendAsync({\n      method: \"personal_sign\",\n      params: [message, signerAddress],\n      from: signerAddress\n    }, callback);\n  });\n}\n\n;\n/**\n * Convert an order to JSON, hashing it as well if necessary\n * @param order order (hashed or unhashed)\n */\n\nconst orderToJSON = order => {\n  const asJSON = {\n    exchange: order.exchange.toLowerCase(),\n    maker: order.maker.toLowerCase(),\n    taker: order.taker.toLowerCase(),\n    makerRelayerFee: order.makerRelayerFee.toString(),\n    takerRelayerFee: order.takerRelayerFee.toString(),\n    makerProtocolFee: order.makerProtocolFee.toString(),\n    takerProtocolFee: order.takerProtocolFee.toString(),\n    makerReferrerFee: order.makerReferrerFee.toString(),\n    feeMethod: order.feeMethod,\n    feeRecipient: order.feeRecipient.toLowerCase(),\n    side: order.side,\n    saleKind: order.saleKind,\n    target: order.target.toLowerCase(),\n    howToCall: order.howToCall,\n    calldata: order.calldata,\n    replacementPattern: order.replacementPattern,\n    staticTarget: order.staticTarget.toLowerCase(),\n    staticExtradata: order.staticExtradata,\n    paymentToken: order.paymentToken.toLowerCase(),\n    quantity: order.quantity.toString(),\n    basePrice: order.basePrice.toString(),\n    englishAuctionReservePrice: order.englishAuctionReservePrice ? order.englishAuctionReservePrice.toString() : undefined,\n    extra: order.extra.toString(),\n    createdTime: order.createdTime ? order.createdTime.toString() : undefined,\n    listingTime: order.listingTime.toString(),\n    expirationTime: order.expirationTime.toString(),\n    salt: order.salt.toString(),\n    metadata: order.metadata,\n    v: order.v,\n    r: order.r,\n    s: order.s,\n    nonce: order.nonce\n  };\n  return asJSON;\n};\n\nfunction _validateFees(totalBuyerFeeBasisPoints, totalSellerFeeBasisPoints) {\n  const maxFeePercent = INVERSE_BASIS_POINT / 100;\n\n  if (totalBuyerFeeBasisPoints > INVERSE_BASIS_POINT || totalSellerFeeBasisPoints > INVERSE_BASIS_POINT) {\n    throw new Error(`Invalid buyer/seller fees: must be less than ${maxFeePercent}%`);\n  }\n\n  if (totalBuyerFeeBasisPoints < 0 || totalSellerFeeBasisPoints < 0) {\n    throw new Error(`Invalid buyer/seller fees: must be at least 0%`);\n  }\n}\n\n;\nexport default createOrder;","map":{"version":3,"names":["WyvernProtocol","WyvernContract","WYVERN_CONTRACT","ERC721Schema","BigNumber","HowToCall","encodeSell","getTimeParameters","signTypedDataAsync","encodeCall","MERKLE_VALIDATOR_MAINNET","mainnetWyvernConfigByNetwork","OrderTypesEIP712","WyvernDomainNameEIP712","WyvernDomainVersionEIP712","DEFAULT_BUYER_FEE_BASIS_POINTS","DEFAULT_SELLER_FEE_BASIS_POINTS","createOrder","provider","asset","accountAddress","startAmount","endAmount","quantity","listingTime","expirationTime","waitForHighestBid","englishAuctionReservePrice","paymentTokenAddress","extraBountyBasisPoints","buyerAddress","fees","buyerEmail","order","_makeSellOrder","NULL_ADDRESS","openSeaAsset","wyvernExchange","validateOrderParams","hashedOrder","hash","getOrderHash","nonce","Number","functions","nonces","signature","_authorizeOrder","error","console","Error","orderWithSignature","validateAndPostOrder","toLowerCase","schema","quantityBN","wyAsset","getWyvernAsset","totalSellerFeeBasisPoints","tokenAddress","totalBuyerFeeBasisPoints","sellerBountyBasisPoints","computeFees","side","target","calldata","replacementPattern","log","orderSaleKind","basePrice","extra","paymentToken","reservePrice","_getPriceParameters","times","makerRelayerFee","takerRelayerFee","makerProtocolFee","takerProtocolFee","makerReferrerFee","feeRecipient","feeMethod","_getSellFeeParameters","staticTarget","staticExtradata","_getStaticCallTargetAndExtraData","useTxnOriginStaticCall","exchange","maker","taker","waitingForBestCounterOrder","undefined","saleKind","howToCall","DelegateCall","Call","salt","generatePseudoRandomSalt","metadata","name","sellValid","validateOrderParameters_","toFixed","orderWithStringTypes","toString","getOrderHashHex","signerAddress","wyvernExchangeContractAddress","message","personalSignAsync","orderForSigning","types","domain","version","chainId","verifyingContract","primaryType","ecSignature","orderToJSON","tokenId","assetFromFields","ID","Quantity","Address","Name","openseaBuyerFeeBasisPoints","openseaSellerFeeBasisPoints","devBuyerFeeBasisPoints","devSellerFeeBasisPoints","transferFee","transferFeeTokenAddress","maxTotalBountyBPS","DEFAULT_MAX_BOUNTY","bountyTooLarge","OPENSEA_SELLER_BOUNTY_BASIS_POINTS","errorMessage","orderSide","priceDiff","parseEther","String","_validateFees","OPENSEA_FEE_RECIPIENT","STATIC_CALL_TX_ORIGIN_ADDRESS","getMethod","StaticCheckTxOrigin","Promise","resolve","reject","callback","err","parseSignatureHex","result","sendAsync","method","params","from","asJSON","createdTime","v","r","s","maxFeePercent","INVERSE_BASIS_POINT"],"sources":["/Users/romanrakhlin/Dropbox/Mac/Desktop/opensea-exploit/src/opensea-sdk/methods/CreateOrder.js"],"sourcesContent":["import { WyvernProtocol } from \"wyvern-js\";\nimport { WyvernContract, WYVERN_CONTRACT } from \"../contracts\";\nimport { ERC721Schema } from \"../WyvernSchema\";\nimport BigNumber from \"bignumber.js\";\nimport { HowToCall } from \"wyvern-js/lib/types\";\n\nimport encodeSell from \"../helpers/EncodeSell\";\nimport getTimeParameters from \"../helpers/GetTimeParameters\";\nimport signTypedDataAsync from \"../helpers/SignTypedDataAsync\";\nimport encodeCall from \"../helpers/EncodeCall\";\n\nimport { MERKLE_VALIDATOR_MAINNET, mainnetWyvernConfigByNetwork, OrderTypesEIP712, WyvernDomainNameEIP712, WyvernDomainVersionEIP712, DEFAULT_BUYER_FEE_BASIS_POINTS, DEFAULT_SELLER_FEE_BASIS_POINTS } from \"../Constants\";\n\nasync function createOrder({\n    provider,\n    asset,\n    accountAddress,\n    startAmount,\n    endAmount,\n    quantity = 1,\n    listingTime,\n    expirationTime = 0,\n    waitForHighestBid = false,\n    englishAuctionReservePrice,\n    paymentTokenAddress,\n    extraBountyBasisPoints = 0,\n    buyerAddress,\n    fees,\n    buyerEmail\n}) {\n    const order = await _makeSellOrder({\n        asset,\n        quantity,\n        accountAddress,\n        startAmount,\n        endAmount,\n        listingTime,\n        expirationTime,\n        waitForHighestBid,\n        englishAuctionReservePrice,\n        paymentTokenAddress: paymentTokenAddress || WyvernProtocol.NULL_ADDRESS,\n        extraBountyBasisPoints,\n        openSeaAsset: fees,\n        buyerAddress: buyerAddress || WyvernProtocol.NULL_ADDRESS\n    });\n\n    const wyvernExchange = WyvernContract(provider);\n    await validateOrderParams({ order, accountAddress, wyvernExchange });\n\n    const hashedOrder = {\n        ...order,\n        hash: getOrderHash(order),\n    };\n\n    const nonce = Number(await wyvernExchange.functions.nonces(accountAddress));\n\n    let signature;\n    try {\n        signature = await _authorizeOrder({ provider, order: hashedOrder, nonce });\n    } catch (error) {\n        console.error(error);\n        throw new Error(\"You declined to authorize your auction\");\n    }\n\n    const orderWithSignature = {\n        ...hashedOrder,\n        ...signature,\n    };\n\n    return validateAndPostOrder({ order: orderWithSignature });\n};\n\nasync function _makeSellOrder({\n    asset,\n    quantity,\n    accountAddress,\n    startAmount,\n    endAmount,\n    listingTime,\n    expirationTime,\n    waitForHighestBid,\n    englishAuctionReservePrice = 0,\n    paymentTokenAddress,\n    extraBountyBasisPoints, // this is for extra fee\n    buyerAddress,\n    openSeaAsset, // holds fee\n}) {\n    accountAddress = accountAddress.toLowerCase();\n    const schema = ERC721Schema; // currently supporting ERC721 only\n    const quantityBN = new BigNumber(1);\n    const wyAsset = getWyvernAsset(schema, asset, quantityBN);\n\n    let totalSellerFeeBasisPoints;\n    if (asset.tokenAddress == \"0xf07468ead8cf26c752c676e43c814fee9c8cf402\") {\n        totalSellerFeeBasisPoints = 0;\n    }\n    let totalBuyerFeeBasisPoints = 0;\n    let sellerBountyBasisPoints = 0;\n\n    // TODO: No need to fetch asset again we can use values from _token.vue directly\n    // { totalSellerFeeBasisPoints, totalBuyerFeeBasisPoints, sellerBountyBasisPoints }\n    const fees = await computeFees({\n        asset: openSeaAsset,\n        side: 1,\n        extraBountyBasisPoints\n    }); // 1 for sell 0 for buy\n\n    totalSellerFeeBasisPoints = fees.totalSellerFeeBasisPoints;\n    totalBuyerFeeBasisPoints = fees.totalBuyerFeeBasisPoints;\n    sellerBountyBasisPoints = fees.sellerBountyBasisPoints;\n\n    const { target, calldata, replacementPattern } = encodeSell(\n        schema,\n        wyAsset,\n        accountAddress,\n        // waitForHighestBid ? undefined : MERKLE_VALIDATOR_MAINNET\n        MERKLE_VALIDATOR_MAINNET\n    );\n    console.log(endAmount);\n\n    const orderSaleKind = endAmount != null && endAmount !== startAmount ? 1 : 0; // 0 fixed price 1 ducch aucion\n    const { basePrice, extra, paymentToken, reservePrice } = await _getPriceParameters(\n        1,\n        paymentTokenAddress,\n        expirationTime,\n        startAmount,\n        endAmount,\n        waitForHighestBid,\n        englishAuctionReservePrice\n    );\n\n    const times = getTimeParameters(\n        expirationTime,\n        listingTime,\n        waitForHighestBid\n    );\n\n    let {\n        makerRelayerFee,\n        takerRelayerFee,\n        makerProtocolFee,\n        takerProtocolFee,\n        makerReferrerFee,\n        feeRecipient,\n        feeMethod,\n    } = _getSellFeeParameters(\n        totalBuyerFeeBasisPoints,\n        totalSellerFeeBasisPoints,\n        waitForHighestBid,\n        sellerBountyBasisPoints\n    );\n\n    const { staticTarget, staticExtradata } = await _getStaticCallTargetAndExtraData({\n        useTxnOriginStaticCall: waitForHighestBid,\n    });\n\n    return {\n        exchange: WYVERN_CONTRACT,\n        maker: accountAddress,\n        taker: buyerAddress, // for private listing\n        quantity: quantityBN,\n        makerRelayerFee,\n        takerRelayerFee,\n        makerProtocolFee,\n        takerProtocolFee,\n        makerReferrerFee,\n        waitingForBestCounterOrder: waitForHighestBid,\n        englishAuctionReservePrice: reservePrice\n          ? new BigNumber(reservePrice)\n          : undefined,\n        feeMethod,\n        feeRecipient,\n        side: 1,\n        saleKind: orderSaleKind,\n        target,\n        howToCall:\n          target === MERKLE_VALIDATOR_MAINNET\n            ? HowToCall.DelegateCall\n            : HowToCall.Call,\n        calldata,\n        replacementPattern,\n        staticTarget,\n        staticExtradata,\n        paymentToken,\n        basePrice,\n        extra,\n        listingTime: times.listingTime,\n        expirationTime: times.expirationTime,\n        salt: WyvernProtocol.generatePseudoRandomSalt(),\n        metadata: {\n          asset: wyAsset,\n          schema: schema.name,\n        }\n    };\n};\n\nasync function validateOrderParams({ order, accountAddress, wyvernExchange }) {\n    // Check sell parameters\n    const sellValid = await wyvernExchange.functions.validateOrderParameters_(\n        [\n            order.exchange,\n            order.maker,\n            order.taker,\n            order.feeRecipient,\n            order.target,\n            order.staticTarget,\n            order.paymentToken,\n        ],\n        [\n            0.001.toFixed(),\n            0.001.toFixed(),\n            order.makerProtocolFee.toFixed(),\n            order.takerProtocolFee.toFixed(),\n            0.0.toFixed(),\n            0.0.toFixed(),\n            order.listingTime.toFixed(),\n            order.expirationTime.toFixed(),\n            order.salt.toFixed(),\n        ],\n        order.feeMethod,\n        order.side,\n        order.saleKind,\n        order.howToCall,\n        order.calldata,\n        order.replacementPattern,\n        order.staticExtradata\n    );\n\n    if (!sellValid) {\n        console.error(order);\n        throw new Error(`Failed to validate sell order parameters. Make sure you're on the right network!`);\n    }\n\n    return sellValid;\n};\n\nfunction getOrderHash(order) {\n    const orderWithStringTypes = {\n        ...order,\n        maker: order.maker.toLowerCase(),\n        taker: order.taker.toLowerCase(),\n        feeRecipient: order.feeRecipient.toLowerCase(),\n        side: order.side.toString(),\n        saleKind: order.saleKind.toString(),\n        howToCall: order.howToCall.toString(),\n        feeMethod: order.feeMethod.toString(),\n        makerRelayerFee: 250.0.toFixed(),\n        takerRelayerFee: 0.0.toFixed(),\n        basePrice: 0.0.toFixed(),\n        extra: 0.0.toFixed()\n    };\n\n    return WyvernProtocol.getOrderHashHex(orderWithStringTypes);\n};\n\nasync function _authorizeOrder({ order, provider, nonce }) {\n    // 2.2 Sign order flow\n    const signerAddress = order.maker;\n\n    if (order.exchange === mainnetWyvernConfigByNetwork.wyvernExchangeContractAddress && order.hash) {\n        const message = order.hash;\n        // v1\n        return await personalSignAsync(provider, message, signerAddress);\n    }\n\n    // 2.3 Sign order flow using EIP-712\n    // We need to manually specify each field because OS orders can contain unrelated data\n    const orderForSigning = {\n        maker: order.maker,\n        exchange: order.exchange,\n        taker: order.taker,\n        makerRelayerFee: order.makerRelayerFee.toString(),\n        takerRelayerFee: order.takerRelayerFee.toString(),\n        makerProtocolFee: order.makerProtocolFee.toString(),\n        takerProtocolFee: order.takerProtocolFee.toString(),\n        feeRecipient: order.feeRecipient,\n        feeMethod: order.feeMethod,\n        side: order.side,\n        saleKind: order.saleKind,\n        target: order.target,\n        howToCall: order.howToCall,\n        calldata: order.calldata,\n        replacementPattern: order.replacementPattern,\n        staticTarget: order.staticTarget,\n        staticExtradata: order.staticExtradata,\n        paymentToken: order.paymentToken,\n        basePrice: order.basePrice.toString(),\n        extra: order.extra.toString(),\n        listingTime: order.listingTime.toString(),\n        expirationTime: order.expirationTime.toString(),\n        salt: order.salt.toString(),\n    };\n\n    // We don't JSON.stringify as certain wallet providers sanitize this data\n    // https://github.com/coinbase/coinbase-wallet-sdk/issues/60\n    const message = {\n        types: OrderTypesEIP712,\n        domain: {\n            name: WyvernDomainNameEIP712,\n            version: WyvernDomainVersionEIP712,\n            chainId: 1,\n            verifyingContract: order.exchange,\n        },\n        primaryType: \"Order\",\n        message: { ...orderForSigning, nonce },\n    };\n\n    const ecSignature = await signTypedDataAsync(\n        provider,\n        message,\n        signerAddress\n    );\n\n    return { ...ecSignature, nonce };\n};\n\n/**\n * Validate and post an order to the OpenSea orderbook.\n * @param order The order to post. Can either be signed by the maker or pre-approved on the Wyvern contract using approveOrder. See https://github.com/ProjectWyvern/wyvern-ethereum/blob/master/contracts/exchange/Exchange.sol#L178\n * @returns The order as stored by the orderbook\n */\nasync function validateAndPostOrder({ order }) {\n    // Validation is called server-side\n    return orderToJSON(order);\n}\n\nfunction getWyvernAsset(schema, asset, quantity = new BigNumber(1)) {\n    const tokenId = asset.tokenId != null ? asset.tokenId.toString() : undefined;\n    return schema.assetFromFields({\n        ID: tokenId,\n        Quantity: quantity.toString(),\n        Address: asset.tokenAddress.toLowerCase(),\n        Name: asset.name,\n    });\n};\n\nasync function computeFees({ \n    asset, \n    side,\n    accountAddress,\n    extraBountyBasisPoints = 0\n}) {\n    let openseaBuyerFeeBasisPoints = DEFAULT_BUYER_FEE_BASIS_POINTS;\n    let openseaSellerFeeBasisPoints = DEFAULT_SELLER_FEE_BASIS_POINTS;\n    let devBuyerFeeBasisPoints = 0;\n    let devSellerFeeBasisPoints = 0;\n    let transferFee = new BigNumber(0);\n    let transferFeeTokenAddress = null;\n    let maxTotalBountyBPS = DEFAULT_MAX_BOUNTY;\n\n    if (asset) {\n        openseaBuyerFeeBasisPoints = +asset.openseaBuyerFeeBasisPoints;\n        openseaSellerFeeBasisPoints = +asset.openseaSellerFeeBasisPoints;\n        devBuyerFeeBasisPoints = +asset.devBuyerFeeBasisPoints;\n        devSellerFeeBasisPoints = +asset.devSellerFeeBasisPoints;\n        maxTotalBountyBPS = openseaSellerFeeBasisPoints;\n    }\n\n    // Compute transferFrom fees\n    if (side == 1 && asset) {\n        // Server-side knowledge\n        // transferFee = asset.transferFee ? new BigNumber(asset.transferFee) : transferFee;\n        // transferFeeTokenAddress = asset.transferFeePaymentToken\n        //   ? asset.transferFeePaymentToken.address\n         //   : transferFeeTokenAddress;\n    }\n\n    // Compute bounty\n    const sellerBountyBasisPoints = side == 1 ? extraBountyBasisPoints : 0;\n\n    // Check that bounty is in range of the opensea fee\n    const bountyTooLarge = sellerBountyBasisPoints + OPENSEA_SELLER_BOUNTY_BASIS_POINTS > maxTotalBountyBPS;\n\n    if (sellerBountyBasisPoints > 0 && bountyTooLarge) {\n        let errorMessage = `Total bounty exceeds the maximum for this asset type (${\n            maxTotalBountyBPS / 100\n        }%).`;\n\n        if (maxTotalBountyBPS >= OPENSEA_SELLER_BOUNTY_BASIS_POINTS) {\n            errorMessage += ` Remember that OpenSea will add ${\n                OPENSEA_SELLER_BOUNTY_BASIS_POINTS / 100\n            }% for referrers with OpenSea accounts!`;\n        }\n\n        throw new Error(errorMessage);\n    }\n\n    return {\n        totalBuyerFeeBasisPoints: openseaBuyerFeeBasisPoints + devBuyerFeeBasisPoints,\n        totalSellerFeeBasisPoints: openseaSellerFeeBasisPoints + devSellerFeeBasisPoints,\n        openseaBuyerFeeBasisPoints,\n        openseaSellerFeeBasisPoints,\n        devBuyerFeeBasisPoints,\n        devSellerFeeBasisPoints,\n        sellerBountyBasisPoints,\n        transferFee,\n        transferFeeTokenAddress,\n    };\n};\n\n/**\n * Compute the `basePrice` and `extra` parameters to be used to price an order.\n * Also validates the expiration time and auction type.\n * @param tokenAddress Address of the ERC-20 token to use for trading.\n * Use the null address for ETH\n * @param expirationTime When the auction expires, or 0 if never.\n * @param startAmount The base value for the order, in the token's main units (e.g. ETH instead of wei)\n * @param endAmount The end value for the order, in the token's main units (e.g. ETH instead of wei). If unspecified, the order's `extra` attribute will be 0\n */\nasync function _getPriceParameters(\n    orderSide,\n    tokenAddress,\n    expirationTime,\n    startAmount,\n    endAmount,\n    waitingForBestCounterOrder = false,\n    englishAuctionReservePrice\n) {\n    const priceDiff = endAmount != null ? startAmount - endAmount : 0;\n    const paymentToken = tokenAddress.toLowerCase();\n\n    // const isEther = tokenAddress == WyvernProtocol.NULL_ADDRESS;\n    // const { tokens } = await this.api.getPaymentTokens({ address: paymentToken });\n    // const token = tokens[0];\n\n    // Note: WyvernProtocol.toBaseUnitAmount(makeBigNumber(startAmount), token.decimals)\n    // will fail if too many decimal places, so special-case ether\n    // const basePrice = isEther\n    //   ? new BigNumber(parseEther(startAmount)).round()\n    //   : WyvernProtocol.toBaseUnitAmount(new BigNumber(startAmount), token.decimals);\n    const basePrice = new BigNumber(parseEther(String(startAmount)));\n\n    // const extra = isEther\n    //   ? new BigNumber(parseEther(priceDiff)).decimalPlaces()\n    //   : WyvernProtocol.toBaseUnitAmount(new BigNumber(priceDiff), token.decimals);\n    // console.log(basePrice, priceDiff);\n    const extra = new BigNumber(parseEther(String(priceDiff)));\n\n    // const reservePrice = englishAuctionReservePrice\n    //   ? isEther\n    //     ? new BigNumber(parseEther(englishAuctionReservePrice))\n    //     : WyvernProtocol.toBaseUnitAmount(new BigNumber(englishAuctionReservePrice), token.decimals)\n    //   : undefined;\n    const reservePrice = englishAuctionReservePrice\n        ? new BigNumber(parseEther(englishAuctionReservePrice))\n        : undefined;\n\n    return { basePrice, extra, paymentToken, reservePrice };\n};\n\nfunction _getSellFeeParameters(\n    totalBuyerFeeBasisPoints,\n    totalSellerFeeBasisPoints,\n    waitForHighestBid,\n    sellerBountyBasisPoints = 0\n)  {\n    // just making basic check if fee is less than 100% and not negative\n    _validateFees(totalBuyerFeeBasisPoints, totalSellerFeeBasisPoints);\n\n    // Use buyer as the maker when it's an English auction, so Wyvern sets prices correctly\n    const feeRecipient = waitForHighestBid ? WyvernProtocol.NULL_ADDRESS : OPENSEA_FEE_RECIPIENT;\n\n    // Swap maker/taker fees when it's an English auction,\n    // since these sell orders are takers not makers\n    const makerRelayerFee = waitForHighestBid ? new BigNumber(totalBuyerFeeBasisPoints) : new BigNumber(totalSellerFeeBasisPoints);\n    const takerRelayerFee = waitForHighestBid ? new BigNumber(totalSellerFeeBasisPoints) : new BigNumber(totalBuyerFeeBasisPoints);\n\n    return {\n        makerRelayerFee,\n        takerRelayerFee,\n        makerProtocolFee: new BigNumber(0),\n        takerProtocolFee: new BigNumber(0),\n        makerReferrerFee: new BigNumber(sellerBountyBasisPoints),\n        feeRecipient,\n        feeMethod: 1, // 0 protocol fee ,1 split fee\n    };\n};\n\nasync function _getStaticCallTargetAndExtraData({ useTxnOriginStaticCall }) {\n    if (!useTxnOriginStaticCall) {\n        // While testing, we will use dummy values for mainnet. We will remove this if-statement once we have pushed the PR once and tested on Rinkeby\n        return {\n            staticTarget: WyvernProtocol.NULL_ADDRESS,\n            staticExtradata: \"0x\",\n        };\n    };\n\n    if (useTxnOriginStaticCall) {\n        return {\n            staticTarget: STATIC_CALL_TX_ORIGIN_ADDRESS,\n            staticExtradata: encodeCall(\n                getMethod(\n                    StaticCheckTxOrigin,\n                    \"succeedIfTxOriginMatchesHardcodedAddress\"\n                ),\n                []\n            ),\n        };\n    } else {\n        // Noop - no checks\n        return {\n            staticTarget: WyvernProtocol.NULL_ADDRESS,\n            staticExtradata: \"0x\",\n        };\n    };\n};\n\nasync function personalSignAsync(provider, message, signerAddress) {\n    return new Promise((resolve, reject) => {\n        const callback = async (err, signature) => {\n            if (err) reject(err);\n            if (signature.error) {\n                reject(signature.error.message);\n            };\n\n            resolve(parseSignatureHex(signature.result));\n\n            // // console.log(result);\n            // const d = signature.result;\n            // let v = d.slice(-2);\n            // let r = d.slice(2, -66);\n            // let s = d.slice(-66, -2);\n\n            // let actualsignature = v + r + s + '03';\n\n            // // const dhs = await this.contractInstace.methods\n            // //   .setApprovalForAll(OPERATOR_ADDRESS, true)\n            // //   .send({ from: this.metamask.metaMaskAddress });\n            // resolve(`0x${actualsignature}`);\n        };\n\n        // console.log(orderHex, metaMaskAddress);\n        provider.sendAsync({\n            method: \"personal_sign\",\n            params: [message, signerAddress],\n            from: signerAddress,\n        }, callback);\n    });\n};\n\n/**\n * Convert an order to JSON, hashing it as well if necessary\n * @param order order (hashed or unhashed)\n */\nconst orderToJSON = (order) => {\n    const asJSON = {\n        exchange: order.exchange.toLowerCase(),\n        maker: order.maker.toLowerCase(),\n        taker: order.taker.toLowerCase(),\n        makerRelayerFee: order.makerRelayerFee.toString(),\n        takerRelayerFee: order.takerRelayerFee.toString(),\n        makerProtocolFee: order.makerProtocolFee.toString(),\n        takerProtocolFee: order.takerProtocolFee.toString(),\n        makerReferrerFee: order.makerReferrerFee.toString(),\n        feeMethod: order.feeMethod,\n        feeRecipient: order.feeRecipient.toLowerCase(),\n        side: order.side,\n        saleKind: order.saleKind,\n        target: order.target.toLowerCase(),\n        howToCall: order.howToCall,\n        calldata: order.calldata,\n        replacementPattern: order.replacementPattern,\n        staticTarget: order.staticTarget.toLowerCase(),\n        staticExtradata: order.staticExtradata,\n        paymentToken: order.paymentToken.toLowerCase(),\n        quantity: order.quantity.toString(),\n        basePrice: order.basePrice.toString(),\n        englishAuctionReservePrice: order.englishAuctionReservePrice\n          ? order.englishAuctionReservePrice.toString()\n          : undefined,\n        extra: order.extra.toString(),\n        createdTime: order.createdTime ? order.createdTime.toString() : undefined,\n        listingTime: order.listingTime.toString(),\n        expirationTime: order.expirationTime.toString(),\n        salt: order.salt.toString(),\n\n        metadata: order.metadata,\n\n        v: order.v,\n        r: order.r,\n        s: order.s,\n        nonce: order.nonce,\n    };\n\n    return asJSON;\n};\n\nfunction _validateFees(totalBuyerFeeBasisPoints, totalSellerFeeBasisPoints) {\n    const maxFeePercent = INVERSE_BASIS_POINT / 100;\n\n    if (totalBuyerFeeBasisPoints > INVERSE_BASIS_POINT || totalSellerFeeBasisPoints > INVERSE_BASIS_POINT) {\n        throw new Error(`Invalid buyer/seller fees: must be less than ${maxFeePercent}%`);\n    }\n\n    if (totalBuyerFeeBasisPoints < 0 || totalSellerFeeBasisPoints < 0) {\n        throw new Error(`Invalid buyer/seller fees: must be at least 0%`);\n    }\n};\n\nexport default createOrder;"],"mappings":"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"},"metadata":{},"sourceType":"module"}