{"ast":null,"code":"// Wyvern\nimport { WyvernProtocol } from \"wyvern-js\";\nimport { HowToCall, Network } from \"wyvern-js/lib/types\";\nimport { ERC721Schema } from \"./WyvernSchema\"; // Ethereum\n\nimport * as ethABI from \"ethereumjs-abi\";\nimport * as ethUtil from \"ethereumjs-util\";\nimport isValidAddress from \"ethereumjs-util\";\nimport { parseEther } from \"@ethersproject/units\";\nimport BigNumber from \"bignumber.js\"; // Other\n\nimport axios from \"axios\";\nimport * as _ from \"lodash\"; // Constants\n\nimport { OPENSEA_URL, X_API_KEY } from \"./Constants\";\nimport { ACTIVITY_POLLING_INTERVAL, LISTING_POLLING_INTERVAL, OFFERS_POLLING_INTERVAL } from \"./Constants\";\nimport { MIN_EXPIRATION_SECONDS, ORDER_MATCHING_LATENCY_SECONDS, OPENSEA_FEE_RECIPIENT, NULL_BLOCK_HASH, INVERSE_BASIS_POINT, DEFAULT_BUYER_FEE_BASIS_POINTS, DEFAULT_SELLER_FEE_BASIS_POINTS, OPENSEA_SELLER_BOUNTY_BASIS_POINTS, DEFAULT_MAX_BOUNTY, STATIC_CALL_TX_ORIGIN_ADDRESS, MERKLE_VALIDATOR_MAINNET } from \"./Constants\";\nimport { mainnetWyvernConfigByNetwork } from \"./Constants\";\nimport { OrderTypesEIP712, WyvernDomainNameEIP712, WyvernDomainVersionEIP712 } from \"./Constants\";\nimport { StaticCheckTxOrigin } from \"./Constants\"; // Contracts\n\nimport { WyvernContract, WYVERN_CONTRACT } from \"./contracts\"; // Methods\n\nimport createOrder from \"./methods/CreateOrder\"; // FUNCTIONS\n\nconst tokenFromJSON = token => {\n  const fromJSON = {\n    name: token.name,\n    symbol: token.symbol,\n    decimals: token.decimals,\n    address: token.address,\n    imageUrl: token.image_url,\n    ethPrice: token.eth_price,\n    usdPrice: token.usd_price\n  };\n  return fromJSON;\n};\n\nconst merkleValidatorByNetwork = {\n  main: MERKLE_VALIDATOR_MAINNET\n};\n\nconst orderFromJSON = order => {\n  const createdDate = new Date(`${order.created_date}Z`);\n  const fromJSON = {\n    hash: order.order_hash || order.hash,\n    cancelledOrFinalized: order.cancelled || order.finalized,\n    markedInvalid: order.marked_invalid,\n    metadata: order.metadata,\n    quantity: new BigNumber(order.quantity || 1),\n    exchange: order.exchange,\n    makerAccount: order.maker,\n    takerAccount: order.taker,\n    // Use string address to conform to Wyvern Order schema\n    maker: order.maker.address,\n    taker: order.taker.address,\n    makerRelayerFee: new BigNumber(order.maker_relayer_fee),\n    takerRelayerFee: new BigNumber(order.taker_relayer_fee),\n    makerProtocolFee: new BigNumber(order.maker_protocol_fee),\n    takerProtocolFee: new BigNumber(order.taker_protocol_fee),\n    makerReferrerFee: new BigNumber(order.maker_referrer_fee || 0),\n    waitingForBestCounterOrder: order.fee_recipient.address == WyvernProtocol.NULL_ADDRESS,\n    feeMethod: order.fee_method,\n    feeRecipientAccount: order.fee_recipient,\n    feeRecipient: order.fee_recipient.address,\n    side: order.side,\n    saleKind: order.sale_kind,\n    target: order.target,\n    howToCall: order.how_to_call,\n    calldata: order.calldata,\n    replacementPattern: order.replacement_pattern,\n    staticTarget: order.static_target,\n    staticExtradata: order.static_extradata,\n    paymentToken: order.payment_token,\n    basePrice: new BigNumber(order.base_price),\n    extra: new BigNumber(order.extra),\n    currentBounty: new BigNumber(order.current_bounty || 0),\n    currentPrice: new BigNumber(order.current_price || 0),\n    createdTime: new BigNumber(Math.round(createdDate.getTime() / 1000)),\n    listingTime: new BigNumber(order.listing_time),\n    expirationTime: new BigNumber(order.expiration_time),\n    salt: new BigNumber(order.salt),\n    v: parseInt(order.v),\n    r: order.r,\n    s: order.s,\n    paymentTokenContract: order.payment_token_contract ? tokenFromJSON(order.payment_token_contract) : undefined,\n    asset: order.asset,\n    assetBundle: order.asset_bundle\n  }; // Use client-side price calc, to account for buyer fee (not added by server) and latency\n\n  fromJSON.currentPrice = estimateCurrentPrice(fromJSON);\n  return fromJSON;\n};\n\nconst _getTimeParameters = function (expirationTimestamp, listingTimestamp) {\n  let waitingForBestCounterOrder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  // Validation\n  const minListingTimestamp = Math.round(Date.now() / 1000);\n  const minExpirationTimestamp = Math.round(Date.now() / 1000 + MIN_EXPIRATION_SECONDS);\n\n  if (expirationTimestamp != 0 && expirationTimestamp < minExpirationTimestamp) {\n    throw new Error(`Expiration time must be at least ${MIN_EXPIRATION_SECONDS} seconds from now, or zero (non-expiring).`);\n  }\n\n  if (listingTimestamp && listingTimestamp < minListingTimestamp) {\n    throw new Error(\"Listing time cannot be in the past.\");\n  }\n\n  if (listingTimestamp && expirationTimestamp != 0 && listingTimestamp >= expirationTimestamp) {\n    throw new Error(\"Listing time must be before the expiration time.\");\n  }\n\n  if (waitingForBestCounterOrder && expirationTimestamp == 0) {\n    throw new Error(\"English auctions must have an expiration time.\");\n  }\n\n  if (waitingForBestCounterOrder && listingTimestamp) {\n    throw new Error(`Cannot schedule an English auction for the future.`);\n  }\n\n  if (parseInt(expirationTimestamp.toString()) != expirationTimestamp) {\n    throw new Error(`Expiration timestamp must be a whole number of seconds`);\n  }\n\n  if (waitingForBestCounterOrder) {\n    listingTimestamp = expirationTimestamp; // Expire one week from now, to ensure server can match it\n    // Later, this will expire closer to the listingTime\n\n    expirationTimestamp = expirationTimestamp + ORDER_MATCHING_LATENCY_SECONDS;\n  } else {\n    // Small offset to account for latency\n    listingTimestamp = listingTimestamp || Math.round(Date.now() / 1000 - 100);\n  }\n\n  return {\n    listingTime: BigNumber(listingTimestamp),\n    expirationTime: BigNumber(expirationTimestamp)\n  };\n};\n\nconst encodeCall = (abi, parameters) => {\n  const inputTypes = abi.inputs.map(i => i.type);\n  const id = ethABI.methodID(abi.name, inputTypes);\n  const encode = ethABI.rawEncode(inputTypes.slice(0, 3), parameters.slice(0, 3));\n  return \"0x\" + Buffer.concat([id, encode]).toString(\"hex\");\n};\n\nconst encodeDefaultCall = (abi, address) => {\n  const parameters = abi.inputs.map(input => {\n    switch (input.kind) {\n      case \"replaceable\":\n        return WyvernProtocol.generateDefaultValue(input.type);\n\n      case \"owner\":\n        return address;\n\n      case \"asset\":\n      default:\n        return input.value;\n    }\n  });\n  return encodeCall(abi, parameters);\n};\n\nconst encodeSell = (schema, asset, address, validatorAddress) => {\n  const transfer = validatorAddress && schema.functions.checkAndTransfer ? schema.functions.checkAndTransfer(asset, validatorAddress) : schema.functions.transfer(asset); // const transfer = schema.functions.transfer(asset);\n\n  let defaultCall = encodeDefaultCall(transfer, address);\n  let pattern = WyvernProtocol.encodeReplacementPattern(transfer);\n  return {\n    target: transfer.target,\n    calldata: defaultCall,\n    replacementPattern: pattern\n  };\n};\n\nconst encodeBuy = (schema, asset, address, validatorAddress) => {\n  // const transfer = schema.functions.transfer(asset);\n  const transfer = validatorAddress && schema.functions.checkAndTransfer ? schema.functions.checkAndTransfer(asset, validatorAddress) : schema.functions.transfer(asset);\n  const replaceables = transfer.inputs.filter(i => i.kind === \"replaceable\");\n  const ownerInputs = transfer.inputs.filter(i => i.kind === \"owner\"); // Validate\n\n  if (replaceables.length !== 1) {\n    throw new Error(\"Only 1 input can match transfer destination, but instead \" + replaceables.length + \" did\");\n  } // Compute calldata\n\n\n  const parameters = transfer.inputs.map(input => {\n    switch (input.kind) {\n      case \"replaceable\":\n        return address;\n\n      case \"owner\":\n        return WyvernProtocol.generateDefaultValue(input.type);\n\n      default:\n        try {\n          return input.value.toString();\n        } catch (e) {\n          console.error(schema);\n          console.error(asset);\n          throw e;\n        }\n\n    }\n  });\n  const calldata = encodeCall(transfer, parameters); // Compute replacement pattern\n\n  let replacementPattern = \"0x\";\n\n  if (ownerInputs.length > 0) {\n    replacementPattern = WyvernProtocol.encodeReplacementPattern(transfer, \"owner\");\n  }\n\n  return {\n    target: transfer.target,\n    calldata,\n    replacementPattern\n  };\n};\n\nfunction getOrderHash(order) {\n  const orderWithStringTypes = { ...order,\n    maker: order.maker.toLowerCase(),\n    taker: order.taker.toLowerCase(),\n    feeRecipient: order.feeRecipient.toLowerCase(),\n    side: order.side.toString(),\n    saleKind: order.saleKind.toString(),\n    howToCall: order.howToCall.toString(),\n    feeMethod: order.feeMethod.toString(),\n    makerRelayerFee: 250.0.toFixed(),\n    takerRelayerFee: 0.0.toFixed(),\n    basePrice: 0.0.toFixed(),\n    extra: 0.0.toFixed()\n  };\n  return WyvernProtocol.getOrderHashHex(orderWithStringTypes);\n}\n\nfunction makeMatchingOrder(_ref) {\n  let {\n    order,\n    accountAddress,\n    recipientAddress\n  } = _ref;\n  accountAddress = accountAddress.toLowerCase();\n  recipientAddress = recipientAddress.toLowerCase();\n\n  const computeOrderParams = () => {\n    const shouldValidate = order.target === merkleValidatorByNetwork.main;\n\n    if (\"asset\" in order.metadata) {\n      const schema = ERC721Schema; // currently supporting ERC721 only\n\n      return order.side == 0 ? encodeSell(schema, order.metadata.asset, recipientAddress, shouldValidate ? order.target : undefined) : encodeBuy(schema, order.metadata.asset, recipientAddress, shouldValidate ? order.target : undefined);\n    } else {\n      throw new Error(\"Invalid order metadata\");\n    }\n  };\n\n  const {\n    target,\n    calldata,\n    replacementPattern\n  } = computeOrderParams();\n\n  const times = _getTimeParameters(0); // Compat for matching buy orders that have fee recipient still on them\n\n\n  const feeRecipient = OPENSEA_FEE_RECIPIENT; // Maybe NULLADDRESS\n\n  const matchingOrder = {\n    exchange: order.exchange,\n    maker: accountAddress,\n    taker: order.maker,\n    quantity: order.quantity,\n    makerRelayerFee: order.makerRelayerFee,\n    takerRelayerFee: order.takerRelayerFee,\n    makerProtocolFee: order.makerProtocolFee,\n    takerProtocolFee: order.takerProtocolFee,\n    makerReferrerFee: order.makerReferrerFee,\n    waitingForBestCounterOrder: false,\n    feeMethod: order.feeMethod,\n    feeRecipient,\n    side: (order.side + 1) % 2,\n    saleKind: 0,\n    // 0 fixed price 1 ducch aucion\n    target,\n    howToCall: order.howToCall,\n    calldata,\n    replacementPattern,\n    staticTarget: WyvernProtocol.NULL_ADDRESS,\n    staticExtradata: \"0x\",\n    paymentToken: order.paymentToken,\n    basePrice: order.basePrice,\n    extra: BigNumber(0),\n    listingTime: times.listingTime,\n    expirationTime: times.expirationTime,\n    salt: WyvernProtocol.generatePseudoRandomSalt(),\n    metadata: order.metadata\n  };\n  return matchingOrder;\n}\n\nfunction assignOrdersToSides(order, matchingOrder) {\n  const isSellOrder = order.side == 1;\n  let buy;\n  let sell;\n\n  if (!isSellOrder) {\n    buy = order;\n    sell = { ...matchingOrder,\n      v: buy.v,\n      r: buy.r,\n      s: buy.s\n    };\n  } else {\n    sell = order;\n    buy = { ...matchingOrder,\n      v: sell.v,\n      r: sell.r,\n      s: sell.s\n    };\n  }\n\n  return {\n    buy,\n    sell\n  };\n}\n\nconst _getMetadata = (order, referrerAddress) => {\n  const referrer = referrerAddress || order.metadata.referrerAddress;\n\n  if (referrer && isValidAddress(referrer)) {\n    return `0x000000000000000000000000${referrer.substr(2)}`;\n  }\n\n  return undefined;\n};\n\nconst _correctGasAmount = estimation => {\n  return Math.ceil(estimation * 1.01);\n};\n/**\n * Gets the price for the order using the contract\n * @param order The order to calculate the price for\n */\n\n\nasync function getCurrentPrice(order, wyvernExchange) {\n  const currentPrice = await wyvernExchange.methods.calculateCurrentPrice_([order.exchange, order.maker, order.taker, order.feeRecipient, order.target, order.staticTarget, order.paymentToken], [order.makerRelayerFee.toFixed(), order.takerRelayerFee.toFixed(), order.makerProtocolFee.toFixed(), order.takerProtocolFee.toFixed(), order.basePrice.toFixed(), order.extra.toFixed(), order.listingTime.toFixed(), order.expirationTime.toFixed(), order.salt.toFixed()], order.feeMethod, order.side, order.saleKind, order.howToCall, order.calldata, order.replacementPattern, order.staticExtradata);\n  return currentPrice;\n}\n/**\n * Estimates the price of an order\n * @param order The order to estimate price on\n * @param secondsToBacktrack The number of seconds to subtract on current time,\n *  to fix race conditions\n * @param shouldRoundUp Whether to round up fractional wei\n */\n\n\nexport function estimateCurrentPrice(order) {\n  let secondsToBacktrack = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 30;\n  let shouldRoundUp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  // round up should be enabled\n  let {\n    basePrice,\n    listingTime,\n    expirationTime,\n    extra\n  } = order;\n  const {\n    side,\n    takerRelayerFee,\n    saleKind\n  } = order;\n  const now = new BigNumber(Math.round(Date.now() / 1000)).minus(secondsToBacktrack);\n  basePrice = new BigNumber(basePrice);\n  listingTime = new BigNumber(listingTime);\n  expirationTime = new BigNumber(expirationTime);\n  extra = new BigNumber(extra);\n  let exactPrice = basePrice; // saleKind 0 : Fixed price 1: Duction acution\n\n  if (saleKind === 0) {// Do nothing, price is correct\n  } else if (saleKind === 1) {\n    const diff = extra.times(now.minus(listingTime)).dividedBy(expirationTime.minus(listingTime)); // side 0 : buy 1: sell\n\n    exactPrice = side == 1 ?\n    /* Sell-side - start price: basePrice. End price: basePrice - extra. */\n    basePrice.minus(diff) :\n    /* Buy-side - start price: basePrice. End price: basePrice + extra. */\n    basePrice.plus(diff);\n  } // Add taker fee only for buyers\n\n\n  if (side === 1 && !order.waitingForBestCounterOrder) {\n    // Buyer fee increases sale price\n    exactPrice = exactPrice.times(+takerRelayerFee / INVERSE_BASIS_POINT + 1);\n  }\n\n  return shouldRoundUp ? exactPrice.ceil() : exactPrice;\n}\n\nasync function _getRequiredAmountForTakingSellOrder(sell, wyvernExchange) {\n  const currentPrice = await getCurrentPrice(sell, wyvernExchange);\n  const estimatedPrice = estimateCurrentPrice(sell);\n  const maxPrice = BigNumber.max(currentPrice, estimatedPrice); // TODO Why is this not always a big number?\n\n  sell.takerRelayerFee = BigNumber(sell.takerRelayerFee);\n  const feePercentage = sell.takerRelayerFee.div(INVERSE_BASIS_POINT);\n  const fee = feePercentage.times(maxPrice);\n  return fee.plus(maxPrice); // use .ceil()\n}\n\nasync function _atomicMatch(_ref2) {\n  let {\n    buy,\n    sell,\n    accountAddress,\n    wyvernExchange,\n    metadata = NULL_BLOCK_HASH\n  } = _ref2;\n  let value;\n\n  if (buy.paymentToken == WyvernProtocol.NULL_ADDRESS) {\n    value = await _getRequiredAmountForTakingSellOrder(sell, wyvernExchange);\n  }\n\n  const txnData = {\n    from: accountAddress,\n    value\n  };\n  const args = [[buy.exchange, buy.maker, buy.taker, buy.feeRecipient, buy.target, buy.staticTarget, buy.paymentToken, sell.exchange, sell.maker, sell.taker, sell.feeRecipient, sell.target, sell.staticTarget, sell.paymentToken], [250.0.toString(), 0.0.toString(), buy.makerProtocolFee.toString(), buy.takerProtocolFee.toString(), 0.0.toString(), buy.extra.toString(), buy.listingTime.toString(), buy.expirationTime.toString(), buy.salt.toString(), 250.0.toString(), 0.0.toString(), sell.makerProtocolFee.toString(), sell.takerProtocolFee.toString(), 0.0.toString(), 0.0.toString(), sell.listingTime.toString(), sell.expirationTime.toString(), sell.salt.toString()], [buy.feeMethod, buy.side, buy.saleKind, buy.howToCall, sell.feeMethod, sell.side, sell.saleKind, sell.howToCall], buy.calldata, sell.calldata, buy.replacementPattern, sell.replacementPattern, buy.staticExtradata, sell.staticExtradata, [buy.v || 0, sell.v || 0], [buy.r || NULL_BLOCK_HASH, buy.s || NULL_BLOCK_HASH, sell.r || NULL_BLOCK_HASH, sell.s || NULL_BLOCK_HASH, metadata]]; // const gasEstimate = await wyvernExchange.functions.estimateGasAsync(txnData);\n  // txnData.gas = _correctGasAmount(gasEstimate);\n\n  const atomicMatchMethod = wyvernExchange.functions.atomicMatch_(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], txnData).then(res => {\n    console.log(res);\n  });\n  return {\n    atomicMatchMethod,\n    txnData\n  };\n}\n\nasync function fulfillOrder(_ref3) {\n  let {\n    order,\n    provider,\n    accountAddress,\n    recipientAddress,\n    referrerAddress\n  } = _ref3;\n  console.info(`Account: ${accountAddress} | Recipient: ${recipientAddress} | Referrer: ${referrerAddress}`); // check if valid order\n\n  const wyvernExchange = WyvernContract(provider);\n  const isValid = await validateOrder({\n    order,\n    accountAddress,\n    wyvernExchange\n  });\n  const matchingOrder = makeMatchingOrder({\n    order,\n    accountAddress,\n    recipientAddress: recipientAddress\n  });\n  const {\n    buy,\n    sell\n  } = assignOrdersToSides(order, matchingOrder);\n\n  const metadata = _getMetadata(order, referrerAddress);\n\n  return await _atomicMatch({\n    buy,\n    sell,\n    accountAddress,\n    wyvernExchange,\n    metadata\n  });\n}\n\nfunction getWyvernAsset(schema, asset) {\n  let quantity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new BigNumber(1);\n  const tokenId = asset.tokenId != null ? asset.tokenId.toString() : undefined;\n  return schema.assetFromFields({\n    ID: tokenId,\n    Quantity: quantity.toString(),\n    Address: asset.tokenAddress.toLowerCase(),\n    Name: asset.name\n  });\n}\n\nasync function computeFees(_ref4) {\n  let {\n    asset,\n    side,\n    accountAddress,\n    extraBountyBasisPoints = 0\n  } = _ref4;\n  let openseaBuyerFeeBasisPoints = DEFAULT_BUYER_FEE_BASIS_POINTS;\n  let openseaSellerFeeBasisPoints = DEFAULT_SELLER_FEE_BASIS_POINTS;\n  let devBuyerFeeBasisPoints = 0;\n  let devSellerFeeBasisPoints = 0;\n  let transferFee = new BigNumber(0);\n  let transferFeeTokenAddress = null;\n  let maxTotalBountyBPS = DEFAULT_MAX_BOUNTY;\n\n  if (asset) {\n    openseaBuyerFeeBasisPoints = +asset.openseaBuyerFeeBasisPoints;\n    openseaSellerFeeBasisPoints = +asset.openseaSellerFeeBasisPoints;\n    devBuyerFeeBasisPoints = +asset.devBuyerFeeBasisPoints;\n    devSellerFeeBasisPoints = +asset.devSellerFeeBasisPoints;\n    maxTotalBountyBPS = openseaSellerFeeBasisPoints;\n  } // Compute transferFrom fees\n\n\n  if (side == 1 && asset) {// Server-side knowledge\n    // transferFee = asset.transferFee ? new BigNumber(asset.transferFee) : transferFee;\n    // transferFeeTokenAddress = asset.transferFeePaymentToken\n    //   ? asset.transferFeePaymentToken.address\n    //   : transferFeeTokenAddress;\n  } // Compute bounty\n\n\n  const sellerBountyBasisPoints = side == 1 ? extraBountyBasisPoints : 0; // Check that bounty is in range of the opensea fee\n\n  const bountyTooLarge = sellerBountyBasisPoints + OPENSEA_SELLER_BOUNTY_BASIS_POINTS > maxTotalBountyBPS;\n\n  if (sellerBountyBasisPoints > 0 && bountyTooLarge) {\n    let errorMessage = `Total bounty exceeds the maximum for this asset type (${maxTotalBountyBPS / 100}%).`;\n\n    if (maxTotalBountyBPS >= OPENSEA_SELLER_BOUNTY_BASIS_POINTS) {\n      errorMessage += ` Remember that OpenSea will add ${OPENSEA_SELLER_BOUNTY_BASIS_POINTS / 100}% for referrers with OpenSea accounts!`;\n    }\n\n    throw new Error(errorMessage);\n  }\n\n  return {\n    totalBuyerFeeBasisPoints: openseaBuyerFeeBasisPoints + devBuyerFeeBasisPoints,\n    totalSellerFeeBasisPoints: openseaSellerFeeBasisPoints + devSellerFeeBasisPoints,\n    openseaBuyerFeeBasisPoints,\n    openseaSellerFeeBasisPoints,\n    devBuyerFeeBasisPoints,\n    devSellerFeeBasisPoints,\n    sellerBountyBasisPoints,\n    transferFee,\n    transferFeeTokenAddress\n  };\n}\n/**\n * Compute the `basePrice` and `extra` parameters to be used to price an order.\n * Also validates the expiration time and auction type.\n * @param tokenAddress Address of the ERC-20 token to use for trading.\n * Use the null address for ETH\n * @param expirationTime When the auction expires, or 0 if never.\n * @param startAmount The base value for the order, in the token's main units (e.g. ETH instead of wei)\n * @param endAmount The end value for the order, in the token's main units (e.g. ETH instead of wei). If unspecified, the order's `extra` attribute will be 0\n */\n\n\nasync function _getPriceParameters(orderSide, tokenAddress, expirationTime, startAmount, endAmount) {\n  let waitingForBestCounterOrder = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  let englishAuctionReservePrice = arguments.length > 6 ? arguments[6] : undefined;\n  const priceDiff = endAmount != null ? startAmount - endAmount : 0;\n  const paymentToken = tokenAddress.toLowerCase(); // const isEther = tokenAddress == WyvernProtocol.NULL_ADDRESS;\n  // const { tokens } = await this.api.getPaymentTokens({ address: paymentToken });\n  // const token = tokens[0];\n  // Note: WyvernProtocol.toBaseUnitAmount(makeBigNumber(startAmount), token.decimals)\n  // will fail if too many decimal places, so special-case ether\n  // const basePrice = isEther\n  //   ? new BigNumber(parseEther(startAmount)).round()\n  //   : WyvernProtocol.toBaseUnitAmount(new BigNumber(startAmount), token.decimals);\n\n  const basePrice = new BigNumber(parseEther(String(startAmount))); // const extra = isEther\n  //   ? new BigNumber(parseEther(priceDiff)).decimalPlaces()\n  //   : WyvernProtocol.toBaseUnitAmount(new BigNumber(priceDiff), token.decimals);\n  // console.log(basePrice, priceDiff);\n\n  const extra = new BigNumber(parseEther(String(priceDiff))); // const reservePrice = englishAuctionReservePrice\n  //   ? isEther\n  //     ? new BigNumber(parseEther(englishAuctionReservePrice))\n  //     : WyvernProtocol.toBaseUnitAmount(new BigNumber(englishAuctionReservePrice), token.decimals)\n  //   : undefined;\n\n  const reservePrice = englishAuctionReservePrice ? new BigNumber(parseEther(englishAuctionReservePrice)) : undefined;\n  return {\n    basePrice,\n    extra,\n    paymentToken,\n    reservePrice\n  };\n}\n\nfunction _validateFees(totalBuyerFeeBasisPoints, totalSellerFeeBasisPoints) {\n  const maxFeePercent = INVERSE_BASIS_POINT / 100;\n\n  if (totalBuyerFeeBasisPoints > INVERSE_BASIS_POINT || totalSellerFeeBasisPoints > INVERSE_BASIS_POINT) {\n    throw new Error(`Invalid buyer/seller fees: must be less than ${maxFeePercent}%`);\n  }\n\n  if (totalBuyerFeeBasisPoints < 0 || totalSellerFeeBasisPoints < 0) {\n    throw new Error(`Invalid buyer/seller fees: must be at least 0%`);\n  }\n}\n\nfunction _getSellFeeParameters(totalBuyerFeeBasisPoints, totalSellerFeeBasisPoints, waitForHighestBid) {\n  let sellerBountyBasisPoints = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n  // just making basic check if fee is less than 100% and not negative\n  _validateFees(totalBuyerFeeBasisPoints, totalSellerFeeBasisPoints); // Use buyer as the maker when it's an English auction, so Wyvern sets prices correctly\n\n\n  const feeRecipient = waitForHighestBid ? WyvernProtocol.NULL_ADDRESS : OPENSEA_FEE_RECIPIENT; // Swap maker/taker fees when it's an English auction,\n  // since these sell orders are takers not makers\n\n  const makerRelayerFee = waitForHighestBid ? new BigNumber(totalBuyerFeeBasisPoints) : new BigNumber(totalSellerFeeBasisPoints);\n  const takerRelayerFee = waitForHighestBid ? new BigNumber(totalSellerFeeBasisPoints) : new BigNumber(totalBuyerFeeBasisPoints);\n  return {\n    makerRelayerFee,\n    takerRelayerFee,\n    makerProtocolFee: new BigNumber(0),\n    takerProtocolFee: new BigNumber(0),\n    makerReferrerFee: new BigNumber(sellerBountyBasisPoints),\n    feeRecipient,\n    feeMethod: 1 // 0 protocol fee ,1 split fee\n\n  };\n}\n\n;\n\nconst getMethod = (abi, name) => {\n  const methodAbi = abi.find(x => x.type == \"function\" && x.name == name);\n\n  if (!methodAbi) {\n    throw new Error(`ABI ${name} not found`);\n  } // Have to cast since there's a bug in  web3 types on the 'type' field\n\n\n  return methodAbi;\n};\n\nasync function _getStaticCallTargetAndExtraData(_ref5) {\n  let {\n    useTxnOriginStaticCall\n  } = _ref5;\n\n  if (!useTxnOriginStaticCall) {\n    // While testing, we will use dummy values for mainnet. We will remove this if-statement once we have pushed the PR once and tested on Rinkeby\n    return {\n      staticTarget: WyvernProtocol.NULL_ADDRESS,\n      staticExtradata: \"0x\"\n    };\n  }\n\n  ;\n\n  if (useTxnOriginStaticCall) {\n    return {\n      staticTarget: STATIC_CALL_TX_ORIGIN_ADDRESS,\n      staticExtradata: encodeCall(getMethod(StaticCheckTxOrigin, \"succeedIfTxOriginMatchesHardcodedAddress\"), [])\n    };\n  } else {\n    // Noop - no checks\n    return {\n      staticTarget: WyvernProtocol.NULL_ADDRESS,\n      staticExtradata: \"0x\"\n    };\n  }\n\n  ;\n}\n\n;\n\nconst assetContractFromJSON = assetContract => {\n  return {\n    name: assetContract.name,\n    description: assetContract.description,\n    type: assetContract.assetContract_type,\n    schemaName: assetContract.schema_name,\n    address: assetContract.address,\n    tokenSymbol: assetContract.symbol,\n    buyerFeeBasisPoints: +assetContract.buyer_fee_basis_points,\n    sellerFeeBasisPoints: +assetContract.seller_fee_basis_points,\n    openseaBuyerFeeBasisPoints: +assetContract.opensea_buyer_fee_basis_points,\n    openseaSellerFeeBasisPoints: +assetContract.opensea_seller_fee_basis_points,\n    devBuyerFeeBasisPoints: +assetContract.dev_buyer_fee_basis_points,\n    devSellerFeeBasisPoints: +assetContract.dev_seller_fee_basis_points,\n    imageUrl: assetContract.image_url,\n    externalLink: assetContract.external_link,\n    wikiLink: assetContract.wiki_link\n  };\n};\n\nexport const collectionFromJSON = collection => {\n  const createdDate = new Date(`${collection.created_date}Z`);\n  return {\n    createdDate,\n    name: collection.name,\n    description: collection.description,\n    slug: collection.slug,\n    editors: collection.editors,\n    hidden: collection.hidden,\n    featured: collection.featured,\n    featuredImageUrl: collection.featured_image_url,\n    displayData: collection.display_data,\n    paymentTokens: (collection.payment_tokens || []).map(tokenFromJSON),\n    openseaBuyerFeeBasisPoints: +collection.opensea_buyer_fee_basis_points,\n    openseaSellerFeeBasisPoints: +collection.opensea_seller_fee_basis_points,\n    devBuyerFeeBasisPoints: +collection.dev_buyer_fee_basis_points,\n    devSellerFeeBasisPoints: +collection.dev_seller_fee_basis_points,\n    payoutAddress: collection.payout_address,\n    imageUrl: collection.image_url,\n    largeImageUrl: collection.large_image_url,\n    stats: collection.stats,\n    traitStats: collection.traits,\n    externalLink: collection.external_url,\n    wikiLink: collection.wiki_url\n  };\n};\n\nconst userFromJSON = user => {\n  return {\n    username: user.username\n  };\n};\n\nconst accountFromJSON = account => {\n  return {\n    address: account.address,\n    config: account.config,\n    profileImgUrl: account.profile_img_url,\n    user: account.user ? userFromJSON(account.user) : null\n  };\n};\n\nconst transactionFromJSON = transaction => {\n  return {\n    fromAccount: accountFromJSON(transaction.from_account),\n    toAccount: accountFromJSON(transaction.to_account),\n    createdDate: new Date(`${transaction.created_date}Z`),\n    modifiedDate: new Date(`${transaction.modified_date}Z`),\n    transactionHash: transaction.transaction_hash,\n    transactionIndex: transaction.transaction_index,\n    blockNumber: transaction.block_number,\n    blockHash: transaction.block_hash,\n    timestamp: new Date(`${transaction.timestamp}Z`)\n  };\n};\n\nconst assetEventFromJSON = assetEvent => {\n  return {\n    eventType: assetEvent.event_type,\n    eventTimestamp: assetEvent.event_timestamp,\n    auctionType: assetEvent.auction_type,\n    totalPrice: assetEvent.total_price,\n    transaction: assetEvent.transaction ? transactionFromJSON(assetEvent.transaction) : null,\n    paymentToken: assetEvent.payment_token ? tokenFromJSON(assetEvent.payment_token) : null\n  };\n};\n\nconst assetFromJSON = asset => {\n  const isAnimated = asset.image_url && asset.image_url.endsWith(\".gif\");\n  const isSvg = asset.image_url && asset.image_url.endsWith(\".svg\");\n  const fromJSON = {\n    tokenId: asset.token_id.toString(),\n    tokenAddress: asset.asset_contract.address,\n    name: asset.name,\n    description: asset.description,\n    owner: asset.owner,\n    assetContract: assetContractFromJSON(asset.asset_contract),\n    collection: collectionFromJSON(asset.collection),\n    orders: asset.orders ? asset.orders.map(orderFromJSON) : null,\n    sellOrders: asset.sell_orders ? asset.sell_orders.map(orderFromJSON) : null,\n    buyOrders: asset.buy_orders ? asset.buy_orders.map(orderFromJSON) : null,\n    isPresale: asset.is_presale,\n    // Don't use previews if it's a special image\n    imageUrl: isAnimated || isSvg ? asset.image_url : asset.image_preview_url || asset.image_url,\n    imagePreviewUrl: asset.image_preview_url,\n    imageUrlOriginal: asset.image_original_url,\n    imageUrlThumbnail: asset.image_thumbnail_url,\n    externalLink: asset.external_link,\n    openseaLink: asset.permalink,\n    traits: asset.traits,\n    numSales: asset.num_sales,\n    lastSale: asset.last_sale ? assetEventFromJSON(asset.last_sale) : null,\n    backgroundColor: asset.background_color ? `#${asset.background_color}` : null,\n    transferFee: asset.transfer_fee ? new BigNumber(asset.transfer_fee) : null,\n    transferFeePaymentToken: asset.transfer_fee_payment_token ? tokenFromJSON(asset.transfer_fee_payment_token) : null\n  }; // If orders were included, put them in sell/buy order groups\n\n  if (fromJSON.orders && !fromJSON.sellOrders) {\n    fromJSON.sellOrders = fromJSON.orders.filter(o => o.side == 1);\n  }\n\n  if (fromJSON.orders && !fromJSON.buyOrders) {\n    fromJSON.buyOrders = fromJSON.orders.filter(o => o.side == 0);\n  }\n\n  return fromJSON;\n};\n/**\n * Fetch an asset from the API, throwing if none is found\n * @param tokenAddress Address of the asset's contract\n * @param tokenId The asset's token ID, or null if ERC-20\n * @param retries Number of times to retry if the service is unavailable for any reason\n */\n\n\nasync function getAsset(_ref6) {\n  let {\n    tokenAddress,\n    tokenId\n  } = _ref6;\n  const {\n    data\n  } = await axios(`${OPENSEA_URL}asset/${tokenAddress}/${tokenId || 0}/`);\n  return assetFromJSON(data);\n}\n\nasync function validateOrder(_ref7) {\n  let {\n    order,\n    accountAddress,\n    wyvernExchange\n  } = _ref7;\n  // Check sell parameters\n  const sellValid = await wyvernExchange.functions.validateOrder_([order.exchange, order.maker, order.taker, order.feeRecipient, order.target, order.staticTarget, order.paymentToken], [250.0.toFixed(), 0.0.toFixed(), order.makerProtocolFee, order.takerProtocolFee, 0.0.toFixed(), 0.0.toFixed(), order.listingTime, order.expirationTime, order.salt], order.feeMethod, order.side, order.saleKind, order.howToCall, order.calldata, order.replacementPattern, order.staticExtradata, order.v, order.r, order.s);\n\n  if (!sellValid) {\n    // eslint-disable-next-line no-throw-literal\n    throw {\n      message: new Error(`Failed to validate sell order parameters. It looks like this listing is invalid.`),\n      code: \"InvalidOrder\"\n    }; // TODO: call order invalidate API\n  }\n\n  return sellValid;\n} // sourced from 0x.js:\n// https://github.com/ProjectWyvern/wyvern-js/blob/39999cb93ce5d80ea90b4382182d1bd4339a9c6c/src/utils/signature_utils.ts\n\n\nasync function parseSignatureHex(signature) {\n  // HACK: There is no consensus on whether the signatureHex string should be formatted as\n  // v + r + s OR r + s + v, and different clients (even different versions of the same client)\n  // return the signature params in different orders. In order to support all client implementations,\n  // we parse the signature in both ways, and evaluate if either one is a valid signature.\n  const validVParamValues = [27, 28];\n\n  const ecSignatureRSV = _parseSignatureHexAsRSV(signature);\n\n  if (_.includes(validVParamValues, ecSignatureRSV.v)) {\n    return ecSignatureRSV;\n  }\n\n  ; // For older clients\n\n  const ecSignatureVRS = _parseSignatureHexAsVRS(signature);\n\n  if (_.includes(validVParamValues, ecSignatureVRS.v)) {\n    return ecSignatureVRS;\n  }\n\n  ;\n  throw new Error(\"Invalid signature\");\n\n  function _parseSignatureHexAsVRS(signatureHex) {\n    const signatureBuffer = ethUtil.toBuffer(signatureHex);\n    let v = signatureBuffer[0];\n\n    if (v < 27) {\n      v += 27;\n    }\n\n    const r = signatureBuffer.slice(1, 33);\n    const s = signatureBuffer.slice(33, 65);\n    const ecSignature = {\n      v,\n      r: ethUtil.bufferToHex(r),\n      s: ethUtil.bufferToHex(s)\n    };\n    return ecSignature;\n  }\n\n  ;\n\n  function _parseSignatureHexAsRSV(signatureHex) {\n    const {\n      v,\n      r,\n      s\n    } = ethUtil.fromRpcSig(signatureHex);\n    const ecSignature = {\n      v,\n      r: ethUtil.bufferToHex(r),\n      s: ethUtil.bufferToHex(s)\n    };\n    return ecSignature;\n  }\n\n  ;\n}\n\n;\n\nasync function personalSignAsync(provider, message, signerAddress) {\n  return new Promise((resolve, reject) => {\n    const callback = async (err, signature) => {\n      if (err) reject(err);\n\n      if (signature.error) {\n        reject(signature.error.message);\n      }\n\n      ;\n      resolve(parseSignatureHex(signature.result)); // // console.log(result);\n      // const d = signature.result;\n      // let v = d.slice(-2);\n      // let r = d.slice(2, -66);\n      // let s = d.slice(-66, -2);\n      // let actualsignature = v + r + s + '03';\n      // // const dhs = await this.contractInstace.methods\n      // //   .setApprovalForAll(OPERATOR_ADDRESS, true)\n      // //   .send({ from: this.metamask.metaMaskAddress });\n      // resolve(`0x${actualsignature}`);\n    }; // console.log(orderHex, metaMaskAddress);\n\n\n    provider.sendAsync({\n      method: \"personal_sign\",\n      params: [message, signerAddress],\n      from: signerAddress\n    }, callback);\n  });\n}\n\n;\nexport async function signTypedDataAsync(provider, message, signerAddress) {\n  let signature;\n  return new Promise((resolve, reject) => {\n    const callback = async (err, result) => {\n      console.log(err);\n      if (err) reject(err);\n\n      if (result.error) {\n        reject(result.error.message);\n      }\n\n      ; // eslint-disable-next-line prefer-promise-reject-errors\n\n      if (result.error) return reject(\"ERROR\", result); // console.log(result);\n      // const d = result.result;\n      // let v = d.slice(-2);\n      // let r = d.slice(2, -66);\n      // let s = d.slice(-66, -2);\n      // let actualsignature = v + r + s + '03';\n\n      resolve(parseSignatureHex(result.result));\n    };\n\n    const stringified = JSON.stringify({ ...message\n    });\n\n    try {\n      // Using sign typed data V4 works with a stringified message, used by browser providers i.e. Metamask\n      provider.sendAsync({\n        method: \"eth_signTypedData_v4\",\n        params: [signerAddress, stringified],\n        from: signerAddress,\n        id: new Date().getTime()\n      }, callback);\n    } catch (error) {\n      console.log(error); // Fallback to normal sign typed data for node providers, without using stringified message\n      // https://github.com/coinbase/coinbase-wallet-sdk/issues/60\n\n      provider.sendAsync({\n        method: \"eth_signTypedData\",\n        params: [signerAddress, message],\n        from: signerAddress,\n        id: new Date().getTime()\n      }, callback);\n    }\n\n    ;\n  });\n}\n\nasync function _authorizeOrder(_ref8) {\n  let {\n    order,\n    provider,\n    nonce\n  } = _ref8;\n  // 2.2 Sign order flow\n  const signerAddress = order.maker;\n\n  if (order.exchange === mainnetWyvernConfigByNetwork.wyvernExchangeContractAddress && order.hash) {\n    const message = order.hash; // v1\n\n    return await personalSignAsync(provider, message, signerAddress);\n  } // 2.3 Sign order flow using EIP-712\n  // We need to manually specify each field because OS orders can contain unrelated data\n\n\n  const orderForSigning = {\n    maker: order.maker,\n    exchange: order.exchange,\n    taker: order.taker,\n    makerRelayerFee: order.makerRelayerFee.toString(),\n    takerRelayerFee: order.takerRelayerFee.toString(),\n    makerProtocolFee: order.makerProtocolFee.toString(),\n    takerProtocolFee: order.takerProtocolFee.toString(),\n    feeRecipient: order.feeRecipient,\n    feeMethod: order.feeMethod,\n    side: order.side,\n    saleKind: order.saleKind,\n    target: order.target,\n    howToCall: order.howToCall,\n    calldata: order.calldata,\n    replacementPattern: order.replacementPattern,\n    staticTarget: order.staticTarget,\n    staticExtradata: order.staticExtradata,\n    paymentToken: order.paymentToken,\n    basePrice: order.basePrice.toString(),\n    extra: order.extra.toString(),\n    listingTime: order.listingTime.toString(),\n    expirationTime: order.expirationTime.toString(),\n    salt: order.salt.toString()\n  }; // We don't JSON.stringify as certain wallet providers sanitize this data\n  // https://github.com/coinbase/coinbase-wallet-sdk/issues/60\n\n  const message = {\n    types: OrderTypesEIP712,\n    domain: {\n      name: WyvernDomainNameEIP712,\n      version: WyvernDomainVersionEIP712,\n      chainId: 1,\n      verifyingContract: order.exchange\n    },\n    primaryType: \"Order\",\n    message: { ...orderForSigning,\n      nonce\n    }\n  };\n  const ecSignature = await signTypedDataAsync(provider, message, signerAddress);\n  return { ...ecSignature,\n    nonce\n  };\n}\n\n;\n/**\n * Convert an order to JSON, hashing it as well if necessary\n * @param order order (hashed or unhashed)\n */\n\nconst orderToJSON = order => {\n  const asJSON = {\n    exchange: order.exchange.toLowerCase(),\n    maker: order.maker.toLowerCase(),\n    taker: order.taker.toLowerCase(),\n    makerRelayerFee: order.makerRelayerFee.toString(),\n    takerRelayerFee: order.takerRelayerFee.toString(),\n    makerProtocolFee: order.makerProtocolFee.toString(),\n    takerProtocolFee: order.takerProtocolFee.toString(),\n    makerReferrerFee: order.makerReferrerFee.toString(),\n    feeMethod: order.feeMethod,\n    feeRecipient: order.feeRecipient.toLowerCase(),\n    side: order.side,\n    saleKind: order.saleKind,\n    target: order.target.toLowerCase(),\n    howToCall: order.howToCall,\n    calldata: order.calldata,\n    replacementPattern: order.replacementPattern,\n    staticTarget: order.staticTarget.toLowerCase(),\n    staticExtradata: order.staticExtradata,\n    paymentToken: order.paymentToken.toLowerCase(),\n    quantity: order.quantity.toString(),\n    basePrice: order.basePrice.toString(),\n    englishAuctionReservePrice: order.englishAuctionReservePrice ? order.englishAuctionReservePrice.toString() : undefined,\n    extra: order.extra.toString(),\n    createdTime: order.createdTime ? order.createdTime.toString() : undefined,\n    listingTime: order.listingTime.toString(),\n    expirationTime: order.expirationTime.toString(),\n    salt: order.salt.toString(),\n    metadata: order.metadata,\n    v: order.v,\n    r: order.r,\n    s: order.s,\n    nonce: order.nonce\n  };\n  return asJSON;\n};\n\nasync function postOrder(order) {\n  let retries = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n\n  try {\n    const {\n      data\n    } = await axios.post(`https://api.opensea.io/wyvern/v1/orders/post/`, order, {\n      headers: {\n        \"x-api-key\": X_API_KEY\n      }\n    });\n    return data;\n  } catch (error) {\n    throw new Error(error);\n  }\n\n  ;\n}\n\n;\n/**\n * Convert an order to JSON for golom, hashing it as well if necessary\n * @param order order (hashed or unhashed)\n */\n\nconst orderToGolomJSON = order => {\n  const asJSON = {\n    exchange: order.exchange.toLowerCase(),\n    maker: {\n      address: order.maker.toLowerCase()\n    },\n    taker: {\n      address: order.taker.toLowerCase()\n    },\n    maker_relayer_fee: order.makerRelayerFee.toString(),\n    taker_relayer_fee: order.takerRelayerFee.toString(),\n    maker_protocol_fee: order.makerProtocolFee.toString(),\n    taker_protocol_fee: order.takerProtocolFee.toString(),\n    makerReferrerFee: order.makerReferrerFee.toString(),\n    fee_method: order.feeMethod,\n    fee_recipient: {\n      address: order.feeRecipient.toLowerCase()\n    },\n    side: order.side,\n    sale_kind: order.saleKind,\n    target: order.target.toLowerCase(),\n    how_to_call: order.howToCall,\n    calldata: order.calldata,\n    replacement_pattern: order.replacementPattern,\n    static_target: order.staticTarget.toLowerCase(),\n    static_extradata: order.staticExtradata,\n    payment_token: order.paymentToken.toLowerCase(),\n    quantity: order.quantity.toString(),\n    base_price: order.basePrice.toString(),\n    englishAuctionReservePrice: order.englishAuctionReservePrice ? order.englishAuctionReservePrice.toString() : undefined,\n    extra: order.extra.toString(),\n    createdTime: order.createdTime ? order.createdTime.toString() : undefined,\n    listing_time: order.listingTime.toString(),\n    expiration_time: order.expirationTime.toString(),\n    salt: order.salt.toString(),\n    metadata: order.metadata,\n    v: order.v,\n    r: order.r,\n    s: order.s,\n    prefixed_hash: order.hash\n  };\n  return asJSON;\n};\n/**\n * Validate and post an order to the OpenSea orderbook.\n * @param order The order to post. Can either be signed by the maker or pre-approved on the Wyvern contract using approveOrder. See https://github.com/ProjectWyvern/wyvern-ethereum/blob/master/contracts/exchange/Exchange.sol#L178\n * @returns The order as stored by the orderbook\n */\n\n\nasync function validateAndPostOrder(_ref9) {\n  let {\n    order\n  } = _ref9;\n  // Validation is called server-side\n  return orderToJSON(order);\n}\n\nfunction cancelOSOrder(_ref10) {\n  let {\n    provider,\n    order\n  } = _ref10;\n  const wyvernExchange = WyvernContract(provider); // const cancelHash = wyvernExchange.methods\n  //   .hashToSign_(\n  //     [\n  //       order.exchange,\n  //       order.maker,\n  //       order.taker,\n  //       order.feeRecipient,\n  //       order.target,\n  //       order.staticTarget,\n  //       order.paymentToken\n  //     ],\n  //     [\n  //       order.makerRelayerFee,\n  //       order.takerRelayerFee,\n  //       order.makerProtocolFee,\n  //       order.takerProtocolFee,\n  //       order.basePrice,\n  //       order.extra,\n  //       order.listingTime,\n  //       order.expirationTime,\n  //       order.salt\n  //     ],\n  //     order.feeMethod,\n  //     order.side,\n  //     order.saleKind,\n  //     order.howToCall,\n  //     order.calldata,\n  //     order.replacementPattern,\n  //     order.staticExtradata\n  //   )\n  //   .call();\n  // console.log(cancelHash);\n\n  return wyvernExchange.methods.cancelOrder_([order.exchange, order.maker, order.taker, order.feeRecipient, order.target, order.staticTarget, order.paymentToken], [order.makerRelayerFee, order.takerRelayerFee, order.makerProtocolFee, order.takerProtocolFee, order.basePrice, order.extra, order.listingTime, order.expirationTime, order.salt], order.feeMethod, order.side, order.saleKind, order.howToCall, order.calldata, order.replacementPattern, order.staticExtradata, order.v || 0, order.r || NULL_BLOCK_HASH, order.s || NULL_BLOCK_HASH);\n}\n\nexport { fulfillOrder, cancelOSOrder }; // maker:\n// 0xafac92864611c564e7fa1a6c6d07b45807536943\n// exchange:\n// 0x7f268357a8c2552623316e2562d90e642bb538e5\n// taker:\n// 0x0000000000000000000000000000000000000000\n// makerRelayerFee:\n// 500\n// takerRelayerFee:\n// 0\n// makerProtocolFee:\n// 0\n// takerProtocolFee:\n// 0\n// feeRecipient:\n// 0x5b3256965e7c3cf26e11fcaf296dfc8807c01073\n// feeMethod:\n// 1\n// side:\n// 1\n// saleKind:\n// 0\n// target:\n// 0xbaf2127b49fc93cbca6269fade0f7f31df4c88a7\n// howToCall:\n// 1\n// calldata:\n// 0xfb16a595000000000000000000000000afac92864611c564e7fa1a6c6d07b45807536943000000000000000000000000000000000000000000000000000000000000000000000000000000000000000079fcdef22feed20eddacbb2587640e45491b757f0000000000000000000000000000000000000000000000000000000000000eb5000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000000\n// replacementPattern:\n// 0x000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n// staticTarget:\n// 0x0000000000000000000000000000000000000000\n// staticExtradata:\n// 0x\n// paymentToken:\n// 0x0000000000000000000000000000000000000000\n// basePrice:\n// 6000000000000000000\n// extra:\n// 0\n// listingTime:\n// 1645298828\n// expirationTime:\n// 1645903716\n// salt:\n// 87906966303110818969546189067137492865825614986988195802067881988151729727179\n// nonce:\n// 0\n// basePrice: \"6000000000000000000\"\n// calldata: \"0xfb16a595000000000000000000000000afac92864611c564e7fa1a6c6d07b45807536943000000000000000000000000000000000000000000000000000000000000000000000000000000000000000079fcdef22feed20eddacbb2587640e45491b757f0000000000000000000000000000000000000000000000000000000000000eb5000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000000\"\n// exchange: \"0x7f268357a8c2552623316e2562d90e642bb538e5\"\n// expirationTime: \"1645903716\"\n// extra: \"0\"\n// feeMethod: 1\n// feeRecipient: \"0x5b3256965e7c3cf26e11fcaf296dfc8807c01073\"\n// howToCall: 1\n// listingTime: \"1645298816\"\n// maker: \"0xafac92864611c564e7fa1a6c6d07b45807536943\"\n// makerProtocolFee: \"0\"\n// makerReferrerFee: \"0\"\n// makerRelayerFee: \"500\"\n// metadata: {asset: {id: \"3765\", address: \"0x79fcdef22feed20eddacbb2587640e45491b757f\"}, schema: \"ERC721\"}\n// nonce: 0\n// paymentToken: \"0x0000000000000000000000000000000000000000\"\n// quantity: \"1\"\n// r: \"0x0c70bd3052b0da178141b84e7bdbe511acc5f7f601281850cd5f93f145c9bbb5\"\n// replacementPattern: \"0x000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n// s: \"0x7a2bf43b7b616073bf2486d2890b674f9587f68f59a84e4d7fff55842bbe9b60\"\n// saleKind: 0\n// salt: \"87577974536160270209585191401103724053896633202437364720132507693990122512257\"\n// side: 1\n// staticExtradata: \"0x\"\n// staticTarget: \"0x0000000000000000000000000000000000000000\"\n// taker: \"0x0000000000000000000000000000000000000000\"\n// takerProtocolFee: \"0\"\n// takerRelayerFee: \"0\"\n// target: \"0xbaf2127b49fc93cbca6269fade0f7f31df4c88a7\"\n// v: 28","map":{"version":3,"names":["WyvernProtocol","HowToCall","Network","ERC721Schema","ethABI","ethUtil","isValidAddress","parseEther","BigNumber","axios","_","OPENSEA_URL","X_API_KEY","ACTIVITY_POLLING_INTERVAL","LISTING_POLLING_INTERVAL","OFFERS_POLLING_INTERVAL","MIN_EXPIRATION_SECONDS","ORDER_MATCHING_LATENCY_SECONDS","OPENSEA_FEE_RECIPIENT","NULL_BLOCK_HASH","INVERSE_BASIS_POINT","DEFAULT_BUYER_FEE_BASIS_POINTS","DEFAULT_SELLER_FEE_BASIS_POINTS","OPENSEA_SELLER_BOUNTY_BASIS_POINTS","DEFAULT_MAX_BOUNTY","STATIC_CALL_TX_ORIGIN_ADDRESS","MERKLE_VALIDATOR_MAINNET","mainnetWyvernConfigByNetwork","OrderTypesEIP712","WyvernDomainNameEIP712","WyvernDomainVersionEIP712","StaticCheckTxOrigin","WyvernContract","WYVERN_CONTRACT","createOrder","tokenFromJSON","token","fromJSON","name","symbol","decimals","address","imageUrl","image_url","ethPrice","eth_price","usdPrice","usd_price","merkleValidatorByNetwork","main","orderFromJSON","order","createdDate","Date","created_date","hash","order_hash","cancelledOrFinalized","cancelled","finalized","markedInvalid","marked_invalid","metadata","quantity","exchange","makerAccount","maker","takerAccount","taker","makerRelayerFee","maker_relayer_fee","takerRelayerFee","taker_relayer_fee","makerProtocolFee","maker_protocol_fee","takerProtocolFee","taker_protocol_fee","makerReferrerFee","maker_referrer_fee","waitingForBestCounterOrder","fee_recipient","NULL_ADDRESS","feeMethod","fee_method","feeRecipientAccount","feeRecipient","side","saleKind","sale_kind","target","howToCall","how_to_call","calldata","replacementPattern","replacement_pattern","staticTarget","static_target","staticExtradata","static_extradata","paymentToken","payment_token","basePrice","base_price","extra","currentBounty","current_bounty","currentPrice","current_price","createdTime","Math","round","getTime","listingTime","listing_time","expirationTime","expiration_time","salt","v","parseInt","r","s","paymentTokenContract","payment_token_contract","undefined","asset","assetBundle","asset_bundle","estimateCurrentPrice","_getTimeParameters","expirationTimestamp","listingTimestamp","minListingTimestamp","now","minExpirationTimestamp","Error","toString","encodeCall","abi","parameters","inputTypes","inputs","map","i","type","id","methodID","encode","rawEncode","slice","Buffer","concat","encodeDefaultCall","input","kind","generateDefaultValue","value","encodeSell","schema","validatorAddress","transfer","functions","checkAndTransfer","defaultCall","pattern","encodeReplacementPattern","encodeBuy","replaceables","filter","ownerInputs","length","e","console","error","getOrderHash","orderWithStringTypes","toLowerCase","toFixed","getOrderHashHex","makeMatchingOrder","accountAddress","recipientAddress","computeOrderParams","shouldValidate","times","matchingOrder","generatePseudoRandomSalt","assignOrdersToSides","isSellOrder","buy","sell","_getMetadata","referrerAddress","referrer","substr","_correctGasAmount","estimation","ceil","getCurrentPrice","wyvernExchange","methods","calculateCurrentPrice_","secondsToBacktrack","shouldRoundUp","minus","exactPrice","diff","dividedBy","plus","_getRequiredAmountForTakingSellOrder","estimatedPrice","maxPrice","max","feePercentage","div","fee","_atomicMatch","txnData","from","args","atomicMatchMethod","atomicMatch_","then","res","log","fulfillOrder","provider","info","isValid","validateOrder","getWyvernAsset","tokenId","assetFromFields","ID","Quantity","Address","tokenAddress","Name","computeFees","extraBountyBasisPoints","openseaBuyerFeeBasisPoints","openseaSellerFeeBasisPoints","devBuyerFeeBasisPoints","devSellerFeeBasisPoints","transferFee","transferFeeTokenAddress","maxTotalBountyBPS","sellerBountyBasisPoints","bountyTooLarge","errorMessage","totalBuyerFeeBasisPoints","totalSellerFeeBasisPoints","_getPriceParameters","orderSide","startAmount","endAmount","englishAuctionReservePrice","priceDiff","String","reservePrice","_validateFees","maxFeePercent","_getSellFeeParameters","waitForHighestBid","getMethod","methodAbi","find","x","_getStaticCallTargetAndExtraData","useTxnOriginStaticCall","assetContractFromJSON","assetContract","description","assetContract_type","schemaName","schema_name","tokenSymbol","buyerFeeBasisPoints","buyer_fee_basis_points","sellerFeeBasisPoints","seller_fee_basis_points","opensea_buyer_fee_basis_points","opensea_seller_fee_basis_points","dev_buyer_fee_basis_points","dev_seller_fee_basis_points","externalLink","external_link","wikiLink","wiki_link","collectionFromJSON","collection","slug","editors","hidden","featured","featuredImageUrl","featured_image_url","displayData","display_data","paymentTokens","payment_tokens","payoutAddress","payout_address","largeImageUrl","large_image_url","stats","traitStats","traits","external_url","wiki_url","userFromJSON","user","username","accountFromJSON","account","config","profileImgUrl","profile_img_url","transactionFromJSON","transaction","fromAccount","from_account","toAccount","to_account","modifiedDate","modified_date","transactionHash","transaction_hash","transactionIndex","transaction_index","blockNumber","block_number","blockHash","block_hash","timestamp","assetEventFromJSON","assetEvent","eventType","event_type","eventTimestamp","event_timestamp","auctionType","auction_type","totalPrice","total_price","assetFromJSON","isAnimated","endsWith","isSvg","token_id","asset_contract","owner","orders","sellOrders","sell_orders","buyOrders","buy_orders","isPresale","is_presale","image_preview_url","imagePreviewUrl","imageUrlOriginal","image_original_url","imageUrlThumbnail","image_thumbnail_url","openseaLink","permalink","numSales","num_sales","lastSale","last_sale","backgroundColor","background_color","transfer_fee","transferFeePaymentToken","transfer_fee_payment_token","o","getAsset","data","sellValid","validateOrder_","message","code","parseSignatureHex","signature","validVParamValues","ecSignatureRSV","_parseSignatureHexAsRSV","includes","ecSignatureVRS","_parseSignatureHexAsVRS","signatureHex","signatureBuffer","toBuffer","ecSignature","bufferToHex","fromRpcSig","personalSignAsync","signerAddress","Promise","resolve","reject","callback","err","result","sendAsync","method","params","signTypedDataAsync","stringified","JSON","stringify","_authorizeOrder","nonce","wyvernExchangeContractAddress","orderForSigning","types","domain","version","chainId","verifyingContract","primaryType","orderToJSON","asJSON","postOrder","retries","post","headers","orderToGolomJSON","prefixed_hash","validateAndPostOrder","cancelOSOrder","cancelOrder_"],"sources":["/Users/romanrakhlin/Dropbox/Mac/Desktop/opensea-exploit/src/opensea-sdk/opensea.js"],"sourcesContent":["// Wyvern\nimport { WyvernProtocol } from \"wyvern-js\";\nimport { HowToCall, Network } from \"wyvern-js/lib/types\";\nimport { ERC721Schema } from \"./WyvernSchema\";\n\n// Ethereum\nimport * as ethABI from \"ethereumjs-abi\";\nimport * as ethUtil from \"ethereumjs-util\";\nimport isValidAddress from \"ethereumjs-util\";\nimport { parseEther } from \"@ethersproject/units\";\nimport BigNumber from \"bignumber.js\";\n\n// Other\nimport axios from \"axios\";\nimport * as _ from \"lodash\";\n\n// Constants\nimport { OPENSEA_URL, X_API_KEY } from \"./Constants\";\nimport { ACTIVITY_POLLING_INTERVAL, LISTING_POLLING_INTERVAL, OFFERS_POLLING_INTERVAL } from \"./Constants\";\nimport { MIN_EXPIRATION_SECONDS, ORDER_MATCHING_LATENCY_SECONDS, OPENSEA_FEE_RECIPIENT, NULL_BLOCK_HASH, INVERSE_BASIS_POINT, DEFAULT_BUYER_FEE_BASIS_POINTS, DEFAULT_SELLER_FEE_BASIS_POINTS, OPENSEA_SELLER_BOUNTY_BASIS_POINTS, DEFAULT_MAX_BOUNTY, STATIC_CALL_TX_ORIGIN_ADDRESS, MERKLE_VALIDATOR_MAINNET } from \"./Constants\";\nimport { mainnetWyvernConfigByNetwork } from \"./Constants\";\nimport { OrderTypesEIP712, WyvernDomainNameEIP712, WyvernDomainVersionEIP712 } from \"./Constants\";\nimport { StaticCheckTxOrigin } from \"./Constants\";\n\n// Contracts\nimport { WyvernContract, WYVERN_CONTRACT } from \"./contracts\";\n\n// Methods\nimport createOrder from \"./methods/CreateOrder\";\n\n// FUNCTIONS\nconst tokenFromJSON = (token) => {\n    const fromJSON = {\n        name: token.name,\n        symbol: token.symbol,\n        decimals: token.decimals,\n        address: token.address,\n        imageUrl: token.image_url,\n        ethPrice: token.eth_price,\n        usdPrice: token.usd_price,\n    };\n\n    return fromJSON;\n};\n\nconst merkleValidatorByNetwork = {\n  main: MERKLE_VALIDATOR_MAINNET\n};\n\nconst orderFromJSON = (order) => {\n    const createdDate = new Date(`${order.created_date}Z`);\n    const fromJSON = {\n        hash: order.order_hash || order.hash,\n        cancelledOrFinalized: order.cancelled || order.finalized,\n        markedInvalid: order.marked_invalid,\n        metadata: order.metadata,\n        quantity: new BigNumber(order.quantity || 1),\n        exchange: order.exchange,\n        makerAccount: order.maker,\n        takerAccount: order.taker,\n\n        // Use string address to conform to Wyvern Order schema\n        maker: order.maker.address,\n        taker: order.taker.address,\n        makerRelayerFee: new BigNumber(order.maker_relayer_fee),\n        takerRelayerFee: new BigNumber(order.taker_relayer_fee),\n        makerProtocolFee: new BigNumber(order.maker_protocol_fee),\n        takerProtocolFee: new BigNumber(order.taker_protocol_fee),\n        makerReferrerFee: new BigNumber(order.maker_referrer_fee || 0),\n        waitingForBestCounterOrder: order.fee_recipient.address == WyvernProtocol.NULL_ADDRESS,\n        feeMethod: order.fee_method,\n        feeRecipientAccount: order.fee_recipient,\n        feeRecipient: order.fee_recipient.address,\n        side: order.side,\n        saleKind: order.sale_kind,\n        target: order.target,\n        howToCall: order.how_to_call,\n        calldata: order.calldata,\n        replacementPattern: order.replacement_pattern,\n        staticTarget: order.static_target,\n        staticExtradata: order.static_extradata,\n        paymentToken: order.payment_token,\n        basePrice: new BigNumber(order.base_price),\n        extra: new BigNumber(order.extra),\n        currentBounty: new BigNumber(order.current_bounty || 0),\n        currentPrice: new BigNumber(order.current_price || 0),\n\n        createdTime: new BigNumber(Math.round(createdDate.getTime() / 1000)),\n        listingTime: new BigNumber(order.listing_time),\n        expirationTime: new BigNumber(order.expiration_time),\n\n        salt: new BigNumber(order.salt),\n        v: parseInt(order.v),\n        r: order.r,\n        s: order.s,\n\n        paymentTokenContract: order.payment_token_contract\n          ? tokenFromJSON(order.payment_token_contract)\n          : undefined,\n        asset: order.asset,\n        assetBundle: order.asset_bundle,\n    };\n\n    // Use client-side price calc, to account for buyer fee (not added by server) and latency\n    fromJSON.currentPrice = estimateCurrentPrice(fromJSON);\n    return fromJSON;\n};\n\nconst _getTimeParameters = (expirationTimestamp, listingTimestamp, waitingForBestCounterOrder = false) => {\n    // Validation\n    const minListingTimestamp = Math.round(Date.now() / 1000);\n    const minExpirationTimestamp = Math.round(Date.now() / 1000 + MIN_EXPIRATION_SECONDS);\n\n    if (expirationTimestamp != 0 && expirationTimestamp < minExpirationTimestamp) {\n        throw new Error(`Expiration time must be at least ${MIN_EXPIRATION_SECONDS} seconds from now, or zero (non-expiring).`);\n    }\n\n    if (listingTimestamp && listingTimestamp < minListingTimestamp) {\n        throw new Error(\"Listing time cannot be in the past.\");\n    }\n\n    if (listingTimestamp && expirationTimestamp != 0 && listingTimestamp >= expirationTimestamp) {\n        throw new Error(\"Listing time must be before the expiration time.\");\n    }\n\n    if (waitingForBestCounterOrder && expirationTimestamp == 0) {\n        throw new Error(\"English auctions must have an expiration time.\");\n    }\n\n    if (waitingForBestCounterOrder && listingTimestamp) {\n        throw new Error(`Cannot schedule an English auction for the future.`);\n    }\n\n    if (parseInt(expirationTimestamp.toString()) != expirationTimestamp) {\n        throw new Error(`Expiration timestamp must be a whole number of seconds`);\n    }\n\n    if (waitingForBestCounterOrder) {\n        listingTimestamp = expirationTimestamp;\n        \n        // Expire one week from now, to ensure server can match it\n        // Later, this will expire closer to the listingTime\n        expirationTimestamp = expirationTimestamp + ORDER_MATCHING_LATENCY_SECONDS;\n    } else {\n        // Small offset to account for latency\n        listingTimestamp = listingTimestamp || Math.round(Date.now() / 1000 - 100);\n    }\n\n    return {\n        listingTime: BigNumber(listingTimestamp),\n        expirationTime: BigNumber(expirationTimestamp),\n    };\n};\n\nconst encodeCall = (abi, parameters) => {\n    const inputTypes = abi.inputs.map((i) => i.type);\n    const id = ethABI.methodID(abi.name, inputTypes);\n    const encode = ethABI.rawEncode(inputTypes.slice(0, 3), parameters.slice(0, 3));\n    return (\"0x\" + Buffer.concat([id, encode]).toString(\"hex\"));\n};\n\nconst encodeDefaultCall = (abi, address) => {\n    const parameters = abi.inputs.map((input) => {\n        switch (input.kind) {\n            case \"replaceable\":\n                return WyvernProtocol.generateDefaultValue(input.type);\n            case \"owner\":\n                return address;\n            case \"asset\":\n            default:\n                return input.value;\n        }\n    });\n\n    return encodeCall(abi, parameters);\n};\n\nconst encodeSell = (schema, asset, address, validatorAddress) => {\n    const transfer = validatorAddress && schema.functions.checkAndTransfer\n        ? schema.functions.checkAndTransfer(asset, validatorAddress)\n        : schema.functions.transfer(asset);\n    \n    // const transfer = schema.functions.transfer(asset);\n    let defaultCall = encodeDefaultCall(transfer, address)\n    let pattern = WyvernProtocol.encodeReplacementPattern(transfer)\n\n    return {\n        target: transfer.target,\n        calldata: defaultCall,\n        replacementPattern: pattern\n    };\n};\n\nconst encodeBuy = (schema, asset, address, validatorAddress) => {\n    // const transfer = schema.functions.transfer(asset);\n    const transfer = validatorAddress && schema.functions.checkAndTransfer\n        ? schema.functions.checkAndTransfer(asset, validatorAddress)\n        : schema.functions.transfer(asset);\n    const replaceables = transfer.inputs.filter((i) => i.kind === \"replaceable\");\n    const ownerInputs = transfer.inputs.filter((i) => i.kind === \"owner\");\n\n    // Validate\n    if (replaceables.length !== 1) {\n        throw new Error(\"Only 1 input can match transfer destination, but instead \" + replaceables.length + \" did\");\n    }\n\n    // Compute calldata\n    const parameters = transfer.inputs.map((input) => {\n        switch (input.kind) {\n            case \"replaceable\":\n                return address;\n            case \"owner\":\n                return WyvernProtocol.generateDefaultValue(input.type);\n            default:\n                try {\n                  return input.value.toString();\n                } catch (e) {\n                  console.error(schema);\n                  console.error(asset);\n                  throw e;\n                }\n        }\n    });\n\n    const calldata = encodeCall(transfer, parameters);\n\n    // Compute replacement pattern\n    let replacementPattern = \"0x\";\n    if (ownerInputs.length > 0) {\n        replacementPattern = WyvernProtocol.encodeReplacementPattern(transfer, \"owner\");\n    }\n\n    return {\n        target: transfer.target,\n        calldata,\n        replacementPattern,\n    };\n};\n\nfunction getOrderHash(order) {\n    const orderWithStringTypes = {\n        ...order,\n        maker: order.maker.toLowerCase(),\n        taker: order.taker.toLowerCase(),\n        feeRecipient: order.feeRecipient.toLowerCase(),\n        side: order.side.toString(),\n        saleKind: order.saleKind.toString(),\n        howToCall: order.howToCall.toString(),\n        feeMethod: order.feeMethod.toString(),\n        makerRelayerFee: 250.0.toFixed(),\n        takerRelayerFee: 0.0.toFixed(),\n        basePrice: 0.0.toFixed(),\n        extra: 0.0.toFixed()\n    };\n\n    return WyvernProtocol.getOrderHashHex(orderWithStringTypes);\n}\n\nfunction makeMatchingOrder({\n    order,\n    accountAddress,\n    recipientAddress\n}) {\n    accountAddress = accountAddress.toLowerCase();\n    recipientAddress = recipientAddress.toLowerCase();\n\n    const computeOrderParams = () => {\n        const shouldValidate = order.target === merkleValidatorByNetwork.main;\n\n        if (\"asset\" in order.metadata) {\n            const schema = ERC721Schema; // currently supporting ERC721 only\n            return order.side == 0 ? encodeSell(\n                schema,\n                order.metadata.asset,\n                recipientAddress,\n                shouldValidate ? order.target : undefined\n            ) : encodeBuy(\n                schema,\n                order.metadata.asset,\n                recipientAddress,\n                shouldValidate ? order.target : undefined\n            );\n        } else {\n            throw new Error(\"Invalid order metadata\");\n        }\n    };\n\n    const { target, calldata, replacementPattern } = computeOrderParams();\n    const times = _getTimeParameters(0);\n    \n    // Compat for matching buy orders that have fee recipient still on them\n    const feeRecipient = OPENSEA_FEE_RECIPIENT; // Maybe NULLADDRESS\n    const matchingOrder = {\n        exchange: order.exchange,\n        maker: accountAddress,\n        taker: order.maker,\n        quantity: order.quantity,\n        makerRelayerFee: order.makerRelayerFee,\n        takerRelayerFee: order.takerRelayerFee,\n        makerProtocolFee: order.makerProtocolFee,\n        takerProtocolFee: order.takerProtocolFee,\n        makerReferrerFee: order.makerReferrerFee,\n        waitingForBestCounterOrder: false,\n        feeMethod: order.feeMethod,\n        feeRecipient,\n        side: (order.side + 1) % 2,\n        saleKind: 0, // 0 fixed price 1 ducch aucion\n        target,\n        howToCall: order.howToCall,\n        calldata,\n        replacementPattern,\n        staticTarget: WyvernProtocol.NULL_ADDRESS,\n        staticExtradata: \"0x\",\n        paymentToken: order.paymentToken,\n        basePrice: order.basePrice,\n        extra: BigNumber(0),\n        listingTime: times.listingTime,\n        expirationTime: times.expirationTime,\n        salt: WyvernProtocol.generatePseudoRandomSalt(),\n        metadata: order.metadata,\n    };\n\n    return matchingOrder;\n}\n\nfunction assignOrdersToSides(order, matchingOrder) {\n    const isSellOrder = order.side == 1;\n\n    let buy;\n    let sell;\n\n    if (!isSellOrder) {\n        buy = order;\n        sell = {\n            ...matchingOrder,\n            v: buy.v,\n            r: buy.r,\n            s: buy.s,\n        };\n    } else {\n        sell = order;\n        buy = {\n            ...matchingOrder,\n            v: sell.v,\n            r: sell.r,\n            s: sell.s,\n        };\n    }\n\n    return { buy, sell };\n}\n\nconst _getMetadata = (order, referrerAddress) => {\n    const referrer = referrerAddress || order.metadata.referrerAddress;\n    if (referrer && isValidAddress(referrer)) {\n        return `0x000000000000000000000000${referrer.substr(2)}`;\n    }\n    return undefined;\n};\n\nconst _correctGasAmount = (estimation) => {\n    return Math.ceil(estimation * 1.01);\n};\n\n/**\n * Gets the price for the order using the contract\n * @param order The order to calculate the price for\n */\nasync function getCurrentPrice(order, wyvernExchange) {\n    const currentPrice = await wyvernExchange.methods.calculateCurrentPrice_(\n        [\n            order.exchange,\n            order.maker,\n            order.taker,\n            order.feeRecipient,\n            order.target,\n            order.staticTarget,\n            order.paymentToken,\n        ],\n        [\n            order.makerRelayerFee.toFixed(),\n            order.takerRelayerFee.toFixed(),\n            order.makerProtocolFee.toFixed(),\n            order.takerProtocolFee.toFixed(),\n            order.basePrice.toFixed(),\n            order.extra.toFixed(),\n            order.listingTime.toFixed(),\n            order.expirationTime.toFixed(),\n            order.salt.toFixed(),\n        ],\n        order.feeMethod,\n        order.side,\n        order.saleKind,\n        order.howToCall,\n        order.calldata,\n        order.replacementPattern,\n        order.staticExtradata\n    );\n\n    return currentPrice;\n}\n\n/**\n * Estimates the price of an order\n * @param order The order to estimate price on\n * @param secondsToBacktrack The number of seconds to subtract on current time,\n *  to fix race conditions\n * @param shouldRoundUp Whether to round up fractional wei\n */\nexport function estimateCurrentPrice(order, secondsToBacktrack = 30, shouldRoundUp = false) {\n    // round up should be enabled\n    let { basePrice, listingTime, expirationTime, extra } = order;\n    const { side, takerRelayerFee, saleKind } = order;\n\n    const now = new BigNumber(Math.round(Date.now() / 1000)).minus(secondsToBacktrack);\n    basePrice = new BigNumber(basePrice);\n    listingTime = new BigNumber(listingTime);\n    expirationTime = new BigNumber(expirationTime);\n    extra = new BigNumber(extra);\n\n    let exactPrice = basePrice;\n    \n    // saleKind 0 : Fixed price 1: Duction acution\n    if (saleKind === 0) {\n        // Do nothing, price is correct\n    } else if (saleKind === 1) {\n        const diff = extra\n            .times(now.minus(listingTime))\n            .dividedBy(expirationTime.minus(listingTime));\n\n        // side 0 : buy 1: sell\n        exactPrice =\n\n        side == 1\n            ? /* Sell-side - start price: basePrice. End price: basePrice - extra. */\n                basePrice.minus(diff)\n            : /* Buy-side - start price: basePrice. End price: basePrice + extra. */\n            basePrice.plus(diff);\n    }\n\n    // Add taker fee only for buyers\n    if (side === 1 && !order.waitingForBestCounterOrder) {\n        // Buyer fee increases sale price\n        exactPrice = exactPrice.times(+takerRelayerFee / INVERSE_BASIS_POINT + 1);\n    }\n\n    return shouldRoundUp ? exactPrice.ceil() : exactPrice;\n}\n\nasync function _getRequiredAmountForTakingSellOrder(sell, wyvernExchange) {\n    const currentPrice = await getCurrentPrice(sell, wyvernExchange);\n    const estimatedPrice = estimateCurrentPrice(sell);\n\n    const maxPrice = BigNumber.max(currentPrice, estimatedPrice);\n\n    // TODO Why is this not always a big number?\n    sell.takerRelayerFee = BigNumber(sell.takerRelayerFee);\n    const feePercentage = sell.takerRelayerFee.div(INVERSE_BASIS_POINT);\n    const fee = feePercentage.times(maxPrice);\n\n    return fee.plus(maxPrice); // use .ceil()\n}\n\nasync function _atomicMatch({\n    buy,\n    sell,\n    accountAddress,\n    wyvernExchange,\n    metadata = NULL_BLOCK_HASH,\n}) {\n    let value;\n\n    if (buy.paymentToken == WyvernProtocol.NULL_ADDRESS) {\n        value = await _getRequiredAmountForTakingSellOrder(sell, wyvernExchange);\n    }\n\n    const txnData = { from: accountAddress, value };\n\n    const args = [\n        [\n            buy.exchange,\n            buy.maker,\n            buy.taker,\n            buy.feeRecipient,\n            buy.target,\n            buy.staticTarget,\n            buy.paymentToken,\n            sell.exchange,\n            sell.maker,\n            sell.taker,\n            sell.feeRecipient,\n            sell.target,\n            sell.staticTarget,\n            sell.paymentToken,\n        ],\n        [\n            250.0.toString(),\n            0.0.toString(),\n            buy.makerProtocolFee.toString(),\n            buy.takerProtocolFee.toString(),\n            0.0.toString(),\n            buy.extra.toString(),\n            buy.listingTime.toString(),\n            buy.expirationTime.toString(),\n            buy.salt.toString(),\n            250.0.toString(),\n            0.0.toString(),\n            sell.makerProtocolFee.toString(),\n            sell.takerProtocolFee.toString(),\n            0.0.toString(),\n            0.0.toString(),\n            sell.listingTime.toString(),\n            sell.expirationTime.toString(),\n            sell.salt.toString(),\n        ],\n        [\n            buy.feeMethod,\n            buy.side,\n            buy.saleKind,\n            buy.howToCall,\n            sell.feeMethod,\n            sell.side,\n            sell.saleKind,\n            sell.howToCall,\n        ],\n        buy.calldata,\n        sell.calldata,\n        buy.replacementPattern,\n        sell.replacementPattern,\n        buy.staticExtradata,\n        sell.staticExtradata,\n        [buy.v || 0, sell.v || 0],\n        [\n            buy.r || NULL_BLOCK_HASH,\n            buy.s || NULL_BLOCK_HASH,\n            sell.r || NULL_BLOCK_HASH,\n            sell.s || NULL_BLOCK_HASH,\n            metadata,\n        ]\n    ];\n\n    // const gasEstimate = await wyvernExchange.functions.estimateGasAsync(txnData);\n    // txnData.gas = _correctGasAmount(gasEstimate);\n\n    const atomicMatchMethod = wyvernExchange.functions.atomicMatch_(\n        args[0],\n        args[1],\n        args[2],\n        args[3],\n        args[4],\n        args[5],\n        args[6],\n        args[7],\n        args[8],\n        args[9],\n        args[10],\n        txnData\n    ).then(res => {\n        console.log(res)\n    });\n\n    return { atomicMatchMethod, txnData };\n}\n\nasync function fulfillOrder({\n    order,\n    provider,\n    accountAddress,\n    recipientAddress,\n    referrerAddress\n}) {\n    console.info(`Account: ${accountAddress} | Recipient: ${recipientAddress} | Referrer: ${referrerAddress}`);\n\n    // check if valid order\n    const wyvernExchange = WyvernContract(provider);\n    const isValid = await validateOrder({ order, accountAddress, wyvernExchange });\n\n    const matchingOrder = makeMatchingOrder({\n        order,\n        accountAddress,\n        recipientAddress: recipientAddress\n    });\n\n    const { buy, sell } = assignOrdersToSides(order, matchingOrder);\n    const metadata = _getMetadata(order, referrerAddress);\n\n    return await _atomicMatch({\n        buy,\n        sell,\n        accountAddress,\n        wyvernExchange,\n        metadata\n    });\n}\n\nfunction getWyvernAsset(schema, asset, quantity = new BigNumber(1)) {\n    const tokenId = asset.tokenId != null ? asset.tokenId.toString() : undefined;\n    return schema.assetFromFields({\n        ID: tokenId,\n        Quantity: quantity.toString(),\n        Address: asset.tokenAddress.toLowerCase(),\n        Name: asset.name,\n    });\n}\n\nasync function computeFees({ \n    asset, \n    side,\n    accountAddress,\n    extraBountyBasisPoints = 0\n}) {\n    let openseaBuyerFeeBasisPoints = DEFAULT_BUYER_FEE_BASIS_POINTS;\n    let openseaSellerFeeBasisPoints = DEFAULT_SELLER_FEE_BASIS_POINTS;\n    let devBuyerFeeBasisPoints = 0;\n    let devSellerFeeBasisPoints = 0;\n    let transferFee = new BigNumber(0);\n    let transferFeeTokenAddress = null;\n    let maxTotalBountyBPS = DEFAULT_MAX_BOUNTY;\n\n    if (asset) {\n        openseaBuyerFeeBasisPoints = +asset.openseaBuyerFeeBasisPoints;\n        openseaSellerFeeBasisPoints = +asset.openseaSellerFeeBasisPoints;\n        devBuyerFeeBasisPoints = +asset.devBuyerFeeBasisPoints;\n        devSellerFeeBasisPoints = +asset.devSellerFeeBasisPoints;\n        maxTotalBountyBPS = openseaSellerFeeBasisPoints;\n    }\n\n    // Compute transferFrom fees\n    if (side == 1 && asset) {\n        // Server-side knowledge\n        // transferFee = asset.transferFee ? new BigNumber(asset.transferFee) : transferFee;\n        // transferFeeTokenAddress = asset.transferFeePaymentToken\n        //   ? asset.transferFeePaymentToken.address\n         //   : transferFeeTokenAddress;\n    }\n\n    // Compute bounty\n    const sellerBountyBasisPoints = side == 1 ? extraBountyBasisPoints : 0;\n\n    // Check that bounty is in range of the opensea fee\n    const bountyTooLarge = sellerBountyBasisPoints + OPENSEA_SELLER_BOUNTY_BASIS_POINTS > maxTotalBountyBPS;\n\n    if (sellerBountyBasisPoints > 0 && bountyTooLarge) {\n        let errorMessage = `Total bounty exceeds the maximum for this asset type (${\n            maxTotalBountyBPS / 100\n        }%).`;\n\n        if (maxTotalBountyBPS >= OPENSEA_SELLER_BOUNTY_BASIS_POINTS) {\n            errorMessage += ` Remember that OpenSea will add ${\n                OPENSEA_SELLER_BOUNTY_BASIS_POINTS / 100\n            }% for referrers with OpenSea accounts!`;\n        }\n\n        throw new Error(errorMessage);\n    }\n\n    return {\n        totalBuyerFeeBasisPoints: openseaBuyerFeeBasisPoints + devBuyerFeeBasisPoints,\n        totalSellerFeeBasisPoints: openseaSellerFeeBasisPoints + devSellerFeeBasisPoints,\n        openseaBuyerFeeBasisPoints,\n        openseaSellerFeeBasisPoints,\n        devBuyerFeeBasisPoints,\n        devSellerFeeBasisPoints,\n        sellerBountyBasisPoints,\n        transferFee,\n        transferFeeTokenAddress,\n    };\n}\n\n/**\n * Compute the `basePrice` and `extra` parameters to be used to price an order.\n * Also validates the expiration time and auction type.\n * @param tokenAddress Address of the ERC-20 token to use for trading.\n * Use the null address for ETH\n * @param expirationTime When the auction expires, or 0 if never.\n * @param startAmount The base value for the order, in the token's main units (e.g. ETH instead of wei)\n * @param endAmount The end value for the order, in the token's main units (e.g. ETH instead of wei). If unspecified, the order's `extra` attribute will be 0\n */\nasync function _getPriceParameters(\n    orderSide,\n    tokenAddress,\n    expirationTime,\n    startAmount,\n    endAmount,\n    waitingForBestCounterOrder = false,\n    englishAuctionReservePrice\n) {\n    const priceDiff = endAmount != null ? startAmount - endAmount : 0;\n    const paymentToken = tokenAddress.toLowerCase();\n\n    // const isEther = tokenAddress == WyvernProtocol.NULL_ADDRESS;\n    // const { tokens } = await this.api.getPaymentTokens({ address: paymentToken });\n    // const token = tokens[0];\n\n    // Note: WyvernProtocol.toBaseUnitAmount(makeBigNumber(startAmount), token.decimals)\n    // will fail if too many decimal places, so special-case ether\n    // const basePrice = isEther\n    //   ? new BigNumber(parseEther(startAmount)).round()\n    //   : WyvernProtocol.toBaseUnitAmount(new BigNumber(startAmount), token.decimals);\n    const basePrice = new BigNumber(parseEther(String(startAmount)));\n\n    // const extra = isEther\n    //   ? new BigNumber(parseEther(priceDiff)).decimalPlaces()\n    //   : WyvernProtocol.toBaseUnitAmount(new BigNumber(priceDiff), token.decimals);\n    // console.log(basePrice, priceDiff);\n    const extra = new BigNumber(parseEther(String(priceDiff)));\n\n    // const reservePrice = englishAuctionReservePrice\n    //   ? isEther\n    //     ? new BigNumber(parseEther(englishAuctionReservePrice))\n    //     : WyvernProtocol.toBaseUnitAmount(new BigNumber(englishAuctionReservePrice), token.decimals)\n    //   : undefined;\n    const reservePrice = englishAuctionReservePrice\n        ? new BigNumber(parseEther(englishAuctionReservePrice))\n        : undefined;\n\n    return { basePrice, extra, paymentToken, reservePrice };\n}\n\nfunction _validateFees(totalBuyerFeeBasisPoints, totalSellerFeeBasisPoints) {\n    const maxFeePercent = INVERSE_BASIS_POINT / 100;\n\n    if (totalBuyerFeeBasisPoints > INVERSE_BASIS_POINT || totalSellerFeeBasisPoints > INVERSE_BASIS_POINT) {\n        throw new Error(`Invalid buyer/seller fees: must be less than ${maxFeePercent}%`);\n    }\n\n    if (totalBuyerFeeBasisPoints < 0 || totalSellerFeeBasisPoints < 0) {\n        throw new Error(`Invalid buyer/seller fees: must be at least 0%`);\n    }\n}\n\nfunction _getSellFeeParameters(\n    totalBuyerFeeBasisPoints,\n    totalSellerFeeBasisPoints,\n    waitForHighestBid,\n    sellerBountyBasisPoints = 0\n)  {\n    // just making basic check if fee is less than 100% and not negative\n    _validateFees(totalBuyerFeeBasisPoints, totalSellerFeeBasisPoints);\n\n    // Use buyer as the maker when it's an English auction, so Wyvern sets prices correctly\n    const feeRecipient = waitForHighestBid ? WyvernProtocol.NULL_ADDRESS : OPENSEA_FEE_RECIPIENT;\n\n    // Swap maker/taker fees when it's an English auction,\n    // since these sell orders are takers not makers\n    const makerRelayerFee = waitForHighestBid ? new BigNumber(totalBuyerFeeBasisPoints) : new BigNumber(totalSellerFeeBasisPoints);\n    const takerRelayerFee = waitForHighestBid ? new BigNumber(totalSellerFeeBasisPoints) : new BigNumber(totalBuyerFeeBasisPoints);\n\n    return {\n        makerRelayerFee,\n        takerRelayerFee,\n        makerProtocolFee: new BigNumber(0),\n        takerProtocolFee: new BigNumber(0),\n        makerReferrerFee: new BigNumber(sellerBountyBasisPoints),\n        feeRecipient,\n        feeMethod: 1, // 0 protocol fee ,1 split fee\n    };\n};\n\nconst getMethod = (abi, name) => {\n    const methodAbi = abi.find((x) => x.type == \"function\" && x.name == name);\n    \n    if (!methodAbi) {\n        throw new Error(`ABI ${name} not found`);\n    }\n\n    // Have to cast since there's a bug in  web3 types on the 'type' field\n    return methodAbi;\n};\n\nasync function _getStaticCallTargetAndExtraData({ useTxnOriginStaticCall }) {\n    if (!useTxnOriginStaticCall) {\n        // While testing, we will use dummy values for mainnet. We will remove this if-statement once we have pushed the PR once and tested on Rinkeby\n        return {\n            staticTarget: WyvernProtocol.NULL_ADDRESS,\n            staticExtradata: \"0x\",\n        };\n    };\n\n    if (useTxnOriginStaticCall) {\n        return {\n            staticTarget: STATIC_CALL_TX_ORIGIN_ADDRESS,\n            staticExtradata: encodeCall(\n                getMethod(\n                    StaticCheckTxOrigin,\n                    \"succeedIfTxOriginMatchesHardcodedAddress\"\n                ),\n                []\n            ),\n        };\n    } else {\n        // Noop - no checks\n        return {\n            staticTarget: WyvernProtocol.NULL_ADDRESS,\n            staticExtradata: \"0x\",\n        };\n    };\n};\n\nconst assetContractFromJSON = (assetContract) => {\n    return {\n        name: assetContract.name,\n        description: assetContract.description,\n        type: assetContract.assetContract_type,\n        schemaName: assetContract.schema_name,\n        address: assetContract.address,\n        tokenSymbol: assetContract.symbol,\n        buyerFeeBasisPoints: +assetContract.buyer_fee_basis_points,\n        sellerFeeBasisPoints: +assetContract.seller_fee_basis_points,\n        openseaBuyerFeeBasisPoints: +assetContract.opensea_buyer_fee_basis_points,\n        openseaSellerFeeBasisPoints: +assetContract.opensea_seller_fee_basis_points,\n        devBuyerFeeBasisPoints: +assetContract.dev_buyer_fee_basis_points,\n        devSellerFeeBasisPoints: +assetContract.dev_seller_fee_basis_points,\n        imageUrl: assetContract.image_url,\n        externalLink: assetContract.external_link,\n        wikiLink: assetContract.wiki_link,\n    };\n};\n\nexport const collectionFromJSON = (collection) => {\n    const createdDate = new Date(`${collection.created_date}Z`);\n\n    return {\n        createdDate,\n        name: collection.name,\n        description: collection.description,\n        slug: collection.slug,\n        editors: collection.editors,\n        hidden: collection.hidden,\n        featured: collection.featured,\n        featuredImageUrl: collection.featured_image_url,\n        displayData: collection.display_data,\n        paymentTokens: (collection.payment_tokens || []).map(tokenFromJSON),\n        openseaBuyerFeeBasisPoints: +collection.opensea_buyer_fee_basis_points,\n        openseaSellerFeeBasisPoints: +collection.opensea_seller_fee_basis_points,\n        devBuyerFeeBasisPoints: +collection.dev_buyer_fee_basis_points,\n        devSellerFeeBasisPoints: +collection.dev_seller_fee_basis_points,\n        payoutAddress: collection.payout_address,\n        imageUrl: collection.image_url,\n        largeImageUrl: collection.large_image_url,\n        stats: collection.stats,\n        traitStats: collection.traits,\n        externalLink: collection.external_url,\n        wikiLink: collection.wiki_url,\n    };\n};\n\nconst userFromJSON = (user) => {\n    return { username: user.username };\n};\n\nconst accountFromJSON = (account) => {\n    return {\n        address: account.address,\n        config: account.config,\n        profileImgUrl: account.profile_img_url,\n        user: account.user ? userFromJSON(account.user) : null\n    };\n};\n\nconst transactionFromJSON = (transaction) => {\n    return {\n        fromAccount: accountFromJSON(transaction.from_account),\n        toAccount: accountFromJSON(transaction.to_account),\n        createdDate: new Date(`${transaction.created_date}Z`),\n        modifiedDate: new Date(`${transaction.modified_date}Z`),\n        transactionHash: transaction.transaction_hash,\n        transactionIndex: transaction.transaction_index,\n        blockNumber: transaction.block_number,\n        blockHash: transaction.block_hash,\n        timestamp: new Date(`${transaction.timestamp}Z`)\n    };\n};\n\nconst assetEventFromJSON = (assetEvent) => {\n    return {\n        eventType: assetEvent.event_type,\n        eventTimestamp: assetEvent.event_timestamp,\n        auctionType: assetEvent.auction_type,\n        totalPrice: assetEvent.total_price,\n        transaction: assetEvent.transaction\n          ? transactionFromJSON(assetEvent.transaction)\n          : null,\n        paymentToken: assetEvent.payment_token\n          ? tokenFromJSON(assetEvent.payment_token)\n          : null\n    };\n};\n\nconst assetFromJSON = (asset) => {\n    const isAnimated = asset.image_url && asset.image_url.endsWith(\".gif\");\n    const isSvg = asset.image_url && asset.image_url.endsWith(\".svg\");\n    const fromJSON = {\n        tokenId: asset.token_id.toString(),\n        tokenAddress: asset.asset_contract.address,\n        name: asset.name,\n        description: asset.description,\n        owner: asset.owner,\n        assetContract: assetContractFromJSON(asset.asset_contract),\n        collection: collectionFromJSON(asset.collection),\n        orders: asset.orders ? asset.orders.map(orderFromJSON) : null,\n        sellOrders: asset.sell_orders ? asset.sell_orders.map(orderFromJSON) : null,\n        buyOrders: asset.buy_orders ? asset.buy_orders.map(orderFromJSON) : null,\n\n        isPresale: asset.is_presale,\n        // Don't use previews if it's a special image\n        imageUrl:\n          isAnimated || isSvg\n            ? asset.image_url\n            : asset.image_preview_url || asset.image_url,\n        imagePreviewUrl: asset.image_preview_url,\n        imageUrlOriginal: asset.image_original_url,\n        imageUrlThumbnail: asset.image_thumbnail_url,\n\n        externalLink: asset.external_link,\n        openseaLink: asset.permalink,\n        traits: asset.traits,\n        numSales: asset.num_sales,\n        lastSale: asset.last_sale ? assetEventFromJSON(asset.last_sale) : null,\n        backgroundColor: asset.background_color\n          ? `#${asset.background_color}`\n          : null,\n\n        transferFee: asset.transfer_fee ? new BigNumber(asset.transfer_fee) : null,\n        transferFeePaymentToken: asset.transfer_fee_payment_token\n          ? tokenFromJSON(asset.transfer_fee_payment_token)\n          : null\n    };\n\n    // If orders were included, put them in sell/buy order groups\n    if (fromJSON.orders && !fromJSON.sellOrders) {\n        fromJSON.sellOrders = fromJSON.orders.filter((o) => o.side == 1);\n    }\n\n    if (fromJSON.orders && !fromJSON.buyOrders) {\n        fromJSON.buyOrders = fromJSON.orders.filter((o) => o.side == 0);\n    }\n\n    return fromJSON;\n};\n\n/**\n * Fetch an asset from the API, throwing if none is found\n * @param tokenAddress Address of the asset's contract\n * @param tokenId The asset's token ID, or null if ERC-20\n * @param retries Number of times to retry if the service is unavailable for any reason\n */\nasync function getAsset({ tokenAddress, tokenId }) {\n    const { data } = await axios(`${OPENSEA_URL}asset/${tokenAddress}/${tokenId || 0}/`);\n    return assetFromJSON(data);\n}\n\nasync function validateOrder({ order, accountAddress, wyvernExchange }) {\n    // Check sell parameters\n    const sellValid = await wyvernExchange.functions.validateOrder_(\n        [\n            order.exchange,\n            order.maker,\n            order.taker,\n            order.feeRecipient,\n            order.target,\n            order.staticTarget,\n            order.paymentToken\n        ],\n        [\n            250.0.toFixed(),\n            0.0.toFixed(),\n            order.makerProtocolFee,\n            order.takerProtocolFee,\n            0.0.toFixed(),\n            0.0.toFixed(),\n            order.listingTime,\n            order.expirationTime,\n            order.salt,\n        ],\n        order.feeMethod,\n        order.side,\n        order.saleKind,\n        order.howToCall,\n        order.calldata,\n        order.replacementPattern,\n        order.staticExtradata,\n        order.v,\n        order.r,\n        order.s\n    );\n\n    if (!sellValid) {\n        // eslint-disable-next-line no-throw-literal\n        throw {\n            message: new Error(`Failed to validate sell order parameters. It looks like this listing is invalid.`),\n            code: \"InvalidOrder\",\n        };\n        // TODO: call order invalidate API\n    }\n\n    return sellValid;\n}\n\n// sourced from 0x.js:\n// https://github.com/ProjectWyvern/wyvern-js/blob/39999cb93ce5d80ea90b4382182d1bd4339a9c6c/src/utils/signature_utils.ts\nasync function parseSignatureHex(signature) {\n    // HACK: There is no consensus on whether the signatureHex string should be formatted as\n    // v + r + s OR r + s + v, and different clients (even different versions of the same client)\n    // return the signature params in different orders. In order to support all client implementations,\n    // we parse the signature in both ways, and evaluate if either one is a valid signature.\n    const validVParamValues = [27, 28];\n\n    const ecSignatureRSV = _parseSignatureHexAsRSV(signature);\n    if (_.includes(validVParamValues, ecSignatureRSV.v)) {\n        return ecSignatureRSV;\n    };\n\n    // For older clients\n    const ecSignatureVRS = _parseSignatureHexAsVRS(signature);\n    if (_.includes(validVParamValues, ecSignatureVRS.v)) {\n        return ecSignatureVRS;\n    };\n\n    throw new Error(\"Invalid signature\");\n\n    function _parseSignatureHexAsVRS(signatureHex) {\n        const signatureBuffer = ethUtil.toBuffer(signatureHex);\n        let v = signatureBuffer[0];\n\n        if (v < 27) {\n            v += 27;\n        }\n\n        const r = signatureBuffer.slice(1, 33);\n        const s = signatureBuffer.slice(33, 65);\n        const ecSignature = {\n            v,\n            r: ethUtil.bufferToHex(r),\n            s: ethUtil.bufferToHex(s),\n        };\n\n        return ecSignature;\n    };\n\n    function _parseSignatureHexAsRSV(signatureHex) {\n        const { v, r, s } = ethUtil.fromRpcSig(signatureHex);\n        const ecSignature = {\n            v,\n            r: ethUtil.bufferToHex(r),\n            s: ethUtil.bufferToHex(s),\n        };\n\n        return ecSignature;\n    };\n};\n\nasync function personalSignAsync(provider, message, signerAddress) {\n    return new Promise((resolve, reject) => {\n        const callback = async (err, signature) => {\n            if (err) reject(err);\n            if (signature.error) {\n                reject(signature.error.message);\n            };\n\n            resolve(parseSignatureHex(signature.result));\n\n            // // console.log(result);\n            // const d = signature.result;\n            // let v = d.slice(-2);\n            // let r = d.slice(2, -66);\n            // let s = d.slice(-66, -2);\n\n            // let actualsignature = v + r + s + '03';\n\n            // // const dhs = await this.contractInstace.methods\n            // //   .setApprovalForAll(OPERATOR_ADDRESS, true)\n            // //   .send({ from: this.metamask.metaMaskAddress });\n            // resolve(`0x${actualsignature}`);\n        };\n\n        // console.log(orderHex, metaMaskAddress);\n        provider.sendAsync({\n            method: \"personal_sign\",\n            params: [message, signerAddress],\n            from: signerAddress,\n        }, callback);\n    });\n};\n\nexport async function signTypedDataAsync(provider, message, signerAddress) {\n    let signature;\n    return new Promise((resolve, reject) => {\n        const callback = async (err, result) => {\n            console.log(err);\n            if (err) reject(err);\n            if (result.error) {\n                reject(result.error.message);\n            };\n\n            // eslint-disable-next-line prefer-promise-reject-errors\n            if (result.error) return reject(\"ERROR\", result);\n            // console.log(result);\n            // const d = result.result;\n\n            // let v = d.slice(-2);\n            // let r = d.slice(2, -66);\n            // let s = d.slice(-66, -2);\n\n            // let actualsignature = v + r + s + '03';\n            resolve(parseSignatureHex(result.result));\n        };\n\n        const stringified = JSON.stringify({ ...message });\n\n        try {\n            // Using sign typed data V4 works with a stringified message, used by browser providers i.e. Metamask\n            provider.sendAsync({\n                method: \"eth_signTypedData_v4\",\n                params: [signerAddress, stringified],\n                from: signerAddress,\n                id: new Date().getTime(),\n            }, callback);\n        } catch (error) {\n            console.log(error);\n\n            // Fallback to normal sign typed data for node providers, without using stringified message\n            // https://github.com/coinbase/coinbase-wallet-sdk/issues/60\n            provider.sendAsync({\n                method: \"eth_signTypedData\",\n                params: [signerAddress, message],\n                from: signerAddress,\n                id: new Date().getTime(),\n            }, callback);\n        };\n    });\n}\n\nasync function _authorizeOrder({ order, provider, nonce }) {\n    // 2.2 Sign order flow\n    const signerAddress = order.maker;\n\n    if (order.exchange === mainnetWyvernConfigByNetwork.wyvernExchangeContractAddress && order.hash) {\n        const message = order.hash;\n        // v1\n        return await personalSignAsync(provider, message, signerAddress);\n    }\n\n    // 2.3 Sign order flow using EIP-712\n    // We need to manually specify each field because OS orders can contain unrelated data\n    const orderForSigning = {\n        maker: order.maker,\n        exchange: order.exchange,\n        taker: order.taker,\n        makerRelayerFee: order.makerRelayerFee.toString(),\n        takerRelayerFee: order.takerRelayerFee.toString(),\n        makerProtocolFee: order.makerProtocolFee.toString(),\n        takerProtocolFee: order.takerProtocolFee.toString(),\n        feeRecipient: order.feeRecipient,\n        feeMethod: order.feeMethod,\n        side: order.side,\n        saleKind: order.saleKind,\n        target: order.target,\n        howToCall: order.howToCall,\n        calldata: order.calldata,\n        replacementPattern: order.replacementPattern,\n        staticTarget: order.staticTarget,\n        staticExtradata: order.staticExtradata,\n        paymentToken: order.paymentToken,\n        basePrice: order.basePrice.toString(),\n        extra: order.extra.toString(),\n        listingTime: order.listingTime.toString(),\n        expirationTime: order.expirationTime.toString(),\n        salt: order.salt.toString(),\n    };\n\n    // We don't JSON.stringify as certain wallet providers sanitize this data\n    // https://github.com/coinbase/coinbase-wallet-sdk/issues/60\n    const message = {\n        types: OrderTypesEIP712,\n        domain: {\n            name: WyvernDomainNameEIP712,\n            version: WyvernDomainVersionEIP712,\n            chainId: 1,\n            verifyingContract: order.exchange,\n        },\n        primaryType: \"Order\",\n        message: { ...orderForSigning, nonce },\n    };\n\n    const ecSignature = await signTypedDataAsync(\n        provider,\n        message,\n        signerAddress\n    );\n\n    return { ...ecSignature, nonce };\n};\n\n/**\n * Convert an order to JSON, hashing it as well if necessary\n * @param order order (hashed or unhashed)\n */\nconst orderToJSON = (order) => {\n    const asJSON = {\n        exchange: order.exchange.toLowerCase(),\n        maker: order.maker.toLowerCase(),\n        taker: order.taker.toLowerCase(),\n        makerRelayerFee: order.makerRelayerFee.toString(),\n        takerRelayerFee: order.takerRelayerFee.toString(),\n        makerProtocolFee: order.makerProtocolFee.toString(),\n        takerProtocolFee: order.takerProtocolFee.toString(),\n        makerReferrerFee: order.makerReferrerFee.toString(),\n        feeMethod: order.feeMethod,\n        feeRecipient: order.feeRecipient.toLowerCase(),\n        side: order.side,\n        saleKind: order.saleKind,\n        target: order.target.toLowerCase(),\n        howToCall: order.howToCall,\n        calldata: order.calldata,\n        replacementPattern: order.replacementPattern,\n        staticTarget: order.staticTarget.toLowerCase(),\n        staticExtradata: order.staticExtradata,\n        paymentToken: order.paymentToken.toLowerCase(),\n        quantity: order.quantity.toString(),\n        basePrice: order.basePrice.toString(),\n        englishAuctionReservePrice: order.englishAuctionReservePrice\n          ? order.englishAuctionReservePrice.toString()\n          : undefined,\n        extra: order.extra.toString(),\n        createdTime: order.createdTime ? order.createdTime.toString() : undefined,\n        listingTime: order.listingTime.toString(),\n        expirationTime: order.expirationTime.toString(),\n        salt: order.salt.toString(),\n\n        metadata: order.metadata,\n\n        v: order.v,\n        r: order.r,\n        s: order.s,\n        nonce: order.nonce,\n    };\n\n    return asJSON;\n};\n\nasync function postOrder(order, retries = 2) {\n    try {\n        const { data } = await axios.post(\n            `https://api.opensea.io/wyvern/v1/orders/post/`,\n            order,\n            { headers: { \"x-api-key\": X_API_KEY }}\n        );\n\n        return data;\n    } catch (error) {\n        throw new Error(error);\n    };\n};\n\n/**\n * Convert an order to JSON for golom, hashing it as well if necessary\n * @param order order (hashed or unhashed)\n */\nconst orderToGolomJSON = (order) => {\n    const asJSON = {\n        exchange: order.exchange.toLowerCase(),\n        maker: { address: order.maker.toLowerCase() },\n        taker: { address: order.taker.toLowerCase() },\n        maker_relayer_fee: order.makerRelayerFee.toString(),\n        taker_relayer_fee: order.takerRelayerFee.toString(),\n        maker_protocol_fee: order.makerProtocolFee.toString(),\n        taker_protocol_fee: order.takerProtocolFee.toString(),\n        makerReferrerFee: order.makerReferrerFee.toString(),\n        fee_method: order.feeMethod,\n        fee_recipient: { address: order.feeRecipient.toLowerCase() },\n        side: order.side,\n        sale_kind: order.saleKind,\n        target: order.target.toLowerCase(),\n        how_to_call: order.howToCall,\n        calldata: order.calldata,\n        replacement_pattern: order.replacementPattern,\n        static_target: order.staticTarget.toLowerCase(),\n        static_extradata: order.staticExtradata,\n        payment_token: order.paymentToken.toLowerCase(),\n        quantity: order.quantity.toString(),\n        base_price: order.basePrice.toString(),\n        englishAuctionReservePrice: order.englishAuctionReservePrice\n          ? order.englishAuctionReservePrice.toString()\n          : undefined,\n        extra: order.extra.toString(),\n        createdTime: order.createdTime ? order.createdTime.toString() : undefined,\n        listing_time: order.listingTime.toString(),\n        expiration_time: order.expirationTime.toString(),\n        salt: order.salt.toString(),\n        metadata: order.metadata,\n        v: order.v,\n        r: order.r,\n        s: order.s,\n        prefixed_hash: order.hash,\n      };\n    \n    return asJSON;\n};\n\n/**\n * Validate and post an order to the OpenSea orderbook.\n * @param order The order to post. Can either be signed by the maker or pre-approved on the Wyvern contract using approveOrder. See https://github.com/ProjectWyvern/wyvern-ethereum/blob/master/contracts/exchange/Exchange.sol#L178\n * @returns The order as stored by the orderbook\n */\nasync function validateAndPostOrder({ order }) {\n    // Validation is called server-side\n    return orderToJSON(order);\n}\n\nfunction cancelOSOrder({ provider, order }) {\n    const wyvernExchange = WyvernContract(provider);\n\n    // const cancelHash = wyvernExchange.methods\n      //   .hashToSign_(\n      //     [\n      //       order.exchange,\n      //       order.maker,\n      //       order.taker,\n      //       order.feeRecipient,\n      //       order.target,\n      //       order.staticTarget,\n      //       order.paymentToken\n      //     ],\n      //     [\n      //       order.makerRelayerFee,\n      //       order.takerRelayerFee,\n      //       order.makerProtocolFee,\n      //       order.takerProtocolFee,\n      //       order.basePrice,\n      //       order.extra,\n      //       order.listingTime,\n      //       order.expirationTime,\n      //       order.salt\n      //     ],\n      //     order.feeMethod,\n      //     order.side,\n      //     order.saleKind,\n      //     order.howToCall,\n      //     order.calldata,\n      //     order.replacementPattern,\n      //     order.staticExtradata\n      //   )\n      //   .call();\n      // console.log(cancelHash);\n\n    return wyvernExchange.methods.cancelOrder_(\n        [\n            order.exchange,\n            order.maker,\n            order.taker,\n            order.feeRecipient,\n            order.target,\n            order.staticTarget,\n            order.paymentToken,\n        ],\n        [\n            order.makerRelayerFee,\n            order.takerRelayerFee,\n            order.makerProtocolFee,\n            order.takerProtocolFee,\n            order.basePrice,\n            order.extra,\n            order.listingTime,\n            order.expirationTime,\n            order.salt,\n        ],\n        order.feeMethod,\n        order.side,\n        order.saleKind,\n        order.howToCall,\n        order.calldata,\n        order.replacementPattern,\n        order.staticExtradata,\n        order.v || 0,\n        order.r || NULL_BLOCK_HASH,\n        order.s || NULL_BLOCK_HASH\n    );\n}\n\nexport { fulfillOrder, cancelOSOrder };\n\n// maker:\n// 0xafac92864611c564e7fa1a6c6d07b45807536943\n// exchange:\n// 0x7f268357a8c2552623316e2562d90e642bb538e5\n// taker:\n// 0x0000000000000000000000000000000000000000\n// makerRelayerFee:\n// 500\n// takerRelayerFee:\n// 0\n// makerProtocolFee:\n// 0\n// takerProtocolFee:\n// 0\n// feeRecipient:\n// 0x5b3256965e7c3cf26e11fcaf296dfc8807c01073\n// feeMethod:\n// 1\n// side:\n// 1\n// saleKind:\n// 0\n// target:\n// 0xbaf2127b49fc93cbca6269fade0f7f31df4c88a7\n// howToCall:\n// 1\n// calldata:\n// 0xfb16a595000000000000000000000000afac92864611c564e7fa1a6c6d07b45807536943000000000000000000000000000000000000000000000000000000000000000000000000000000000000000079fcdef22feed20eddacbb2587640e45491b757f0000000000000000000000000000000000000000000000000000000000000eb5000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000000\n// replacementPattern:\n// 0x000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n// staticTarget:\n// 0x0000000000000000000000000000000000000000\n// staticExtradata:\n// 0x\n// paymentToken:\n// 0x0000000000000000000000000000000000000000\n// basePrice:\n// 6000000000000000000\n// extra:\n// 0\n// listingTime:\n// 1645298828\n// expirationTime:\n// 1645903716\n// salt:\n// 87906966303110818969546189067137492865825614986988195802067881988151729727179\n// nonce:\n// 0\n\n// basePrice: \"6000000000000000000\"\n// calldata: \"0xfb16a595000000000000000000000000afac92864611c564e7fa1a6c6d07b45807536943000000000000000000000000000000000000000000000000000000000000000000000000000000000000000079fcdef22feed20eddacbb2587640e45491b757f0000000000000000000000000000000000000000000000000000000000000eb5000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000000\"\n// exchange: \"0x7f268357a8c2552623316e2562d90e642bb538e5\"\n// expirationTime: \"1645903716\"\n// extra: \"0\"\n// feeMethod: 1\n// feeRecipient: \"0x5b3256965e7c3cf26e11fcaf296dfc8807c01073\"\n// howToCall: 1\n// listingTime: \"1645298816\"\n// maker: \"0xafac92864611c564e7fa1a6c6d07b45807536943\"\n// makerProtocolFee: \"0\"\n// makerReferrerFee: \"0\"\n// makerRelayerFee: \"500\"\n// metadata: {asset: {id: \"3765\", address: \"0x79fcdef22feed20eddacbb2587640e45491b757f\"}, schema: \"ERC721\"}\n// nonce: 0\n// paymentToken: \"0x0000000000000000000000000000000000000000\"\n// quantity: \"1\"\n// r: \"0x0c70bd3052b0da178141b84e7bdbe511acc5f7f601281850cd5f93f145c9bbb5\"\n// replacementPattern: \"0x000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n// s: \"0x7a2bf43b7b616073bf2486d2890b674f9587f68f59a84e4d7fff55842bbe9b60\"\n// saleKind: 0\n// salt: \"87577974536160270209585191401103724053896633202437364720132507693990122512257\"\n// side: 1\n// staticExtradata: \"0x\"\n// staticTarget: \"0x0000000000000000000000000000000000000000\"\n// taker: \"0x0000000000000000000000000000000000000000\"\n// takerProtocolFee: \"0\"\n// takerRelayerFee: \"0\"\n// target: \"0xbaf2127b49fc93cbca6269fade0f7f31df4c88a7\"\n// v: 28\n"],"mappings":"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,CAAClX,KAAD,CAAlB;AACH;;AAED,SAAS2X,aAAT,SAA4C;EAAA,IAArB;IAAE7M,QAAF;IAAY9K;EAAZ,CAAqB;EACxC,MAAMmJ,cAAc,GAAGtK,cAAc,CAACiM,QAAD,CAArC,CADwC,CAGxC;EACE;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEF,OAAO3B,cAAc,CAACC,OAAf,CAAuBwO,YAAvB,CACH,CACI5X,KAAK,CAACa,QADV,EAEIb,KAAK,CAACe,KAFV,EAGIf,KAAK,CAACiB,KAHV,EAIIjB,KAAK,CAACkC,YAJV,EAKIlC,KAAK,CAACsC,MALV,EAMItC,KAAK,CAAC4C,YANV,EAOI5C,KAAK,CAACgD,YAPV,CADG,EAUH,CACIhD,KAAK,CAACkB,eADV,EAEIlB,KAAK,CAACoB,eAFV,EAGIpB,KAAK,CAACsB,gBAHV,EAIItB,KAAK,CAACwB,gBAJV,EAKIxB,KAAK,CAACkD,SALV,EAMIlD,KAAK,CAACoD,KANV,EAOIpD,KAAK,CAAC6D,WAPV,EAQI7D,KAAK,CAAC+D,cARV,EASI/D,KAAK,CAACiE,IATV,CAVG,EAqBHjE,KAAK,CAAC+B,SArBH,EAsBH/B,KAAK,CAACmC,IAtBH,EAuBHnC,KAAK,CAACoC,QAvBH,EAwBHpC,KAAK,CAACuC,SAxBH,EAyBHvC,KAAK,CAACyC,QAzBH,EA0BHzC,KAAK,CAAC0C,kBA1BH,EA2BH1C,KAAK,CAAC8C,eA3BH,EA4BH9C,KAAK,CAACkE,CAAN,IAAW,CA5BR,EA6BHlE,KAAK,CAACoE,CAAN,IAAWpG,eA7BR,EA8BHgC,KAAK,CAACqE,CAAN,IAAWrG,eA9BR,CAAP;AAgCH;;AAED,SAAS6M,YAAT,EAAuB8M,aAAvB,G,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"module"}