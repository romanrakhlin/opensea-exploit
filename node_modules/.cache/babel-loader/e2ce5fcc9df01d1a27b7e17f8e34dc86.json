{"ast":null,"code":"import { WyvernProtocol } from \"wyvern-js\";\nimport BigNumber from \"bignumber.js\";\nimport isValidAddress from \"ethereumjs-util\";\nimport { ERC721Schema } from \"../WyvernSchema\";\nimport { WyvernContract } from \"../contracts\";\nimport encodeSell from \"../helpers/EncodeSell\";\nimport encodeBuy from \"../helpers/EncodeBuy\";\nimport getTimeParameters from \"../helpers/GetTimeParameters\";\nimport { NULL_BLOCK_HASH, INVERSE_BASIS_POINT, OPENSEA_FEE_RECIPIENT, MERKLE_VALIDATOR_MAINNET } from \"../Constants\";\n\nconst performOrder = async _ref => {\n  let {\n    order,\n    provider,\n    accountAddress,\n    recipientAddress,\n    referrerAddress\n  } = _ref;\n  console.info(`Account: ${accountAddress} | Recipient: ${recipientAddress} | Referrer: ${referrerAddress}`); // check if valid order\n\n  const wyvernExchange = WyvernContract(provider);\n  const isValid = await validateOrder({\n    order,\n    accountAddress,\n    wyvernExchange\n  });\n  const matchingOrder = makeMatchingOrder({\n    order,\n    accountAddress,\n    recipientAddress: recipientAddress\n  });\n  const {\n    buy,\n    sell\n  } = assignOrdersToSides(order, matchingOrder);\n\n  const metadata = _getMetadata(order, referrerAddress);\n\n  return await _atomicMatch({\n    buy,\n    sell,\n    accountAddress,\n    wyvernExchange,\n    metadata\n  });\n};\n\nasync function validateOrder(_ref2) {\n  let {\n    order,\n    accountAddress,\n    wyvernExchange\n  } = _ref2;\n  // Check sell parameters\n  const sellValid = await wyvernExchange.functions.validateOrder_([order.exchange, order.maker, order.taker, order.feeRecipient, order.target, order.staticTarget, order.paymentToken], [250.0.toFixed(), 0.0.toFixed(), order.makerProtocolFee, order.takerProtocolFee, 0.0.toFixed(), 0.0.toFixed(), order.listingTime, order.expirationTime, order.salt], order.feeMethod, order.side, order.saleKind, order.howToCall, order.calldata, order.replacementPattern, order.staticExtradata, order.v, order.r, order.s);\n\n  if (!sellValid) {\n    // eslint-disable-next-line no-throw-literal\n    throw {\n      message: new Error(`Failed to validate sell order parameters. It looks like this listing is invalid.`),\n      code: \"InvalidOrder\"\n    }; // TODO: call order invalidate API\n  }\n\n  return sellValid;\n}\n\n;\n\nfunction makeMatchingOrder(_ref3) {\n  let {\n    order,\n    accountAddress,\n    recipientAddress\n  } = _ref3;\n  accountAddress = accountAddress.toLowerCase();\n  recipientAddress = recipientAddress.toLowerCase();\n\n  const computeOrderParams = () => {\n    const shouldValidate = order.target === MERKLE_VALIDATOR_MAINNET;\n\n    if (\"asset\" in order.metadata) {\n      const schema = ERC721Schema; // currently supporting ERC721 only\n\n      return order.side == 0 ? encodeSell(schema, order.metadata.asset, recipientAddress, shouldValidate ? order.target : undefined) : encodeBuy(schema, order.metadata.asset, recipientAddress, shouldValidate ? order.target : undefined);\n    } else {\n      throw new Error(\"Invalid order metadata\");\n    }\n  };\n\n  const {\n    target,\n    calldata,\n    replacementPattern\n  } = computeOrderParams();\n  const times = getTimeParameters(0); // Compat for matching buy orders that have fee recipient still on them\n\n  const feeRecipient = OPENSEA_FEE_RECIPIENT; // Maybe NULLADDRESS\n\n  const matchingOrder = {\n    exchange: order.exchange,\n    maker: accountAddress,\n    taker: order.maker,\n    quantity: order.quantity,\n    makerRelayerFee: order.makerRelayerFee,\n    takerRelayerFee: order.takerRelayerFee,\n    makerProtocolFee: order.makerProtocolFee,\n    takerProtocolFee: order.takerProtocolFee,\n    makerReferrerFee: order.makerReferrerFee,\n    waitingForBestCounterOrder: false,\n    feeMethod: order.feeMethod,\n    feeRecipient,\n    side: (order.side + 1) % 2,\n    saleKind: 0,\n    // 0 fixed price 1 ducch aucion\n    target,\n    howToCall: order.howToCall,\n    calldata,\n    replacementPattern,\n    staticTarget: WyvernProtocol.NULL_ADDRESS,\n    staticExtradata: \"0x\",\n    paymentToken: order.paymentToken,\n    basePrice: order.basePrice,\n    extra: BigNumber(0),\n    listingTime: times.listingTime,\n    expirationTime: times.expirationTime,\n    salt: WyvernProtocol.generatePseudoRandomSalt(),\n    metadata: order.metadata\n  };\n  return matchingOrder;\n}\n\n;\n\nfunction assignOrdersToSides(order, matchingOrder) {\n  const isSellOrder = order.side == 1;\n  let buy;\n  let sell;\n\n  if (!isSellOrder) {\n    buy = order;\n    sell = { ...matchingOrder,\n      v: buy.v,\n      r: buy.r,\n      s: buy.s\n    };\n  } else {\n    sell = order;\n    buy = { ...matchingOrder,\n      v: sell.v,\n      r: sell.r,\n      s: sell.s\n    };\n  }\n\n  return {\n    buy,\n    sell\n  };\n}\n\n;\n\nconst _getMetadata = (order, referrerAddress) => {\n  const referrer = referrerAddress || order.metadata.referrerAddress;\n\n  if (referrer && isValidAddress(referrer)) {\n    return `0x000000000000000000000000${referrer.substr(2)}`;\n  }\n\n  return undefined;\n};\n\nconst _correctGasAmount = estimation => {\n  return Math.ceil(estimation * 1.01);\n};\n\nasync function _atomicMatch(_ref4) {\n  let {\n    buy,\n    sell,\n    accountAddress,\n    wyvernExchange,\n    metadata = NULL_BLOCK_HASH\n  } = _ref4;\n  let value;\n\n  if (buy.paymentToken == WyvernProtocol.NULL_ADDRESS) {\n    value = await _getRequiredAmountForTakingSellOrder(sell, wyvernExchange);\n  }\n\n  const txnData = {\n    from: accountAddress,\n    value\n  };\n  const args = [[buy.exchange, buy.maker, buy.taker, buy.feeRecipient, buy.target, buy.staticTarget, buy.paymentToken, sell.exchange, sell.maker, sell.taker, sell.feeRecipient, sell.target, sell.staticTarget, sell.paymentToken], [250.0.toString(), 0.0.toString(), buy.makerProtocolFee.toString(), buy.takerProtocolFee.toString(), 0.0.toString(), buy.extra.toString(), buy.listingTime.toString(), buy.expirationTime.toString(), buy.salt.toString(), 250.0.toString(), 0.0.toString(), sell.makerProtocolFee.toString(), sell.takerProtocolFee.toString(), 0.0.toString(), 0.0.toString(), sell.listingTime.toString(), sell.expirationTime.toString(), sell.salt.toString()], [buy.feeMethod, buy.side, buy.saleKind, buy.howToCall, sell.feeMethod, sell.side, sell.saleKind, sell.howToCall], buy.calldata, sell.calldata, buy.replacementPattern, sell.replacementPattern, buy.staticExtradata, sell.staticExtradata, [buy.v || 0, sell.v || 0], [buy.r || NULL_BLOCK_HASH, buy.s || NULL_BLOCK_HASH, sell.r || NULL_BLOCK_HASH, sell.s || NULL_BLOCK_HASH, metadata]]; // const gasEstimate = await wyvernExchange.functions.estimateGasAsync(txnData);\n  // txnData.gas = _correctGasAmount(gasEstimate);\n\n  const atomicMatchMethod = wyvernExchange.functions.atomicMatch_(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], txnData).then(res => {\n    console.log(res);\n  });\n  return {\n    atomicMatchMethod,\n    txnData\n  };\n}\n\n;\n\nasync function _getRequiredAmountForTakingSellOrder(sell, wyvernExchange) {\n  const currentPrice = await getCurrentPrice(sell, wyvernExchange);\n  const estimatedPrice = estimateCurrentPrice(sell);\n  const maxPrice = BigNumber.max(currentPrice, estimatedPrice); // TODO Why is this not always a big number?\n\n  sell.takerRelayerFee = BigNumber(sell.takerRelayerFee);\n  const feePercentage = sell.takerRelayerFee.div(INVERSE_BASIS_POINT);\n  const fee = feePercentage.times(maxPrice);\n  return fee.plus(maxPrice); // use .ceil()\n}\n\n;\nexport default performOrder;","map":{"version":3,"names":["WyvernProtocol","BigNumber","isValidAddress","ERC721Schema","WyvernContract","encodeSell","encodeBuy","getTimeParameters","NULL_BLOCK_HASH","INVERSE_BASIS_POINT","OPENSEA_FEE_RECIPIENT","MERKLE_VALIDATOR_MAINNET","performOrder","order","provider","accountAddress","recipientAddress","referrerAddress","console","info","wyvernExchange","isValid","validateOrder","matchingOrder","makeMatchingOrder","buy","sell","assignOrdersToSides","metadata","_getMetadata","_atomicMatch","sellValid","functions","validateOrder_","exchange","maker","taker","feeRecipient","target","staticTarget","paymentToken","toFixed","makerProtocolFee","takerProtocolFee","listingTime","expirationTime","salt","feeMethod","side","saleKind","howToCall","calldata","replacementPattern","staticExtradata","v","r","s","message","Error","code","toLowerCase","computeOrderParams","shouldValidate","schema","asset","undefined","times","quantity","makerRelayerFee","takerRelayerFee","makerReferrerFee","waitingForBestCounterOrder","NULL_ADDRESS","basePrice","extra","generatePseudoRandomSalt","isSellOrder","referrer","substr","_correctGasAmount","estimation","Math","ceil","value","_getRequiredAmountForTakingSellOrder","txnData","from","args","toString","atomicMatchMethod","atomicMatch_","then","res","log","currentPrice","getCurrentPrice","estimatedPrice","estimateCurrentPrice","maxPrice","max","feePercentage","div","fee","plus"],"sources":["/Users/romanrakhlin/Dropbox/Mac/Desktop/opensea-exploit/src/opensea-sdk/methods/PerformOrder.js"],"sourcesContent":["import { WyvernProtocol } from \"wyvern-js\";\nimport BigNumber from \"bignumber.js\";\nimport isValidAddress from \"ethereumjs-util\";\n\nimport { ERC721Schema } from \"../WyvernSchema\";\nimport { WyvernContract } from \"../contracts\";\nimport encodeSell from \"../helpers/EncodeSell\";\nimport encodeBuy from \"../helpers/EncodeBuy\";\nimport getTimeParameters from \"../helpers/GetTimeParameters\";\n\nimport { NULL_BLOCK_HASH, INVERSE_BASIS_POINT, OPENSEA_FEE_RECIPIENT, MERKLE_VALIDATOR_MAINNET } from \"../Constants\"\n\nconst performOrder = async ({\n    order,\n    provider,\n    accountAddress,\n    recipientAddress,\n    referrerAddress\n}) => {\n    console.info(`Account: ${accountAddress} | Recipient: ${recipientAddress} | Referrer: ${referrerAddress}`);\n\n    // check if valid order\n    const wyvernExchange = WyvernContract(provider);\n    const isValid = await validateOrder({ order, accountAddress, wyvernExchange });\n\n    const matchingOrder = makeMatchingOrder({\n        order,\n        accountAddress,\n        recipientAddress: recipientAddress\n    });\n\n    const { buy, sell } = assignOrdersToSides(order, matchingOrder);\n    const metadata = _getMetadata(order, referrerAddress);\n\n    return await _atomicMatch({\n        buy,\n        sell,\n        accountAddress,\n        wyvernExchange,\n        metadata\n    });\n};\n\nasync function validateOrder({ order, accountAddress, wyvernExchange }) {\n    // Check sell parameters\n    const sellValid = await wyvernExchange.functions.validateOrder_(\n        [\n            order.exchange,\n            order.maker,\n            order.taker,\n            order.feeRecipient,\n            order.target,\n            order.staticTarget,\n            order.paymentToken\n        ],\n        [\n            250.0.toFixed(),\n            0.0.toFixed(),\n            order.makerProtocolFee,\n            order.takerProtocolFee,\n            0.0.toFixed(),\n            0.0.toFixed(),\n            order.listingTime,\n            order.expirationTime,\n            order.salt,\n        ],\n        order.feeMethod,\n        order.side,\n        order.saleKind,\n        order.howToCall,\n        order.calldata,\n        order.replacementPattern,\n        order.staticExtradata,\n        order.v,\n        order.r,\n        order.s\n    );\n\n    if (!sellValid) {\n        // eslint-disable-next-line no-throw-literal\n        throw {\n            message: new Error(`Failed to validate sell order parameters. It looks like this listing is invalid.`),\n            code: \"InvalidOrder\",\n        };\n        // TODO: call order invalidate API\n    }\n\n    return sellValid;\n};\n\nfunction makeMatchingOrder({\n    order,\n    accountAddress,\n    recipientAddress\n}) {\n    accountAddress = accountAddress.toLowerCase();\n    recipientAddress = recipientAddress.toLowerCase();\n\n    const computeOrderParams = () => {\n        const shouldValidate = order.target === MERKLE_VALIDATOR_MAINNET;\n\n        if (\"asset\" in order.metadata) {\n            const schema = ERC721Schema; // currently supporting ERC721 only\n            return order.side == 0 ? encodeSell(\n                schema,\n                order.metadata.asset,\n                recipientAddress,\n                shouldValidate ? order.target : undefined\n            ) : encodeBuy(\n                schema,\n                order.metadata.asset,\n                recipientAddress,\n                shouldValidate ? order.target : undefined\n            );\n        } else {\n            throw new Error(\"Invalid order metadata\");\n        }\n    };\n\n    const { target, calldata, replacementPattern } = computeOrderParams();\n    const times = getTimeParameters(0);\n    \n    // Compat for matching buy orders that have fee recipient still on them\n    const feeRecipient = OPENSEA_FEE_RECIPIENT; // Maybe NULLADDRESS\n    const matchingOrder = {\n        exchange: order.exchange,\n        maker: accountAddress,\n        taker: order.maker,\n        quantity: order.quantity,\n        makerRelayerFee: order.makerRelayerFee,\n        takerRelayerFee: order.takerRelayerFee,\n        makerProtocolFee: order.makerProtocolFee,\n        takerProtocolFee: order.takerProtocolFee,\n        makerReferrerFee: order.makerReferrerFee,\n        waitingForBestCounterOrder: false,\n        feeMethod: order.feeMethod,\n        feeRecipient,\n        side: (order.side + 1) % 2,\n        saleKind: 0, // 0 fixed price 1 ducch aucion\n        target,\n        howToCall: order.howToCall,\n        calldata,\n        replacementPattern,\n        staticTarget: WyvernProtocol.NULL_ADDRESS,\n        staticExtradata: \"0x\",\n        paymentToken: order.paymentToken,\n        basePrice: order.basePrice,\n        extra: BigNumber(0),\n        listingTime: times.listingTime,\n        expirationTime: times.expirationTime,\n        salt: WyvernProtocol.generatePseudoRandomSalt(),\n        metadata: order.metadata,\n    };\n\n    return matchingOrder;\n};\n\nfunction assignOrdersToSides(order, matchingOrder) {\n    const isSellOrder = order.side == 1;\n\n    let buy;\n    let sell;\n\n    if (!isSellOrder) {\n        buy = order;\n        sell = {\n            ...matchingOrder,\n            v: buy.v,\n            r: buy.r,\n            s: buy.s,\n        };\n    } else {\n        sell = order;\n        buy = {\n            ...matchingOrder,\n            v: sell.v,\n            r: sell.r,\n            s: sell.s,\n        };\n    }\n\n    return { buy, sell };\n};\n\nconst _getMetadata = (order, referrerAddress) => {\n    const referrer = referrerAddress || order.metadata.referrerAddress;\n    if (referrer && isValidAddress(referrer)) {\n        return `0x000000000000000000000000${referrer.substr(2)}`;\n    }\n    return undefined;\n};\n\nconst _correctGasAmount = (estimation) => {\n    return Math.ceil(estimation * 1.01);\n};\n\nasync function _atomicMatch({\n    buy,\n    sell,\n    accountAddress,\n    wyvernExchange,\n    metadata = NULL_BLOCK_HASH,\n}) {\n    let value;\n\n    if (buy.paymentToken == WyvernProtocol.NULL_ADDRESS) {\n        value = await _getRequiredAmountForTakingSellOrder(sell, wyvernExchange);\n    }\n\n    const txnData = { from: accountAddress, value };\n\n    const args = [\n        [\n            buy.exchange,\n            buy.maker,\n            buy.taker,\n            buy.feeRecipient,\n            buy.target,\n            buy.staticTarget,\n            buy.paymentToken,\n            sell.exchange,\n            sell.maker,\n            sell.taker,\n            sell.feeRecipient,\n            sell.target,\n            sell.staticTarget,\n            sell.paymentToken,\n        ],\n        [\n            250.0.toString(),\n            0.0.toString(),\n            buy.makerProtocolFee.toString(),\n            buy.takerProtocolFee.toString(),\n            0.0.toString(),\n            buy.extra.toString(),\n            buy.listingTime.toString(),\n            buy.expirationTime.toString(),\n            buy.salt.toString(),\n            250.0.toString(),\n            0.0.toString(),\n            sell.makerProtocolFee.toString(),\n            sell.takerProtocolFee.toString(),\n            0.0.toString(),\n            0.0.toString(),\n            sell.listingTime.toString(),\n            sell.expirationTime.toString(),\n            sell.salt.toString(),\n        ],\n        [\n            buy.feeMethod,\n            buy.side,\n            buy.saleKind,\n            buy.howToCall,\n            sell.feeMethod,\n            sell.side,\n            sell.saleKind,\n            sell.howToCall,\n        ],\n        buy.calldata,\n        sell.calldata,\n        buy.replacementPattern,\n        sell.replacementPattern,\n        buy.staticExtradata,\n        sell.staticExtradata,\n        [buy.v || 0, sell.v || 0],\n        [\n            buy.r || NULL_BLOCK_HASH,\n            buy.s || NULL_BLOCK_HASH,\n            sell.r || NULL_BLOCK_HASH,\n            sell.s || NULL_BLOCK_HASH,\n            metadata,\n        ]\n    ];\n\n    // const gasEstimate = await wyvernExchange.functions.estimateGasAsync(txnData);\n    // txnData.gas = _correctGasAmount(gasEstimate);\n\n    const atomicMatchMethod = wyvernExchange.functions.atomicMatch_(\n        args[0],\n        args[1],\n        args[2],\n        args[3],\n        args[4],\n        args[5],\n        args[6],\n        args[7],\n        args[8],\n        args[9],\n        args[10],\n        txnData\n    ).then(res => {\n        console.log(res)\n    });\n\n    return { atomicMatchMethod, txnData };\n};\n\nasync function _getRequiredAmountForTakingSellOrder(sell, wyvernExchange) {\n    const currentPrice = await getCurrentPrice(sell, wyvernExchange);\n    const estimatedPrice = estimateCurrentPrice(sell);\n\n    const maxPrice = BigNumber.max(currentPrice, estimatedPrice);\n\n    // TODO Why is this not always a big number?\n    sell.takerRelayerFee = BigNumber(sell.takerRelayerFee);\n    const feePercentage = sell.takerRelayerFee.div(INVERSE_BASIS_POINT);\n    const fee = feePercentage.times(maxPrice);\n\n    return fee.plus(maxPrice); // use .ceil()\n};\n\nexport default performOrder;"],"mappings":"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"},"metadata":{},"sourceType":"module"}