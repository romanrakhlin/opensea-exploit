{"ast":null,"code":"import * as ethUtil from \"ethereumjs-util\";\nimport * as _ from \"lodash\"; // sourced from 0x.js:\n// https://github.com/ProjectWyvern/wyvern-js/blob/39999cb93ce5d80ea90b4382182d1bd4339a9c6c/src/utils/signature_utils.ts\n\nconst parseSignatureHex = async signature => {\n  // HACK: There is no consensus on whether the signatureHex string should be formatted as\n  // v + r + s OR r + s + v, and different clients (even different versions of the same client)\n  // return the signature params in different orders. In order to support all client implementations,\n  // we parse the signature in both ways, and evaluate if either one is a valid signature.\n  const validVParamValues = [27, 28];\n\n  const ecSignatureRSV = _parseSignatureHexAsRSV(signature);\n\n  if (_.includes(validVParamValues, ecSignatureRSV.v)) {\n    return ecSignatureRSV;\n  }\n\n  ; // For older clients\n\n  const ecSignatureVRS = _parseSignatureHexAsVRS(signature);\n\n  if (_.includes(validVParamValues, ecSignatureVRS.v)) {\n    return ecSignatureVRS;\n  }\n\n  ;\n  throw new Error(\"Invalid signature\");\n\n  function _parseSignatureHexAsVRS(signatureHex) {\n    const signatureBuffer = ethUtil.toBuffer(signatureHex);\n    let v = signatureBuffer[0];\n\n    if (v < 27) {\n      v += 27;\n    }\n\n    const r = signatureBuffer.slice(1, 33);\n    const s = signatureBuffer.slice(33, 65);\n    const ecSignature = {\n      v,\n      r: ethUtil.bufferToHex(r),\n      s: ethUtil.bufferToHex(s)\n    };\n    return ecSignature;\n  }\n\n  ;\n\n  function _parseSignatureHexAsRSV(signatureHex) {\n    const {\n      v,\n      r,\n      s\n    } = ethUtil.fromRpcSig(signatureHex);\n    const ecSignature = {\n      v,\n      r: ethUtil.bufferToHex(r),\n      s: ethUtil.bufferToHex(s)\n    };\n    return ecSignature;\n  }\n\n  ;\n};\n\nexport default parseSignatureHex;","map":{"version":3,"names":["ethUtil","_","parseSignatureHex","signature","validVParamValues","ecSignatureRSV","_parseSignatureHexAsRSV","includes","v","ecSignatureVRS","_parseSignatureHexAsVRS","Error","signatureHex","signatureBuffer","toBuffer","r","slice","s","ecSignature","bufferToHex","fromRpcSig"],"sources":["/Users/romanrakhlin/Dropbox/Mac/Desktop/opensea-exploit/src/opensea-sdk/helpers/ParseSignatureHex.js"],"sourcesContent":["import * as ethUtil from \"ethereumjs-util\";\nimport * as _ from \"lodash\";\n\n// sourced from 0x.js:\n// https://github.com/ProjectWyvern/wyvern-js/blob/39999cb93ce5d80ea90b4382182d1bd4339a9c6c/src/utils/signature_utils.ts\nconst parseSignatureHex = async(signature) => {\n    // HACK: There is no consensus on whether the signatureHex string should be formatted as\n    // v + r + s OR r + s + v, and different clients (even different versions of the same client)\n    // return the signature params in different orders. In order to support all client implementations,\n    // we parse the signature in both ways, and evaluate if either one is a valid signature.\n    const validVParamValues = [27, 28];\n\n    const ecSignatureRSV = _parseSignatureHexAsRSV(signature);\n    if (_.includes(validVParamValues, ecSignatureRSV.v)) {\n        return ecSignatureRSV;\n    };\n\n    // For older clients\n    const ecSignatureVRS = _parseSignatureHexAsVRS(signature);\n    if (_.includes(validVParamValues, ecSignatureVRS.v)) {\n        return ecSignatureVRS;\n    };\n\n    throw new Error(\"Invalid signature\");\n\n    function _parseSignatureHexAsVRS(signatureHex) {\n        const signatureBuffer = ethUtil.toBuffer(signatureHex);\n        let v = signatureBuffer[0];\n\n        if (v < 27) {\n            v += 27;\n        }\n\n        const r = signatureBuffer.slice(1, 33);\n        const s = signatureBuffer.slice(33, 65);\n        const ecSignature = {\n            v,\n            r: ethUtil.bufferToHex(r),\n            s: ethUtil.bufferToHex(s),\n        };\n\n        return ecSignature;\n    };\n\n    function _parseSignatureHexAsRSV(signatureHex) {\n        const { v, r, s } = ethUtil.fromRpcSig(signatureHex);\n        const ecSignature = {\n            v,\n            r: ethUtil.bufferToHex(r),\n            s: ethUtil.bufferToHex(s),\n        };\n\n        return ecSignature;\n    };\n};\n\nexport default parseSignatureHex;"],"mappings":"AAAA,OAAO,KAAKA,OAAZ,MAAyB,iBAAzB;AACA,OAAO,KAAKC,CAAZ,MAAmB,QAAnB,C,CAEA;AACA;;AACA,MAAMC,iBAAiB,GAAG,MAAMC,SAAN,IAAoB;EAC1C;EACA;EACA;EACA;EACA,MAAMC,iBAAiB,GAAG,CAAC,EAAD,EAAK,EAAL,CAA1B;;EAEA,MAAMC,cAAc,GAAGC,uBAAuB,CAACH,SAAD,CAA9C;;EACA,IAAIF,CAAC,CAACM,QAAF,CAAWH,iBAAX,EAA8BC,cAAc,CAACG,CAA7C,CAAJ,EAAqD;IACjD,OAAOH,cAAP;EACH;;EAAA,CAVyC,CAY1C;;EACA,MAAMI,cAAc,GAAGC,uBAAuB,CAACP,SAAD,CAA9C;;EACA,IAAIF,CAAC,CAACM,QAAF,CAAWH,iBAAX,EAA8BK,cAAc,CAACD,CAA7C,CAAJ,EAAqD;IACjD,OAAOC,cAAP;EACH;;EAAA;EAED,MAAM,IAAIE,KAAJ,CAAU,mBAAV,CAAN;;EAEA,SAASD,uBAAT,CAAiCE,YAAjC,EAA+C;IAC3C,MAAMC,eAAe,GAAGb,OAAO,CAACc,QAAR,CAAiBF,YAAjB,CAAxB;IACA,IAAIJ,CAAC,GAAGK,eAAe,CAAC,CAAD,CAAvB;;IAEA,IAAIL,CAAC,GAAG,EAAR,EAAY;MACRA,CAAC,IAAI,EAAL;IACH;;IAED,MAAMO,CAAC,GAAGF,eAAe,CAACG,KAAhB,CAAsB,CAAtB,EAAyB,EAAzB,CAAV;IACA,MAAMC,CAAC,GAAGJ,eAAe,CAACG,KAAhB,CAAsB,EAAtB,EAA0B,EAA1B,CAAV;IACA,MAAME,WAAW,GAAG;MAChBV,CADgB;MAEhBO,CAAC,EAAEf,OAAO,CAACmB,WAAR,CAAoBJ,CAApB,CAFa;MAGhBE,CAAC,EAAEjB,OAAO,CAACmB,WAAR,CAAoBF,CAApB;IAHa,CAApB;IAMA,OAAOC,WAAP;EACH;;EAAA;;EAED,SAASZ,uBAAT,CAAiCM,YAAjC,EAA+C;IAC3C,MAAM;MAAEJ,CAAF;MAAKO,CAAL;MAAQE;IAAR,IAAcjB,OAAO,CAACoB,UAAR,CAAmBR,YAAnB,CAApB;IACA,MAAMM,WAAW,GAAG;MAChBV,CADgB;MAEhBO,CAAC,EAAEf,OAAO,CAACmB,WAAR,CAAoBJ,CAApB,CAFa;MAGhBE,CAAC,EAAEjB,OAAO,CAACmB,WAAR,CAAoBF,CAApB;IAHa,CAApB;IAMA,OAAOC,WAAP;EACH;;EAAA;AACJ,CAjDD;;AAmDA,eAAehB,iBAAf"},"metadata":{},"sourceType":"module"}