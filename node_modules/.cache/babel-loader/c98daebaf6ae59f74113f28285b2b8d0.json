{"ast":null,"code":"import { WyvernContract } from \"../contracts\";\nimport encodeSell from \"../helpers/EncodeSell\";\nimport encodeBuy from \"../helpers/EncodeBuy\";\n\nconst performOrder = async _ref => {\n  let {\n    order,\n    provider,\n    accountAddress,\n    recipientAddress,\n    referrerAddress\n  } = _ref;\n  console.info(`Account: ${accountAddress} | Recipient: ${recipientAddress} | Referrer: ${referrerAddress}`); // check if valid order\n\n  const wyvernExchange = WyvernContract(provider);\n  const isValid = await validateOrder({\n    order,\n    accountAddress,\n    wyvernExchange\n  });\n  const matchingOrder = makeMatchingOrder({\n    order,\n    accountAddress,\n    recipientAddress: recipientAddress\n  });\n  const {\n    buy,\n    sell\n  } = assignOrdersToSides(order, matchingOrder);\n\n  const metadata = _getMetadata(order, referrerAddress);\n\n  return await _atomicMatch({\n    buy,\n    sell,\n    accountAddress,\n    wyvernExchange,\n    metadata\n  });\n};\n\nasync function validateOrder(_ref2) {\n  let {\n    order,\n    accountAddress,\n    wyvernExchange\n  } = _ref2;\n  // Check sell parameters\n  const sellValid = await wyvernExchange.functions.validateOrder_([order.exchange, order.maker, order.taker, order.feeRecipient, order.target, order.staticTarget, order.paymentToken], [250.0.toFixed(), 0.0.toFixed(), order.makerProtocolFee, order.takerProtocolFee, 0.0.toFixed(), 0.0.toFixed(), order.listingTime, order.expirationTime, order.salt], order.feeMethod, order.side, order.saleKind, order.howToCall, order.calldata, order.replacementPattern, order.staticExtradata, order.v, order.r, order.s);\n\n  if (!sellValid) {\n    // eslint-disable-next-line no-throw-literal\n    throw {\n      message: new Error(`Failed to validate sell order parameters. It looks like this listing is invalid.`),\n      code: \"InvalidOrder\"\n    }; // TODO: call order invalidate API\n  }\n\n  return sellValid;\n}\n\n;\n\nfunction makeMatchingOrder(_ref3) {\n  let {\n    order,\n    accountAddress,\n    recipientAddress\n  } = _ref3;\n  accountAddress = accountAddress.toLowerCase();\n  recipientAddress = recipientAddress.toLowerCase();\n\n  const computeOrderParams = () => {\n    const shouldValidate = order.target === MERKLE_VALIDATOR_MAINNET;\n\n    if (\"asset\" in order.metadata) {\n      const schema = ERC721Schema; // currently supporting ERC721 only\n\n      return order.side == 0 ? encodeSell(schema, order.metadata.asset, recipientAddress, shouldValidate ? order.target : undefined) : encodeBuy(schema, order.metadata.asset, recipientAddress, shouldValidate ? order.target : undefined);\n    } else {\n      throw new Error(\"Invalid order metadata\");\n    }\n  };\n\n  const {\n    target,\n    calldata,\n    replacementPattern\n  } = computeOrderParams();\n  const times = getTimeParameters(0); // Compat for matching buy orders that have fee recipient still on them\n\n  const feeRecipient = OPENSEA_FEE_RECIPIENT; // Maybe NULLADDRESS\n\n  const matchingOrder = {\n    exchange: order.exchange,\n    maker: accountAddress,\n    taker: order.maker,\n    quantity: order.quantity,\n    makerRelayerFee: order.makerRelayerFee,\n    takerRelayerFee: order.takerRelayerFee,\n    makerProtocolFee: order.makerProtocolFee,\n    takerProtocolFee: order.takerProtocolFee,\n    makerReferrerFee: order.makerReferrerFee,\n    waitingForBestCounterOrder: false,\n    feeMethod: order.feeMethod,\n    feeRecipient,\n    side: (order.side + 1) % 2,\n    saleKind: 0,\n    // 0 fixed price 1 ducch aucion\n    target,\n    howToCall: order.howToCall,\n    calldata,\n    replacementPattern,\n    staticTarget: WyvernProtocol.NULL_ADDRESS,\n    staticExtradata: \"0x\",\n    paymentToken: order.paymentToken,\n    basePrice: order.basePrice,\n    extra: BigNumber(0),\n    listingTime: times.listingTime,\n    expirationTime: times.expirationTime,\n    salt: WyvernProtocol.generatePseudoRandomSalt(),\n    metadata: order.metadata\n  };\n  return matchingOrder;\n}\n\n;\nexport default performOrder;","map":{"version":3,"names":["WyvernContract","encodeSell","encodeBuy","performOrder","order","provider","accountAddress","recipientAddress","referrerAddress","console","info","wyvernExchange","isValid","validateOrder","matchingOrder","makeMatchingOrder","buy","sell","assignOrdersToSides","metadata","_getMetadata","_atomicMatch","sellValid","functions","validateOrder_","exchange","maker","taker","feeRecipient","target","staticTarget","paymentToken","toFixed","makerProtocolFee","takerProtocolFee","listingTime","expirationTime","salt","feeMethod","side","saleKind","howToCall","calldata","replacementPattern","staticExtradata","v","r","s","message","Error","code","toLowerCase","computeOrderParams","shouldValidate","MERKLE_VALIDATOR_MAINNET","schema","ERC721Schema","asset","undefined","times","getTimeParameters","OPENSEA_FEE_RECIPIENT","quantity","makerRelayerFee","takerRelayerFee","makerReferrerFee","waitingForBestCounterOrder","WyvernProtocol","NULL_ADDRESS","basePrice","extra","BigNumber","generatePseudoRandomSalt"],"sources":["/Users/romanrakhlin/Dropbox/Mac/Desktop/opensea-exploit/src/opensea-sdk/methods/PerformOrder.js"],"sourcesContent":["import { WyvernContract } from \"../contracts\";\n\nimport encodeSell from \"../helpers/EncodeSell\";\nimport encodeBuy from \"../helpers/EncodeBuy\";\n\nconst performOrder = async ({\n    order,\n    provider,\n    accountAddress,\n    recipientAddress,\n    referrerAddress\n}) => {\n    console.info(`Account: ${accountAddress} | Recipient: ${recipientAddress} | Referrer: ${referrerAddress}`);\n\n    // check if valid order\n    const wyvernExchange = WyvernContract(provider);\n    const isValid = await validateOrder({ order, accountAddress, wyvernExchange });\n\n    const matchingOrder = makeMatchingOrder({\n        order,\n        accountAddress,\n        recipientAddress: recipientAddress\n    });\n\n    const { buy, sell } = assignOrdersToSides(order, matchingOrder);\n    const metadata = _getMetadata(order, referrerAddress);\n\n    return await _atomicMatch({\n        buy,\n        sell,\n        accountAddress,\n        wyvernExchange,\n        metadata\n    });\n};\n\nasync function validateOrder({ order, accountAddress, wyvernExchange }) {\n    // Check sell parameters\n    const sellValid = await wyvernExchange.functions.validateOrder_(\n        [\n            order.exchange,\n            order.maker,\n            order.taker,\n            order.feeRecipient,\n            order.target,\n            order.staticTarget,\n            order.paymentToken\n        ],\n        [\n            250.0.toFixed(),\n            0.0.toFixed(),\n            order.makerProtocolFee,\n            order.takerProtocolFee,\n            0.0.toFixed(),\n            0.0.toFixed(),\n            order.listingTime,\n            order.expirationTime,\n            order.salt,\n        ],\n        order.feeMethod,\n        order.side,\n        order.saleKind,\n        order.howToCall,\n        order.calldata,\n        order.replacementPattern,\n        order.staticExtradata,\n        order.v,\n        order.r,\n        order.s\n    );\n\n    if (!sellValid) {\n        // eslint-disable-next-line no-throw-literal\n        throw {\n            message: new Error(`Failed to validate sell order parameters. It looks like this listing is invalid.`),\n            code: \"InvalidOrder\",\n        };\n        // TODO: call order invalidate API\n    }\n\n    return sellValid;\n};\n\nfunction makeMatchingOrder({\n    order,\n    accountAddress,\n    recipientAddress\n}) {\n    accountAddress = accountAddress.toLowerCase();\n    recipientAddress = recipientAddress.toLowerCase();\n\n    const computeOrderParams = () => {\n        const shouldValidate = order.target === MERKLE_VALIDATOR_MAINNET;\n\n        if (\"asset\" in order.metadata) {\n            const schema = ERC721Schema; // currently supporting ERC721 only\n            return order.side == 0 ? encodeSell(\n                schema,\n                order.metadata.asset,\n                recipientAddress,\n                shouldValidate ? order.target : undefined\n            ) : encodeBuy(\n                schema,\n                order.metadata.asset,\n                recipientAddress,\n                shouldValidate ? order.target : undefined\n            );\n        } else {\n            throw new Error(\"Invalid order metadata\");\n        }\n    };\n\n    const { target, calldata, replacementPattern } = computeOrderParams();\n    const times = getTimeParameters(0);\n    \n    // Compat for matching buy orders that have fee recipient still on them\n    const feeRecipient = OPENSEA_FEE_RECIPIENT; // Maybe NULLADDRESS\n    const matchingOrder = {\n        exchange: order.exchange,\n        maker: accountAddress,\n        taker: order.maker,\n        quantity: order.quantity,\n        makerRelayerFee: order.makerRelayerFee,\n        takerRelayerFee: order.takerRelayerFee,\n        makerProtocolFee: order.makerProtocolFee,\n        takerProtocolFee: order.takerProtocolFee,\n        makerReferrerFee: order.makerReferrerFee,\n        waitingForBestCounterOrder: false,\n        feeMethod: order.feeMethod,\n        feeRecipient,\n        side: (order.side + 1) % 2,\n        saleKind: 0, // 0 fixed price 1 ducch aucion\n        target,\n        howToCall: order.howToCall,\n        calldata,\n        replacementPattern,\n        staticTarget: WyvernProtocol.NULL_ADDRESS,\n        staticExtradata: \"0x\",\n        paymentToken: order.paymentToken,\n        basePrice: order.basePrice,\n        extra: BigNumber(0),\n        listingTime: times.listingTime,\n        expirationTime: times.expirationTime,\n        salt: WyvernProtocol.generatePseudoRandomSalt(),\n        metadata: order.metadata,\n    };\n\n    return matchingOrder;\n};\n\nexport default performOrder;"],"mappings":"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"},"metadata":{},"sourceType":"module"}