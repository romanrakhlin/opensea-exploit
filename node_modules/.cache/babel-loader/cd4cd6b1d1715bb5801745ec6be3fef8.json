{"ast":null,"code":"// Wyvern\nimport WyvernProtocol from \"wyvern-js\";\nimport { HowToCall, Network } from \"wyvern-js/lib/types\";\nimport { ERC721Schema } from \"./WyvernSchema\"; // Ethereum\n\nimport * as ethABI from \"ethereumjs-abi\";\nimport * as ethUtil from \"ethereumjs-util\";\nimport isValidAddress from \"ethereumjs-util\";\nimport { parseEther } from \"@ethersproject/units\";\nimport BigNumber from \"bignumber.js\"; // Other\n\nimport axios from \"axios\";\nimport * as _ from \"lodash\"; // Constants\n\nimport { OPENSEA_URL, X_API_KEY } from \"./Constants\"; // Contracts\n\nimport { WyvernContract, WYVERN_CONTRACT } from \"./Contracts\";\nconst MIN_EXPIRATION_SECONDS = 10;\nconst ORDER_MATCHING_LATENCY_SECONDS = 60 * 60 * 24 * 7;\nconst NULL_ADDRESS = WyvernProtocol.NULL_ADDRESS;\nconst OPENSEA_FEE_RECIPIENT = \"0x5b3256965e7c3cf26e11fcaf296dfc8807c01073\";\nconst NULL_BLOCK_HASH = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\nconst INVERSE_BASIS_POINT = 10000;\nconst DEFAULT_BUYER_FEE_BASIS_POINTS = 0;\nconst DEFAULT_SELLER_FEE_BASIS_POINTS = 250;\nconst OPENSEA_SELLER_BOUNTY_BASIS_POINTS = 250; // default 1 % we are using 2.5%\n\nconst DEFAULT_MAX_BOUNTY = DEFAULT_SELLER_FEE_BASIS_POINTS;\nconst STATIC_CALL_TX_ORIGIN_ADDRESS = \"0xbff6ade67e3717101dd8d0a7f3de1bf6623a2ba8\";\nconst MERKLE_VALIDATOR_MAINNET = \"0xbaf2127b49fc93cbca6269fade0f7f31df4c88a7\"; // MAIN FUNCTIONALITY\n\nconst mainnetWyvernConfigByNetwork = {\n  wyvernExchangeContractAddress: \"0x7be8076f4ea4a4ad08075c2508e481d6c946d12b\",\n  wyvernProxyRegistryContractAddress: \"0xa5409ec958c83c3f309868babaca7c86dcb077c1\",\n  wyvernTokenTransferProxyContractAddress: \"0xe5c783ee536cf5e63e792988335c4255169be4e1\"\n};\nconst OrderTypesEIP712 = {\n  EIP712Domain: [{\n    name: \"name\",\n    type: \"string\"\n  }, {\n    name: \"version\",\n    type: \"string\"\n  }, {\n    name: \"chainId\",\n    type: \"uint256\"\n  }, {\n    name: \"verifyingContract\",\n    type: \"address\"\n  }],\n  Order: [{\n    name: \"maker\",\n    type: \"address\"\n  }, {\n    name: \"exchange\",\n    type: \"address\"\n  }, {\n    name: \"taker\",\n    type: \"address\"\n  }, {\n    name: \"makerRelayerFee\",\n    type: \"uint256\"\n  }, {\n    name: \"takerRelayerFee\",\n    type: \"uint256\"\n  }, {\n    name: \"makerProtocolFee\",\n    type: \"uint256\"\n  }, {\n    name: \"takerProtocolFee\",\n    type: \"uint256\"\n  }, {\n    name: \"feeRecipient\",\n    type: \"address\"\n  }, {\n    name: \"feeMethod\",\n    type: \"uint8\"\n  }, {\n    name: \"side\",\n    type: \"uint8\"\n  }, {\n    name: \"saleKind\",\n    type: \"uint8\"\n  }, {\n    name: \"target\",\n    type: \"address\"\n  }, {\n    name: \"howToCall\",\n    type: \"uint8\"\n  }, {\n    name: \"calldata\",\n    type: \"bytes\"\n  }, {\n    name: \"replacementPattern\",\n    type: \"bytes\"\n  }, {\n    name: \"staticTarget\",\n    type: \"address\"\n  }, {\n    name: \"staticExtradata\",\n    type: \"bytes\"\n  }, {\n    name: \"paymentToken\",\n    type: \"address\"\n  }, {\n    name: \"basePrice\",\n    type: \"uint256\"\n  }, {\n    name: \"extra\",\n    type: \"uint256\"\n  }, {\n    name: \"listingTime\",\n    type: \"uint256\"\n  }, {\n    name: \"expirationTime\",\n    type: \"uint256\"\n  }, {\n    name: \"salt\",\n    type: \"uint256\"\n  }, {\n    name: \"nonce\",\n    type: \"uint256\"\n  }]\n};\nexport const EIP_712_WYVERN_DOMAIN_NAME = \"Wyvern Exchange Contract\";\nexport const EIP_712_WYVERN_DOMAIN_VERSION = \"2.3\";\n\nfunction validateAndFormatWalletAddress(address) {\n  return address.toLowerCase();\n}\n\nexport const tokenFromJSON = token => {\n  const fromJSON = {\n    name: token.name,\n    symbol: token.symbol,\n    decimals: token.decimals,\n    address: token.address,\n    imageUrl: token.image_url,\n    ethPrice: token.eth_price,\n    usdPrice: token.usd_price\n  };\n  return fromJSON;\n};\nexport const merkleValidatorByNetwork = {\n  main: MERKLE_VALIDATOR_MAINNET,\n  rinkeby: MERKLE_VALIDATOR_RINKEBY\n};\nexport const orderFromJSON = order => {\n  const createdDate = new Date(`${order.created_date}Z`);\n  const fromJSON = {\n    hash: order.order_hash || order.hash,\n    cancelledOrFinalized: order.cancelled || order.finalized,\n    markedInvalid: order.marked_invalid,\n    metadata: order.metadata,\n    quantity: new BigNumber(order.quantity || 1),\n    exchange: order.exchange,\n    makerAccount: order.maker,\n    takerAccount: order.taker,\n    // Use string address to conform to Wyvern Order schema\n    maker: order.maker.address,\n    taker: order.taker.address,\n    makerRelayerFee: new BigNumber(order.maker_relayer_fee),\n    takerRelayerFee: new BigNumber(order.taker_relayer_fee),\n    makerProtocolFee: new BigNumber(order.maker_protocol_fee),\n    takerProtocolFee: new BigNumber(order.taker_protocol_fee),\n    makerReferrerFee: new BigNumber(order.maker_referrer_fee || 0),\n    waitingForBestCounterOrder: order.fee_recipient.address == NULL_ADDRESS,\n    feeMethod: order.fee_method,\n    feeRecipientAccount: order.fee_recipient,\n    feeRecipient: order.fee_recipient.address,\n    side: order.side,\n    saleKind: order.sale_kind,\n    target: order.target,\n    howToCall: order.how_to_call,\n    calldata: order.calldata,\n    replacementPattern: order.replacement_pattern,\n    staticTarget: order.static_target,\n    staticExtradata: order.static_extradata,\n    paymentToken: order.payment_token,\n    basePrice: new BigNumber(order.base_price),\n    extra: new BigNumber(order.extra),\n    currentBounty: new BigNumber(order.current_bounty || 0),\n    currentPrice: new BigNumber(order.current_price || 0),\n    createdTime: new BigNumber(Math.round(createdDate.getTime() / 1000)),\n    listingTime: new BigNumber(order.listing_time),\n    expirationTime: new BigNumber(order.expiration_time),\n    salt: new BigNumber(order.salt),\n    v: parseInt(order.v),\n    r: order.r,\n    s: order.s,\n    paymentTokenContract: order.payment_token_contract ? tokenFromJSON(order.payment_token_contract) : undefined,\n    asset: order.asset,\n    assetBundle: order.asset_bundle\n  }; // Use client-side price calc, to account for buyer fee (not added by server) and latency\n\n  fromJSON.currentPrice = estimateCurrentPrice(fromJSON);\n  return fromJSON;\n};\nexport const orderFromGolomJSON = order => {\n  const createdDate = new Date(`${order.created}`);\n  const orderData = order.data;\n  const metadata = {\n    asset: {\n      address: order.contract_address,\n      id: order.token_id\n    },\n    schema: \"ERC721\" // currently supporting erc721 only\n\n  };\n  const fromJSON = {\n    hash: order.hex,\n    cancelledOrFinalized: false,\n    markedInvalid: order.valid,\n    metadata,\n    quantity: new BigNumber(1),\n    exchange: orderData.exchange,\n    // Use string address to conform to Wyvern Order schema\n    maker: orderData.maker,\n    taker: orderData.taker,\n    makerRelayerFee: new BigNumber(orderData.makerRelayerFee),\n    takerRelayerFee: new BigNumber(orderData.takerRelayerFee),\n    makerProtocolFee: new BigNumber(orderData.makerProtocolFee),\n    takerProtocolFee: new BigNumber(orderData.takerProtocolFee),\n    makerReferrerFee: new BigNumber(0),\n    // need to explore this field more\n    waitingForBestCounterOrder: orderData.feeRecipient == NULL_ADDRESS,\n    feeMethod: orderData.feeMethod,\n    feeRecipient: orderData.feeRecipient,\n    side: orderData.side,\n    saleKind: orderData.saleKind,\n    target: orderData.target,\n    howToCall: orderData.howToCall,\n    calldata: orderData.calldata,\n    replacementPattern: orderData.replacementPattern,\n    staticTarget: orderData.staticTarget,\n    staticExtradata: orderData.staticExtradata,\n    paymentToken: orderData.paymentToken,\n    basePrice: new BigNumber(orderData.basePrice),\n    extra: new BigNumber(orderData.extra),\n    currentBounty: new BigNumber(0),\n    currentPrice: new BigNumber(0),\n    createdTime: new BigNumber(Math.round(createdDate.getTime() / 1000)),\n    listingTime: new BigNumber(orderData.listingTime),\n    expirationTime: new BigNumber(orderData.expirationTime),\n    salt: new BigNumber(orderData.salt),\n    v: parseInt(orderData.v),\n    r: orderData.r,\n    s: orderData.s,\n    asset: order.asset\n  }; // Use client-side price calc, to account for buyer fee (not added by server) and latency\n\n  fromJSON.currentPrice = estimateCurrentPrice(fromJSON);\n  return fromJSON;\n};\n\nconst _getTimeParameters = function (expirationTimestamp, listingTimestamp) {\n  let waitingForBestCounterOrder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  // Validation\n  const minExpirationTimestamp = Math.round(Date.now() / 1000 + MIN_EXPIRATION_SECONDS);\n  const minListingTimestamp = Math.round(Date.now() / 1000);\n\n  if (expirationTimestamp != 0 && expirationTimestamp < minExpirationTimestamp) {\n    throw new Error(`Expiration time must be at least ${MIN_EXPIRATION_SECONDS} seconds from now, or zero (non-expiring).`);\n  }\n\n  if (listingTimestamp && listingTimestamp < minListingTimestamp) {\n    throw new Error(\"Listing time cannot be in the past.\");\n  }\n\n  if (listingTimestamp && expirationTimestamp != 0 && listingTimestamp >= expirationTimestamp) {\n    throw new Error(\"Listing time must be before the expiration time.\");\n  }\n\n  if (waitingForBestCounterOrder && expirationTimestamp == 0) {\n    throw new Error(\"English auctions must have an expiration time.\");\n  }\n\n  if (waitingForBestCounterOrder && listingTimestamp) {\n    throw new Error(`Cannot schedule an English auction for the future.`);\n  }\n\n  if (parseInt(expirationTimestamp.toString()) != expirationTimestamp) {\n    throw new Error(`Expiration timestamp must be a whole number of seconds`);\n  }\n\n  if (waitingForBestCounterOrder) {\n    listingTimestamp = expirationTimestamp; // Expire one week from now, to ensure server can match it\n    // Later, this will expire closer to the listingTime\n\n    expirationTimestamp = expirationTimestamp + ORDER_MATCHING_LATENCY_SECONDS;\n  } else {\n    // Small offset to account for latency\n    listingTimestamp = listingTimestamp || Math.round(Date.now() / 1000 - 100);\n  }\n\n  return {\n    listingTime: BigNumber(listingTimestamp),\n    expirationTime: BigNumber(expirationTimestamp)\n  };\n};\n\nexport const encodeCall = (abi, parameters) => {\n  const inputTypes = abi.inputs.map(i => i.type);\n  let id = ethABI.methodID(abi.name, inputTypes);\n  let encode = ethABI.rawEncode(inputTypes.slice(0, 3), parameters.slice(0, 3));\n  return \"0x\" + Buffer.concat([id, encode]).toString(\"hex\");\n};\n\nconst encodeDefaultCall = (abi, address) => {\n  const parameters = abi.inputs.map(input => {\n    switch (input.kind) {\n      case \"replaceable\":\n        return WyvernProtocol.generateDefaultValue(input.type);\n\n      case \"owner\":\n        return address;\n\n      case \"asset\":\n      default:\n        return input.value;\n    }\n  });\n  return encodeCall(abi, parameters);\n};\n\nconst encodeSell = (schema, asset, address, validatorAddress) => {\n  const transfer = validatorAddress && schema.functions.checkAndTransfer ? schema.functions.checkAndTransfer(asset, validatorAddress) : schema.functions.transfer(asset); //   const transfer = schema.functions.transfer(asset);\n\n  let defaultCall = encodeDefaultCall(transfer, address);\n  let pattern = WyvernProtocol.encodeReplacementPattern(transfer);\n  return {\n    target: transfer.target,\n    calldata: defaultCall,\n    replacementPattern: pattern\n  };\n};\n\nconst encodeBuy = (schema, asset, address, validatorAddress) => {\n  //   const transfer = schema.functions.transfer(asset);\n  const transfer = validatorAddress && schema.functions.checkAndTransfer ? schema.functions.checkAndTransfer(asset, validatorAddress) : schema.functions.transfer(asset);\n  const replaceables = transfer.inputs.filter(i => i.kind === \"replaceable\");\n  const ownerInputs = transfer.inputs.filter(i => i.kind === \"owner\"); // Validate\n\n  if (replaceables.length !== 1) {\n    throw new Error(\"Only 1 input can match transfer destination, but instead \" + replaceables.length + \" did\");\n  } // Compute calldata\n\n\n  const parameters = transfer.inputs.map(input => {\n    switch (input.kind) {\n      case \"replaceable\":\n        return address;\n\n      case \"owner\":\n        return WyvernProtocol.generateDefaultValue(input.type);\n\n      default:\n        try {\n          return input.value.toString();\n        } catch (e) {\n          console.error(schema);\n          console.error(asset);\n          throw e;\n        }\n\n    }\n  });\n  const calldata = encodeCall(transfer, parameters); // Compute replacement pattern\n\n  let replacementPattern = \"0x\";\n\n  if (ownerInputs.length > 0) {\n    replacementPattern = WyvernProtocol.encodeReplacementPattern(transfer, \"owner\");\n  }\n\n  return {\n    target: transfer.target,\n    calldata,\n    replacementPattern\n  };\n}; // \"metadata\": {\n//     \"asset\": {\n//         \"id\": \"5934\",\n//         \"address\": \"0x66fca7555cd481545a5e66ba9a2bec1e256f98e7\"\n//     },\n//     \"schema\": \"ERC721\"\n// },\n\n\nfunction getOrderHash(order) {\n  const orderWithStringTypes = { ...order,\n    maker: order.maker.toLowerCase(),\n    taker: order.taker.toLowerCase(),\n    feeRecipient: order.feeRecipient.toLowerCase(),\n    side: order.side.toString(),\n    saleKind: order.saleKind.toString(),\n    howToCall: order.howToCall.toString(),\n    feeMethod: order.feeMethod.toString(),\n    makerRelayerFee: 250.0.toFixed(),\n    takerRelayerFee: 0.0.toFixed(),\n    basePrice: 0.0.toFixed(),\n    extra: 0.0.toFixed()\n  };\n  return WyvernProtocol.getOrderHashHex(orderWithStringTypes);\n}\n\nfunction makeMatchingOrder(_ref) {\n  let {\n    order,\n    accountAddress,\n    recipientAddress,\n    platform\n  } = _ref;\n  accountAddress = validateAndFormatWalletAddress(accountAddress);\n  recipientAddress = validateAndFormatWalletAddress(recipientAddress);\n\n  const computeOrderParams = () => {\n    const shouldValidate = order.target === merkleValidatorByNetwork.main;\n\n    if (\"asset\" in order.metadata) {\n      const schema = ERC721Schema; // currently supporting ERC721 only\n\n      return order.side == 0 ? encodeSell(schema, order.metadata.asset, recipientAddress, shouldValidate ? order.target : undefined) : encodeBuy(schema, order.metadata.asset, recipientAddress, shouldValidate ? order.target : undefined);\n    } else {\n      throw new Error(\"Invalid order metadata\");\n    }\n  };\n\n  const {\n    target,\n    calldata,\n    replacementPattern\n  } = computeOrderParams();\n\n  const times = _getTimeParameters(0); // Compat for matching buy orders that have fee recipient still on them\n\n\n  const feeRecipient = order.feeRecipient == NULL_ADDRESS ? platform == PlatformType.Opensea ? OPENSEA_FEE_RECIPIENT : GOLOM_FEE_RECIPIENT : NULL_ADDRESS;\n  const matchingOrder = {\n    exchange: order.exchange,\n    maker: accountAddress,\n    taker: order.maker,\n    quantity: order.quantity,\n    makerRelayerFee: order.makerRelayerFee,\n    takerRelayerFee: order.takerRelayerFee,\n    makerProtocolFee: order.makerProtocolFee,\n    takerProtocolFee: order.takerProtocolFee,\n    makerReferrerFee: order.makerReferrerFee,\n    waitingForBestCounterOrder: false,\n    feeMethod: order.feeMethod,\n    feeRecipient,\n    side: (order.side + 1) % 2,\n    saleKind: 0,\n    // 0 fixed price 1 ducch aucion\n    target,\n    howToCall: order.howToCall,\n    calldata,\n    replacementPattern,\n    staticTarget: NULL_ADDRESS,\n    staticExtradata: \"0x\",\n    paymentToken: order.paymentToken,\n    basePrice: order.basePrice,\n    extra: BigNumber(0),\n    listingTime: times.listingTime,\n    expirationTime: times.expirationTime,\n    salt: WyvernProtocol.generatePseudoRandomSalt(),\n    metadata: order.metadata\n  };\n  return matchingOrder;\n}\n\nfunction assignOrdersToSides(order, matchingOrder) {\n  const isSellOrder = order.side == 1;\n  let buy;\n  let sell;\n\n  if (!isSellOrder) {\n    buy = order;\n    sell = { ...matchingOrder,\n      v: buy.v,\n      r: buy.r,\n      s: buy.s\n    };\n  } else {\n    sell = order;\n    buy = { ...matchingOrder,\n      v: sell.v,\n      r: sell.r,\n      s: sell.s\n    };\n  }\n\n  return {\n    buy,\n    sell\n  };\n}\n\nconst _getMetadata = (order, referrerAddress) => {\n  const referrer = referrerAddress || order.metadata.referrerAddress;\n\n  if (referrer && isValidAddress(referrer)) {\n    return `0x000000000000000000000000${referrer.substr(2)}`;\n  }\n\n  return undefined;\n};\n\nconst _correctGasAmount = estimation => {\n  return Math.ceil(estimation * 1.01);\n};\n\nfunction _getWyvernProtocolForOrder(order, useReadOnly) {\n  if (order.exchange === wyvern2_2ConfigByNetwork.main.wyvernExchangeContractAddress) {\n    return useReadOnly ? this._wyvern2_2ProtocolReadOnly : this._wyvern2_2Protocol;\n  }\n\n  return useReadOnly ? this._wyvernProtocolReadOnly : this._wyvernProtocol;\n}\n/**\n * Gets the price for the order using the contract\n * @param order The order to calculate the price for\n */\n\n\nasync function getCurrentPrice(order, wyvernExchange) {\n  const currentPrice = await wyvernExchange.methods.calculateCurrentPrice_([order.exchange, order.maker, order.taker, order.feeRecipient, order.target, order.staticTarget, order.paymentToken], [order.makerRelayerFee.toFixed(), order.takerRelayerFee.toFixed(), order.makerProtocolFee.toFixed(), order.takerProtocolFee.toFixed(), order.basePrice.toFixed(), order.extra.toFixed(), order.listingTime.toFixed(), order.expirationTime.toFixed(), order.salt.toFixed()], order.feeMethod, order.side, order.saleKind, order.howToCall, order.calldata, order.replacementPattern, order.staticExtradata).call();\n  return currentPrice;\n}\n/**\n * Estimates the price of an order\n * @param order The order to estimate price on\n * @param secondsToBacktrack The number of seconds to subtract on current time,\n *  to fix race conditions\n * @param shouldRoundUp Whether to round up fractional wei\n */\n\n\nexport function estimateCurrentPrice(order) {\n  let secondsToBacktrack = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 30;\n  let shouldRoundUp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  // round up should be enabled\n  let {\n    basePrice,\n    listingTime,\n    expirationTime,\n    extra\n  } = order;\n  const {\n    side,\n    takerRelayerFee,\n    saleKind\n  } = order;\n  const now = new BigNumber(Math.round(Date.now() / 1000)).minus(secondsToBacktrack);\n  basePrice = new BigNumber(basePrice);\n  listingTime = new BigNumber(listingTime);\n  expirationTime = new BigNumber(expirationTime);\n  extra = new BigNumber(extra);\n  let exactPrice = basePrice; // saleKind 0 : Fixed price 1: Duction acution\n\n  if (saleKind === 0) {// Do nothing, price is correct\n  } else if (saleKind === 1) {\n    const diff = extra.times(now.minus(listingTime)).dividedBy(expirationTime.minus(listingTime)); // side 0 : buy 1: sell\n\n    exactPrice = side == 1 ?\n    /* Sell-side - start price: basePrice. End price: basePrice - extra. */\n    basePrice.minus(diff) :\n    /* Buy-side - start price: basePrice. End price: basePrice + extra. */\n    basePrice.plus(diff);\n  } // Add taker fee only for buyers\n\n\n  if (side === 1 && !order.waitingForBestCounterOrder) {\n    // Buyer fee increases sale price\n    exactPrice = exactPrice.times(+takerRelayerFee / INVERSE_BASIS_POINT + 1);\n  }\n\n  return shouldRoundUp ? exactPrice.ceil() : exactPrice;\n}\n\nasync function _getRequiredAmountForTakingSellOrder(sell, wyvernExchange) {\n  const currentPrice = await getCurrentPrice(sell, wyvernExchange);\n  const estimatedPrice = estimateCurrentPrice(sell);\n  const maxPrice = BigNumber.max(currentPrice, estimatedPrice); // TODO Why is this not always a big number?\n\n  sell.takerRelayerFee = BigNumber(sell.takerRelayerFee);\n  const feePercentage = sell.takerRelayerFee.div(INVERSE_BASIS_POINT);\n  const fee = feePercentage.times(maxPrice);\n  return fee.plus(maxPrice); // use .ceil()\n}\n\nasync function _atomicMatch(_ref2) {\n  let {\n    buy,\n    sell,\n    accountAddress,\n    wyvernExchange,\n    metadata = NULL_BLOCK_HASH\n  } = _ref2;\n  let value;\n\n  if (buy.paymentToken == NULL_ADDRESS) {\n    value = await _getRequiredAmountForTakingSellOrder(sell, wyvernExchange);\n  }\n\n  const txnData = {\n    from: accountAddress,\n    value\n  };\n  const args = [[buy.exchange, buy.maker, buy.taker, buy.feeRecipient, buy.target, buy.staticTarget, buy.paymentToken, sell.exchange, sell.maker, sell.taker, sell.feeRecipient, sell.target, sell.staticTarget, sell.paymentToken], [250.0.toString(), 0.0.toString(), buy.makerProtocolFee.toString(), buy.takerProtocolFee.toString(), 0.0.toString(), buy.extra.toString(), buy.listingTime.toString(), buy.expirationTime.toString(), buy.salt.toString(), 250.0.toString(), 0.0.toString(), sell.makerProtocolFee.toString(), sell.takerProtocolFee.toString(), 0.0.toString(), 0.0.toString(), sell.listingTime.toString(), sell.expirationTime.toString(), sell.salt.toString()], [buy.feeMethod, buy.side, buy.saleKind, buy.howToCall, sell.feeMethod, sell.side, sell.saleKind, sell.howToCall], buy.calldata, sell.calldata, buy.replacementPattern, sell.replacementPattern, buy.staticExtradata, sell.staticExtradata, [buy.v || 0, sell.v || 0], [buy.r || NULL_BLOCK_HASH, buy.s || NULL_BLOCK_HASH, sell.r || NULL_BLOCK_HASH, sell.s || NULL_BLOCK_HASH, metadata]]; // const gasEstimate = await wyvernExchange.functions.estimateGasAsync(txnData);\n  // txnData.gas = _correctGasAmount(gasEstimate);\n\n  console.log(wyvernExchange);\n  const atomicMatchMethod = wyvernExchange.functions.atomicMatch_(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], txnData).then(res => {\n    console.log(res);\n  });\n  return {\n    atomicMatchMethod,\n    txnData\n  };\n}\n\nconst jsonToOrder = golomOrder => {\n  // console.log(order, golomOrder);\n  const {\n    data,\n    tokenId,\n    contractAddress,\n    created\n  } = golomOrder;\n  const createdDate = new Date(`${created}`);\n  const metadata = {\n    asset: {\n      id: String(tokenId),\n      address: contractAddress\n    },\n    schema: \"ERC721\"\n  };\n  const fromJSON = { ...data,\n    metadata,\n    quantity: new BigNumber(1),\n    makerRelayerFee: new BigNumber(data.makerRelayerFee),\n    takerRelayerFee: new BigNumber(data.takerRelayerFee),\n    makerProtocolFee: new BigNumber(data.makerProtocolFee),\n    takerProtocolFee: new BigNumber(data.takerProtocolFee),\n    makerReferrerFee: new BigNumber(data.makerReferrerFee),\n    waitingForBestCounterOrder: data.feeRecipient == NULL_ADDRESS,\n    basePrice: new BigNumber(data.basePrice),\n    extra: new BigNumber(data.extra),\n    currentBounty: new BigNumber(0),\n    currentPrice: new BigNumber(0),\n    createdTime: new BigNumber(Math.round(createdDate.getTime() / 1000)),\n    listingTime: new BigNumber(data.listingTime),\n    expirationTime: new BigNumber(data.expirationTime),\n    salt: new BigNumber(data.salt),\n    v: parseInt(data.v),\n    paymentTokenContract: data.payment_token_contract ? tokenFromJSON(data.payment_token_contract) : undefined\n  }; // Use client-side price calc, to account for buyer fee (not added by server) and latency\n\n  fromJSON.currentPrice = estimateCurrentPrice(fromJSON);\n  return fromJSON;\n};\n\nasync function fulfillOrder(_ref3) {\n  let {\n    order,\n    provider,\n    accountAddress,\n    recipientAddress,\n    referrerAddress,\n    platform = PlatformType.Opensea\n  } = _ref3;\n  console.info(`Account: ${accountAddress} | Recipient: ${recipientAddress} | Referrer: ${referrerAddress}`); // check if valid order\n  // order = jsonToOrder(order);\n\n  const wyvernExchange = WyvernContract(provider);\n  const isValid = await validateOrder({\n    order,\n    accountAddress,\n    wyvernExchange\n  });\n  const matchingOrder = makeMatchingOrder({\n    order,\n    accountAddress,\n    recipientAddress: recipientAddress,\n    platform\n  });\n  const {\n    buy,\n    sell\n  } = assignOrdersToSides(order, matchingOrder);\n\n  const metadata = _getMetadata(order, referrerAddress);\n\n  return await _atomicMatch({\n    buy,\n    sell,\n    accountAddress,\n    wyvernExchange,\n    metadata\n  });\n}\n\nfunction getWyvernAsset(schema, asset) {\n  let quantity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new BigNumber(1);\n  const tokenId = asset.tokenId != null ? asset.tokenId.toString() : undefined;\n  return schema.assetFromFields({\n    ID: tokenId,\n    Quantity: quantity.toString(),\n    Address: asset.tokenAddress.toLowerCase(),\n    Name: asset.name\n  });\n}\n\nasync function computeFees(_ref4) {\n  let {\n    asset,\n    side,\n    accountAddress,\n    platform,\n    extraBountyBasisPoints = 0\n  } = _ref4;\n  let openseaBuyerFeeBasisPoints = DEFAULT_BUYER_FEE_BASIS_POINTS;\n  let openseaSellerFeeBasisPoints = DEFAULT_SELLER_FEE_BASIS_POINTS;\n  let devBuyerFeeBasisPoints = 0;\n  let devSellerFeeBasisPoints = 0;\n  let transferFee = new BigNumber(0);\n  let transferFeeTokenAddress = null;\n  let maxTotalBountyBPS = DEFAULT_MAX_BOUNTY;\n\n  if (asset && platform == PlatformType.Opensea) {\n    openseaBuyerFeeBasisPoints = +asset.openseaBuyerFeeBasisPoints;\n    openseaSellerFeeBasisPoints = +asset.openseaSellerFeeBasisPoints;\n    devBuyerFeeBasisPoints = +asset.devBuyerFeeBasisPoints;\n    devSellerFeeBasisPoints = +asset.devSellerFeeBasisPoints;\n    maxTotalBountyBPS = openseaSellerFeeBasisPoints;\n  } // Compute transferFrom fees\n\n\n  if (side == 1 && asset && platform == PlatformType.Opensea) {// Server-side knowledge\n    // transferFee = asset.transferFee ? new BigNumber(asset.transferFee) : transferFee;\n    // transferFeeTokenAddress = asset.transferFeePaymentToken\n    //   ? asset.transferFeePaymentToken.address\n    //   : transferFeeTokenAddress;\n  } // Compute bounty\n\n\n  const sellerBountyBasisPoints = side == 1 ? extraBountyBasisPoints : 0; // Check that bounty is in range of the opensea fee\n\n  const bountyTooLarge = sellerBountyBasisPoints + OPENSEA_SELLER_BOUNTY_BASIS_POINTS > maxTotalBountyBPS;\n\n  if (sellerBountyBasisPoints > 0 && bountyTooLarge) {\n    let errorMessage = `Total bounty exceeds the maximum for this asset type (${maxTotalBountyBPS / 100}%).`;\n\n    if (maxTotalBountyBPS >= OPENSEA_SELLER_BOUNTY_BASIS_POINTS) {\n      errorMessage += ` Remember that OpenSea will add ${OPENSEA_SELLER_BOUNTY_BASIS_POINTS / 100}% for referrers with OpenSea accounts!`;\n    }\n\n    throw new Error(errorMessage);\n  }\n\n  return {\n    totalBuyerFeeBasisPoints: openseaBuyerFeeBasisPoints + devBuyerFeeBasisPoints,\n    totalSellerFeeBasisPoints: openseaSellerFeeBasisPoints + devSellerFeeBasisPoints,\n    openseaBuyerFeeBasisPoints,\n    openseaSellerFeeBasisPoints,\n    devBuyerFeeBasisPoints,\n    devSellerFeeBasisPoints,\n    sellerBountyBasisPoints,\n    transferFee,\n    transferFeeTokenAddress\n  };\n}\n/**\n * Compute the `basePrice` and `extra` parameters to be used to price an order.\n * Also validates the expiration time and auction type.\n * @param tokenAddress Address of the ERC-20 token to use for trading.\n * Use the null address for ETH\n * @param expirationTime When the auction expires, or 0 if never.\n * @param startAmount The base value for the order, in the token's main units (e.g. ETH instead of wei)\n * @param endAmount The end value for the order, in the token's main units (e.g. ETH instead of wei). If unspecified, the order's `extra` attribute will be 0\n */\n\n\nasync function _getPriceParameters(orderSide, tokenAddress, expirationTime, startAmount, endAmount) {\n  let waitingForBestCounterOrder = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  let englishAuctionReservePrice = arguments.length > 6 ? arguments[6] : undefined;\n  const priceDiff = endAmount != null ? startAmount - endAmount : 0;\n  const paymentToken = tokenAddress.toLowerCase(); // const isEther = tokenAddress == NULL_ADDRESS;\n  // const { tokens } = await this.api.getPaymentTokens({ address: paymentToken });\n  // const token = tokens[0];\n  // Note: WyvernProtocol.toBaseUnitAmount(makeBigNumber(startAmount), token.decimals)\n  // will fail if too many decimal places, so special-case ether\n  // const basePrice = isEther\n  //   ? new BigNumber(parseEther(startAmount)).round()\n  //   : WyvernProtocol.toBaseUnitAmount(new BigNumber(startAmount), token.decimals);\n\n  const basePrice = new BigNumber(parseEther(String(startAmount))); // const extra = isEther\n  //   ? new BigNumber(parseEther(priceDiff)).decimalPlaces()\n  //   : WyvernProtocol.toBaseUnitAmount(new BigNumber(priceDiff), token.decimals);\n  // console.log(basePrice, priceDiff);\n\n  const extra = new BigNumber(parseEther(String(priceDiff))); // const reservePrice = englishAuctionReservePrice\n  //   ? isEther\n  //     ? new BigNumber(parseEther(englishAuctionReservePrice))\n  //     : WyvernProtocol.toBaseUnitAmount(new BigNumber(englishAuctionReservePrice), token.decimals)\n  //   : undefined;\n\n  const reservePrice = englishAuctionReservePrice ? new BigNumber(parseEther(englishAuctionReservePrice)) : undefined;\n  return {\n    basePrice,\n    extra,\n    paymentToken,\n    reservePrice\n  };\n}\n\nfunction _validateFees(totalBuyerFeeBasisPoints, totalSellerFeeBasisPoints) {\n  const maxFeePercent = INVERSE_BASIS_POINT / 100;\n\n  if (totalBuyerFeeBasisPoints > INVERSE_BASIS_POINT || totalSellerFeeBasisPoints > INVERSE_BASIS_POINT) {\n    throw new Error(`Invalid buyer/seller fees: must be less than ${maxFeePercent}%`);\n  }\n\n  if (totalBuyerFeeBasisPoints < 0 || totalSellerFeeBasisPoints < 0) {\n    throw new Error(`Invalid buyer/seller fees: must be at least 0%`);\n  }\n}\n\nfunction _getSellFeeParameters(totalBuyerFeeBasisPoints, totalSellerFeeBasisPoints, waitForHighestBid) {\n  let sellerBountyBasisPoints = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  let platform = arguments.length > 4 ? arguments[4] : undefined;\n\n  // just making basic check if fee is less than 100% and not negative\n  _validateFees(totalBuyerFeeBasisPoints, totalSellerFeeBasisPoints); // Use buyer as the maker when it's an English auction, so Wyvern sets prices correctly\n\n\n  const feeRecipient = waitForHighestBid ? NULL_ADDRESS : OPENSEA_FEE_RECIPIENT; // Swap maker/taker fees when it's an English auction,\n  // since these sell orders are takers not makers\n\n  const makerRelayerFee = waitForHighestBid ? new BigNumber(totalBuyerFeeBasisPoints) : new BigNumber(totalSellerFeeBasisPoints);\n  const takerRelayerFee = waitForHighestBid ? new BigNumber(totalSellerFeeBasisPoints) : new BigNumber(totalBuyerFeeBasisPoints);\n  return {\n    makerRelayerFee,\n    takerRelayerFee,\n    makerProtocolFee: new BigNumber(0),\n    takerProtocolFee: new BigNumber(0),\n    makerReferrerFee: new BigNumber(sellerBountyBasisPoints),\n    feeRecipient,\n    feeMethod: 1 // 0 protocol fee ,1 split fee\n\n  };\n}\n\nconst StaticCheckTxOrigin = [{\n  constant: true,\n  inputs: [],\n  name: \"succeedIfTxOriginMatchesHardcodedAddress\",\n  outputs: [],\n  payable: false,\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  constant: false,\n  inputs: [],\n  name: \"renounceOwnership\",\n  outputs: [],\n  payable: false,\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  constant: true,\n  inputs: [{\n    name: \"_specifiedAddress\",\n    type: \"address\"\n  }],\n  name: \"succeedIfTxOriginMatchesSpecifiedAddress\",\n  outputs: [],\n  payable: false,\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  constant: true,\n  inputs: [],\n  name: \"owner\",\n  outputs: [{\n    name: \"\",\n    type: \"address\"\n  }],\n  payable: false,\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  constant: true,\n  inputs: [],\n  name: \"isOwner\",\n  outputs: [{\n    name: \"\",\n    type: \"bool\"\n  }],\n  payable: false,\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  constant: false,\n  inputs: [{\n    name: \"_newHardcodedAddress\",\n    type: \"address\"\n  }],\n  name: \"changeHardcodedAddress\",\n  outputs: [],\n  payable: false,\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  constant: false,\n  inputs: [{\n    name: \"newOwner\",\n    type: \"address\"\n  }],\n  name: \"transferOwnership\",\n  outputs: [],\n  payable: false,\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    name: \"_hardcodedAddress\",\n    type: \"address\"\n  }],\n  payable: false,\n  stateMutability: \"nonpayable\",\n  type: \"constructor\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    name: \"previousOwner\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    name: \"newOwner\",\n    type: \"address\"\n  }],\n  name: \"OwnershipTransferred\",\n  type: \"event\"\n}];\nexport const getMethod = (abi, name) => {\n  const methodAbi = abi.find(x => x.type == \"function\" && x.name == name);\n\n  if (!methodAbi) {\n    throw new Error(`ABI ${name} not found`);\n  } // Have to cast since there's a bug in\n  // web3 types on the 'type' field\n\n\n  return methodAbi;\n};\n\nasync function _getStaticCallTargetAndExtraData(_ref5) {\n  let {\n    useTxnOriginStaticCall\n  } = _ref5;\n\n  if (!useTxnOriginStaticCall) {\n    // While testing, we will use dummy values for mainnet. We will remove this if-statement once we have pushed the PR once and tested on Rinkeby\n    return {\n      staticTarget: NULL_ADDRESS,\n      staticExtradata: \"0x\"\n    };\n  }\n\n  if (useTxnOriginStaticCall) {\n    return {\n      staticTarget: STATIC_CALL_TX_ORIGIN_ADDRESS,\n      staticExtradata: encodeCall(getMethod(StaticCheckTxOrigin, \"succeedIfTxOriginMatchesHardcodedAddress\"), [])\n    };\n  } else {\n    // Noop - no checks\n    return {\n      staticTarget: NULL_ADDRESS,\n      staticExtradata: \"0x\"\n    };\n  }\n}\n\nexport const assetContractFromJSON = assetContract => {\n  return {\n    name: assetContract.name,\n    description: assetContract.description,\n    type: assetContract.assetContract_type,\n    schemaName: assetContract.schema_name,\n    address: assetContract.address,\n    tokenSymbol: assetContract.symbol,\n    buyerFeeBasisPoints: +assetContract.buyer_fee_basis_points,\n    sellerFeeBasisPoints: +assetContract.seller_fee_basis_points,\n    openseaBuyerFeeBasisPoints: +assetContract.opensea_buyer_fee_basis_points,\n    openseaSellerFeeBasisPoints: +assetContract.opensea_seller_fee_basis_points,\n    devBuyerFeeBasisPoints: +assetContract.dev_buyer_fee_basis_points,\n    devSellerFeeBasisPoints: +assetContract.dev_seller_fee_basis_points,\n    imageUrl: assetContract.image_url,\n    externalLink: assetContract.external_link,\n    wikiLink: assetContract.wiki_link\n  };\n};\nexport const collectionFromJSON = collection => {\n  const createdDate = new Date(`${collection.created_date}Z`);\n  return {\n    createdDate,\n    name: collection.name,\n    description: collection.description,\n    slug: collection.slug,\n    editors: collection.editors,\n    hidden: collection.hidden,\n    featured: collection.featured,\n    featuredImageUrl: collection.featured_image_url,\n    displayData: collection.display_data,\n    paymentTokens: (collection.payment_tokens || []).map(tokenFromJSON),\n    openseaBuyerFeeBasisPoints: +collection.opensea_buyer_fee_basis_points,\n    openseaSellerFeeBasisPoints: +collection.opensea_seller_fee_basis_points,\n    devBuyerFeeBasisPoints: +collection.dev_buyer_fee_basis_points,\n    devSellerFeeBasisPoints: +collection.dev_seller_fee_basis_points,\n    payoutAddress: collection.payout_address,\n    imageUrl: collection.image_url,\n    largeImageUrl: collection.large_image_url,\n    stats: collection.stats,\n    traitStats: collection.traits,\n    externalLink: collection.external_url,\n    wikiLink: collection.wiki_url\n  };\n};\nexport const userFromJSON = user => {\n  return {\n    username: user.username\n  };\n};\nexport const accountFromJSON = account => {\n  return {\n    address: account.address,\n    config: account.config,\n    profileImgUrl: account.profile_img_url,\n    user: account.user ? userFromJSON(account.user) : null\n  };\n};\nexport const transactionFromJSON = transaction => {\n  return {\n    fromAccount: accountFromJSON(transaction.from_account),\n    toAccount: accountFromJSON(transaction.to_account),\n    createdDate: new Date(`${transaction.created_date}Z`),\n    modifiedDate: new Date(`${transaction.modified_date}Z`),\n    transactionHash: transaction.transaction_hash,\n    transactionIndex: transaction.transaction_index,\n    blockNumber: transaction.block_number,\n    blockHash: transaction.block_hash,\n    timestamp: new Date(`${transaction.timestamp}Z`)\n  };\n};\nexport const assetEventFromJSON = assetEvent => {\n  return {\n    eventType: assetEvent.event_type,\n    eventTimestamp: assetEvent.event_timestamp,\n    auctionType: assetEvent.auction_type,\n    totalPrice: assetEvent.total_price,\n    transaction: assetEvent.transaction ? transactionFromJSON(assetEvent.transaction) : null,\n    paymentToken: assetEvent.payment_token ? tokenFromJSON(assetEvent.payment_token) : null\n  };\n};\nexport const assetFromJSON = asset => {\n  const isAnimated = asset.image_url && asset.image_url.endsWith(\".gif\");\n  const isSvg = asset.image_url && asset.image_url.endsWith(\".svg\");\n  const fromJSON = {\n    tokenId: asset.token_id.toString(),\n    tokenAddress: asset.asset_contract.address,\n    name: asset.name,\n    description: asset.description,\n    owner: asset.owner,\n    assetContract: assetContractFromJSON(asset.asset_contract),\n    collection: collectionFromJSON(asset.collection),\n    orders: asset.orders ? asset.orders.map(orderFromJSON) : null,\n    sellOrders: asset.sell_orders ? asset.sell_orders.map(orderFromJSON) : null,\n    buyOrders: asset.buy_orders ? asset.buy_orders.map(orderFromJSON) : null,\n    isPresale: asset.is_presale,\n    // Don't use previews if it's a special image\n    imageUrl: isAnimated || isSvg ? asset.image_url : asset.image_preview_url || asset.image_url,\n    imagePreviewUrl: asset.image_preview_url,\n    imageUrlOriginal: asset.image_original_url,\n    imageUrlThumbnail: asset.image_thumbnail_url,\n    externalLink: asset.external_link,\n    openseaLink: asset.permalink,\n    traits: asset.traits,\n    numSales: asset.num_sales,\n    lastSale: asset.last_sale ? assetEventFromJSON(asset.last_sale) : null,\n    backgroundColor: asset.background_color ? `#${asset.background_color}` : null,\n    transferFee: asset.transfer_fee ? new BigNumber(asset.transfer_fee) : null,\n    transferFeePaymentToken: asset.transfer_fee_payment_token ? tokenFromJSON(asset.transfer_fee_payment_token) : null\n  }; // If orders were included, put them in sell/buy order groups\n\n  if (fromJSON.orders && !fromJSON.sellOrders) {\n    fromJSON.sellOrders = fromJSON.orders.filter(o => o.side == 1);\n  }\n\n  if (fromJSON.orders && !fromJSON.buyOrders) {\n    fromJSON.buyOrders = fromJSON.orders.filter(o => o.side == 0);\n  }\n\n  return fromJSON;\n};\n/**\n * Fetch an asset from the API, throwing if none is found\n * @param tokenAddress Address of the asset's contract\n * @param tokenId The asset's token ID, or null if ERC-20\n * @param retries Number of times to retry if the service is unavailable for any reason\n */\n\nasync function getAsset(_ref6) {\n  let {\n    tokenAddress,\n    tokenId\n  } = _ref6;\n  const {\n    data\n  } = await axios(`${OPENSEA_URL}asset/${tokenAddress}/${tokenId || 0}/`);\n  return assetFromJSON(data);\n}\n\nasync function _makeSellOrder(_ref7) {\n  let {\n    asset,\n    quantity,\n    accountAddress,\n    startAmount,\n    endAmount,\n    listingTime,\n    expirationTime,\n    waitForHighestBid,\n    englishAuctionReservePrice = 0,\n    paymentTokenAddress,\n    extraBountyBasisPoints,\n    // this is for extra fee\n    buyerAddress,\n    platform,\n    openSeaAsset // holds fee\n\n  } = _ref7;\n  accountAddress = validateAndFormatWalletAddress(accountAddress);\n  const schema = ERC721Schema; // currently supporting ERC721 only\n\n  const quantityBN = new BigNumber(1);\n  const wyAsset = getWyvernAsset(schema, asset, quantityBN);\n  let totalSellerFeeBasisPoints = GOLOM_DEFAULT_FEES; // in bps\n\n  if (asset.tokenAddress == \"0xf07468ead8cf26c752c676e43c814fee9c8cf402\") {\n    totalSellerFeeBasisPoints = 0;\n  }\n\n  let totalBuyerFeeBasisPoints = 0;\n  let sellerBountyBasisPoints = 0; // TODO: No need to fetch asset again we can use values from _token.vue directly\n\n  if (platform == PlatformType.Opensea) {\n    // { totalSellerFeeBasisPoints, totalBuyerFeeBasisPoints, sellerBountyBasisPoints }\n    const fees = await computeFees({\n      asset: openSeaAsset,\n      side: 1,\n      extraBountyBasisPoints,\n      platform\n    }); // 1 for sell 0 for buy\n\n    totalSellerFeeBasisPoints = fees.totalSellerFeeBasisPoints;\n    totalBuyerFeeBasisPoints = fees.totalBuyerFeeBasisPoints;\n    sellerBountyBasisPoints = fees.sellerBountyBasisPoints;\n  }\n\n  const {\n    target,\n    calldata,\n    replacementPattern\n  } = encodeSell(schema, wyAsset, accountAddress, // waitForHighestBid ? undefined : merkleValidatorByNetwork.main\n  merkleValidatorByNetwork.main);\n  console.log(endAmount);\n  const orderSaleKind = endAmount != null && endAmount !== startAmount ? 1 : 0; // 0 fixed price 1 ducch aucion\n\n  const {\n    basePrice,\n    extra,\n    paymentToken,\n    reservePrice\n  } = await _getPriceParameters(1, paymentTokenAddress, expirationTime, startAmount, endAmount, waitForHighestBid, englishAuctionReservePrice);\n\n  const times = _getTimeParameters(expirationTime, listingTime, waitForHighestBid);\n\n  let {\n    makerRelayerFee,\n    takerRelayerFee,\n    makerProtocolFee,\n    takerProtocolFee,\n    makerReferrerFee,\n    feeRecipient,\n    feeMethod\n  } = _getSellFeeParameters(totalBuyerFeeBasisPoints, totalSellerFeeBasisPoints, waitForHighestBid, sellerBountyBasisPoints);\n\n  if (platform != PlatformType.Opensea) {\n    feeRecipient = GOLOM_FEE_RECIPIENT;\n  }\n\n  const {\n    staticTarget,\n    staticExtradata\n  } = await _getStaticCallTargetAndExtraData({\n    useTxnOriginStaticCall: waitForHighestBid\n  });\n  return {\n    exchange: WYVERN_CONTRACT,\n    maker: accountAddress,\n    taker: buyerAddress,\n    // for private listing\n    quantity: quantityBN,\n    makerRelayerFee,\n    takerRelayerFee,\n    makerProtocolFee,\n    takerProtocolFee,\n    makerReferrerFee,\n    waitingForBestCounterOrder: waitForHighestBid,\n    englishAuctionReservePrice: reservePrice ? new BigNumber(reservePrice) : undefined,\n    feeMethod,\n    feeRecipient,\n    side: 1,\n    saleKind: orderSaleKind,\n    target,\n    howToCall: target === merkleValidatorByNetwork.main ? HowToCall.DelegateCall : HowToCall.Call,\n    calldata,\n    replacementPattern,\n    staticTarget,\n    staticExtradata,\n    paymentToken,\n    basePrice,\n    extra,\n    listingTime: times.listingTime,\n    expirationTime: times.expirationTime,\n    salt: WyvernProtocol.generatePseudoRandomSalt(),\n    metadata: {\n      asset: wyAsset,\n      schema: schema.name\n    }\n  };\n}\n\nasync function validateOrderParams(_ref8) {\n  let {\n    order,\n    accountAddress,\n    wyvernExchange\n  } = _ref8;\n  // Check sell parameters\n  const sellValid = await wyvernExchange.functions.validateOrderParameters_([order.exchange, order.maker, order.taker, order.feeRecipient, order.target, order.staticTarget, order.paymentToken], [0.001.toFixed(), 0.001.toFixed(), order.makerProtocolFee.toFixed(), order.takerProtocolFee.toFixed(), 0.0.toFixed(), 0.0.toFixed(), order.listingTime.toFixed(), order.expirationTime.toFixed(), order.salt.toFixed()], order.feeMethod, order.side, order.saleKind, order.howToCall, order.calldata, order.replacementPattern, order.staticExtradata); // .call({ from: accountAddress });\n\n  if (!sellValid) {\n    console.error(order);\n    throw new Error(`Failed to validate sell order parameters. Make sure you're on the right network!`);\n  }\n\n  return sellValid;\n}\n\nasync function validateOrder(_ref9) {\n  let {\n    order,\n    accountAddress,\n    wyvernExchange\n  } = _ref9;\n  // Check sell parameters\n  const sellValid = await wyvernExchange.functions.validateOrder_([order.exchange, order.maker, order.taker, order.feeRecipient, order.target, order.staticTarget, order.paymentToken], [250.0.toFixed(), 0.0.toFixed(), order.makerProtocolFee, order.takerProtocolFee, 0.0.toFixed(), 0.0.toFixed(), order.listingTime, order.expirationTime, order.salt], order.feeMethod, order.side, order.saleKind, order.howToCall, order.calldata, order.replacementPattern, order.staticExtradata, order.v, order.r, order.s); // .call({ from: accountAddress });\n\n  if (!sellValid) {\n    // eslint-disable-next-line no-throw-literal\n    throw {\n      message: new Error(`Failed to validate sell order parameters. It looks like this listing is invalid.`),\n      code: \"InvalidOrder\"\n    }; // TODO: call order invalidate API\n  }\n\n  return sellValid;\n} // sourced from 0x.js:\n// https://github.com/ProjectWyvern/wyvern-js/blob/39999cb93ce5d80ea90b4382182d1bd4339a9c6c/src/utils/signature_utils.ts\n\n\nasync function parseSignatureHex(signature) {\n  // HACK: There is no consensus on whether the signatureHex string should be formatted as\n  // v + r + s OR r + s + v, and different clients (even different versions of the same client)\n  // return the signature params in different orders. In order to support all client implementations,\n  // we parse the signature in both ways, and evaluate if either one is a valid signature.\n  const validVParamValues = [27, 28];\n\n  const ecSignatureRSV = _parseSignatureHexAsRSV(signature);\n\n  if (_.includes(validVParamValues, ecSignatureRSV.v)) {\n    return ecSignatureRSV;\n  } // For older clients\n\n\n  const ecSignatureVRS = _parseSignatureHexAsVRS(signature);\n\n  if (_.includes(validVParamValues, ecSignatureVRS.v)) {\n    return ecSignatureVRS;\n  }\n\n  throw new Error(\"Invalid signature\");\n\n  function _parseSignatureHexAsVRS(signatureHex) {\n    const signatureBuffer = ethUtil.toBuffer(signatureHex);\n    let v = signatureBuffer[0];\n\n    if (v < 27) {\n      v += 27;\n    }\n\n    const r = signatureBuffer.slice(1, 33);\n    const s = signatureBuffer.slice(33, 65);\n    const ecSignature = {\n      v,\n      r: ethUtil.bufferToHex(r),\n      s: ethUtil.bufferToHex(s)\n    };\n    return ecSignature;\n  }\n\n  function _parseSignatureHexAsRSV(signatureHex) {\n    const {\n      v,\n      r,\n      s\n    } = ethUtil.fromRpcSig(signatureHex);\n    const ecSignature = {\n      v,\n      r: ethUtil.bufferToHex(r),\n      s: ethUtil.bufferToHex(s)\n    };\n    return ecSignature;\n  }\n}\n\nasync function personalSignAsync(provider, message, signerAddress) {\n  return new Promise((resolve, reject) => {\n    const callback = async (err, signature) => {\n      if (err) reject(err);\n\n      if (signature.error) {\n        reject(signature.error.message);\n      }\n\n      resolve(parseSignatureHex(signature.result)); // // console.log(result);\n      // const d = signature.result;\n      // let v = d.slice(-2);\n      // let r = d.slice(2, -66);\n      // let s = d.slice(-66, -2);\n      // let actualsignature = v + r + s + '03';\n      // // const dhs = await this.contractInstace.methods\n      // //   .setApprovalForAll(OPERATOR_ADDRESS, true)\n      // //   .send({ from: this.metamask.metaMaskAddress });\n      // resolve(`0x${actualsignature}`);\n    }; // console.log(orderHex, metaMaskAddress);\n\n\n    provider.sendAsync({\n      method: \"personal_sign\",\n      params: [message, signerAddress],\n      from: signerAddress\n    }, callback);\n  });\n}\n\nexport async function signTypedDataAsync(provider, message, signerAddress) {\n  let signature;\n  console.log(signerAddress);\n  return new Promise((resolve, reject) => {\n    const callback = async (err, result) => {\n      console.log(err);\n      if (err) reject(err);\n\n      if (result.error) {\n        reject(result.error.message);\n      } // eslint-disable-next-line prefer-promise-reject-errors\n\n\n      if (result.error) return reject(\"ERROR\", result); // console.log(result);\n      // const d = result.result;\n      // let v = d.slice(-2);\n      // let r = d.slice(2, -66);\n      // let s = d.slice(-66, -2);\n      // let actualsignature = v + r + s + '03';\n\n      resolve(parseSignatureHex(result.result));\n    };\n\n    const stringified = JSON.stringify({ ...message\n    });\n\n    try {\n      // Using sign typed data V4 works with a stringified message, used by browser providers i.e. Metamask\n      provider.sendAsync({\n        method: \"eth_signTypedData_v4\",\n        params: [signerAddress, stringified],\n        from: signerAddress,\n        id: new Date().getTime()\n      }, callback);\n    } catch (error) {\n      console.log(error); // Fallback to normal sign typed data for node providers, without using stringified message\n      // https://github.com/coinbase/coinbase-wallet-sdk/issues/60\n\n      provider.sendAsync({\n        method: \"eth_signTypedData\",\n        params: [signerAddress, message],\n        from: signerAddress,\n        id: new Date().getTime()\n      }, callback);\n    }\n  });\n}\n\nasync function _authorizeOrder(_ref10) {\n  let {\n    order,\n    provider,\n    nonce\n  } = _ref10;\n  // 2.2 Sign order flow\n  const signerAddress = order.maker; // console.log(order, nonce);\n\n  if (order.exchange === wyvern2_2ConfigByNetwork.main.wyvernExchangeContractAddress && order.hash) {\n    const message = order.hash; // v1\n\n    return await personalSignAsync(provider, message, signerAddress);\n  } // 2.3 Sign order flow using EIP-712\n  // We need to manually specify each field because OS orders can contain unrelated data\n\n\n  const orderForSigning = {\n    maker: order.maker,\n    exchange: order.exchange,\n    taker: order.taker,\n    makerRelayerFee: order.makerRelayerFee.toString(),\n    takerRelayerFee: order.takerRelayerFee.toString(),\n    makerProtocolFee: order.makerProtocolFee.toString(),\n    takerProtocolFee: order.takerProtocolFee.toString(),\n    feeRecipient: order.feeRecipient,\n    feeMethod: order.feeMethod,\n    side: order.side,\n    saleKind: order.saleKind,\n    target: order.target,\n    howToCall: order.howToCall,\n    calldata: order.calldata,\n    replacementPattern: order.replacementPattern,\n    staticTarget: order.staticTarget,\n    staticExtradata: order.staticExtradata,\n    paymentToken: order.paymentToken,\n    basePrice: order.basePrice.toString(),\n    extra: order.extra.toString(),\n    listingTime: order.listingTime.toString(),\n    expirationTime: order.expirationTime.toString(),\n    salt: order.salt.toString()\n  }; // We don't JSON.stringify as certain wallet providers sanitize this data\n  // https://github.com/coinbase/coinbase-wallet-sdk/issues/60\n\n  const message = {\n    types: EIP_712_ORDER_TYPES,\n    domain: {\n      name: EIP_712_WYVERN_DOMAIN_NAME,\n      version: EIP_712_WYVERN_DOMAIN_VERSION,\n      chainId: 1,\n      verifyingContract: order.exchange\n    },\n    primaryType: \"Order\",\n    message: { ...orderForSigning,\n      nonce\n    }\n  };\n  const ecSignature = await signTypedDataAsync(provider, message, signerAddress);\n  return { ...ecSignature,\n    nonce\n  };\n}\n/**\n * Convert an order to JSON, hashing it as well if necessary\n * @param order order (hashed or unhashed)\n */\n\n\nconst orderToJSON = order => {\n  const asJSON = {\n    exchange: order.exchange.toLowerCase(),\n    maker: order.maker.toLowerCase(),\n    taker: order.taker.toLowerCase(),\n    makerRelayerFee: order.makerRelayerFee.toString(),\n    takerRelayerFee: order.takerRelayerFee.toString(),\n    makerProtocolFee: order.makerProtocolFee.toString(),\n    takerProtocolFee: order.takerProtocolFee.toString(),\n    makerReferrerFee: order.makerReferrerFee.toString(),\n    feeMethod: order.feeMethod,\n    feeRecipient: order.feeRecipient.toLowerCase(),\n    side: order.side,\n    saleKind: order.saleKind,\n    target: order.target.toLowerCase(),\n    howToCall: order.howToCall,\n    calldata: order.calldata,\n    replacementPattern: order.replacementPattern,\n    staticTarget: order.staticTarget.toLowerCase(),\n    staticExtradata: order.staticExtradata,\n    paymentToken: order.paymentToken.toLowerCase(),\n    quantity: order.quantity.toString(),\n    basePrice: order.basePrice.toString(),\n    englishAuctionReservePrice: order.englishAuctionReservePrice ? order.englishAuctionReservePrice.toString() : undefined,\n    extra: order.extra.toString(),\n    createdTime: order.createdTime ? order.createdTime.toString() : undefined,\n    listingTime: order.listingTime.toString(),\n    expirationTime: order.expirationTime.toString(),\n    salt: order.salt.toString(),\n    metadata: order.metadata,\n    v: order.v,\n    r: order.r,\n    s: order.s,\n    nonce: order.nonce\n  };\n  return asJSON;\n};\n\nasync function postOrder(order) {\n  let retries = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n\n  try {\n    const {\n      data\n    } = await axios.post(`https://api.opensea.io/wyvern/v1/orders/post/`, order, {\n      headers: {\n        \"x-api-key\": X_API_KEY\n      }\n    });\n    return data;\n  } catch (error) {\n    throw new Error(error);\n  }\n}\n/**\n * Convert an order to JSON for golom, hashing it as well if necessary\n * @param order order (hashed or unhashed)\n */\n\n\nconst orderToGolomJSON = order => {\n  const asJSON = {\n    exchange: order.exchange.toLowerCase(),\n    maker: {\n      address: order.maker.toLowerCase()\n    },\n    taker: {\n      address: order.taker.toLowerCase()\n    },\n    maker_relayer_fee: order.makerRelayerFee.toString(),\n    taker_relayer_fee: order.takerRelayerFee.toString(),\n    maker_protocol_fee: order.makerProtocolFee.toString(),\n    taker_protocol_fee: order.takerProtocolFee.toString(),\n    makerReferrerFee: order.makerReferrerFee.toString(),\n    fee_method: order.feeMethod,\n    fee_recipient: {\n      address: order.feeRecipient.toLowerCase()\n    },\n    side: order.side,\n    sale_kind: order.saleKind,\n    target: order.target.toLowerCase(),\n    how_to_call: order.howToCall,\n    calldata: order.calldata,\n    replacement_pattern: order.replacementPattern,\n    static_target: order.staticTarget.toLowerCase(),\n    static_extradata: order.staticExtradata,\n    payment_token: order.paymentToken.toLowerCase(),\n    quantity: order.quantity.toString(),\n    base_price: order.basePrice.toString(),\n    englishAuctionReservePrice: order.englishAuctionReservePrice ? order.englishAuctionReservePrice.toString() : undefined,\n    extra: order.extra.toString(),\n    createdTime: order.createdTime ? order.createdTime.toString() : undefined,\n    listing_time: order.listingTime.toString(),\n    expiration_time: order.expirationTime.toString(),\n    salt: order.salt.toString(),\n    metadata: order.metadata,\n    v: order.v,\n    r: order.r,\n    s: order.s,\n    prefixed_hash: order.hash\n  };\n  return asJSON;\n};\n/**\n * Validate and post an order to the OpenSea orderbook.\n * @param order The order to post. Can either be signed by the maker or pre-approved on the Wyvern contract using approveOrder. See https://github.com/ProjectWyvern/wyvern-ethereum/blob/master/contracts/exchange/Exchange.sol#L178\n * @returns The order as stored by the orderbook\n */\n\n\nasync function validateAndPostOrder(_ref11) {\n  let {\n    order,\n    platform\n  } = _ref11;\n  // Validation is called server-side\n  return platform == PlatformType.Opensea ? orderToJSON(order) : orderToGolomJSON(order);\n}\n\nfunction cancelOSOrder(_ref12) {\n  let {\n    provider,\n    order\n  } = _ref12;\n  const wyvernExchange = WyvernContract(provider); // const cancelHash = wyvernExchange.methods\n  //   .hashToSign_(\n  //     [\n  //       order.exchange,\n  //       order.maker,\n  //       order.taker,\n  //       order.feeRecipient,\n  //       order.target,\n  //       order.staticTarget,\n  //       order.paymentToken\n  //     ],\n  //     [\n  //       order.makerRelayerFee,\n  //       order.takerRelayerFee,\n  //       order.makerProtocolFee,\n  //       order.takerProtocolFee,\n  //       order.basePrice,\n  //       order.extra,\n  //       order.listingTime,\n  //       order.expirationTime,\n  //       order.salt\n  //     ],\n  //     order.feeMethod,\n  //     order.side,\n  //     order.saleKind,\n  //     order.howToCall,\n  //     order.calldata,\n  //     order.replacementPattern,\n  //     order.staticExtradata\n  //   )\n  //   .call();\n  // console.log(cancelHash);\n\n  return wyvernExchange.methods.cancelOrder_([order.exchange, order.maker, order.taker, order.feeRecipient, order.target, order.staticTarget, order.paymentToken], [order.makerRelayerFee, order.takerRelayerFee, order.makerProtocolFee, order.takerProtocolFee, order.basePrice, order.extra, order.listingTime, order.expirationTime, order.salt], order.feeMethod, order.side, order.saleKind, order.howToCall, order.calldata, order.replacementPattern, order.staticExtradata, order.v || 0, order.r || NULL_BLOCK_HASH, order.s || NULL_BLOCK_HASH);\n}\n\nasync function createSellOrder(_ref13) {\n  let {\n    provider,\n    asset,\n    accountAddress,\n    startAmount,\n    endAmount,\n    quantity = 1,\n    listingTime,\n    expirationTime = 0,\n    waitForHighestBid = false,\n    englishAuctionReservePrice,\n    paymentTokenAddress,\n    extraBountyBasisPoints = 0,\n    buyerAddress,\n    fees,\n    platform = PlatformType.Opensea,\n    buyerEmail\n  } = _ref13;\n  const order = await _makeSellOrder({\n    asset,\n    quantity,\n    accountAddress,\n    startAmount,\n    endAmount,\n    listingTime,\n    expirationTime,\n    waitForHighestBid,\n    englishAuctionReservePrice,\n    paymentTokenAddress: paymentTokenAddress || NULL_ADDRESS,\n    extraBountyBasisPoints,\n    platform,\n    openSeaAsset: fees,\n    buyerAddress: buyerAddress || NULL_ADDRESS\n  });\n  const wyvernExchange = WyvernContract(provider);\n  await validateOrderParams({\n    order,\n    accountAddress,\n    wyvernExchange\n  });\n  const hashedOrder = { ...order,\n    hash: getOrderHash(order)\n  };\n  const nonce = Number(await wyvernExchange.functions.nonces(accountAddress));\n  let signature;\n\n  try {\n    signature = await _authorizeOrder({\n      provider,\n      order: hashedOrder,\n      nonce\n    });\n  } catch (error) {\n    console.error(error);\n    throw new Error(\"You declined to authorize your auction\");\n  }\n\n  const orderWithSignature = { ...hashedOrder,\n    ...signature\n  };\n  return validateAndPostOrder({\n    order: orderWithSignature,\n    platform\n  });\n}\n\nexport { fulfillOrder, createSellOrder, cancelOSOrder }; // maker:\n// 0xafac92864611c564e7fa1a6c6d07b45807536943\n// exchange:\n// 0x7f268357a8c2552623316e2562d90e642bb538e5\n// taker:\n// 0x0000000000000000000000000000000000000000\n// makerRelayerFee:\n// 500\n// takerRelayerFee:\n// 0\n// makerProtocolFee:\n// 0\n// takerProtocolFee:\n// 0\n// feeRecipient:\n// 0x5b3256965e7c3cf26e11fcaf296dfc8807c01073\n// feeMethod:\n// 1\n// side:\n// 1\n// saleKind:\n// 0\n// target:\n// 0xbaf2127b49fc93cbca6269fade0f7f31df4c88a7\n// howToCall:\n// 1\n// calldata:\n// 0xfb16a595000000000000000000000000afac92864611c564e7fa1a6c6d07b45807536943000000000000000000000000000000000000000000000000000000000000000000000000000000000000000079fcdef22feed20eddacbb2587640e45491b757f0000000000000000000000000000000000000000000000000000000000000eb5000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000000\n// replacementPattern:\n// 0x000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n// staticTarget:\n// 0x0000000000000000000000000000000000000000\n// staticExtradata:\n// 0x\n// paymentToken:\n// 0x0000000000000000000000000000000000000000\n// basePrice:\n// 6000000000000000000\n// extra:\n// 0\n// listingTime:\n// 1645298828\n// expirationTime:\n// 1645903716\n// salt:\n// 87906966303110818969546189067137492865825614986988195802067881988151729727179\n// nonce:\n// 0\n// basePrice: \"6000000000000000000\"\n// calldata: \"0xfb16a595000000000000000000000000afac92864611c564e7fa1a6c6d07b45807536943000000000000000000000000000000000000000000000000000000000000000000000000000000000000000079fcdef22feed20eddacbb2587640e45491b757f0000000000000000000000000000000000000000000000000000000000000eb5000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000000\"\n// exchange: \"0x7f268357a8c2552623316e2562d90e642bb538e5\"\n// expirationTime: \"1645903716\"\n// extra: \"0\"\n// feeMethod: 1\n// feeRecipient: \"0x5b3256965e7c3cf26e11fcaf296dfc8807c01073\"\n// howToCall: 1\n// listingTime: \"1645298816\"\n// maker: \"0xafac92864611c564e7fa1a6c6d07b45807536943\"\n// makerProtocolFee: \"0\"\n// makerReferrerFee: \"0\"\n// makerRelayerFee: \"500\"\n// metadata: {asset: {id: \"3765\", address: \"0x79fcdef22feed20eddacbb2587640e45491b757f\"}, schema: \"ERC721\"}\n// nonce: 0\n// paymentToken: \"0x0000000000000000000000000000000000000000\"\n// quantity: \"1\"\n// r: \"0x0c70bd3052b0da178141b84e7bdbe511acc5f7f601281850cd5f93f145c9bbb5\"\n// replacementPattern: \"0x000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n// s: \"0x7a2bf43b7b616073bf2486d2890b674f9587f68f59a84e4d7fff55842bbe9b60\"\n// saleKind: 0\n// salt: \"87577974536160270209585191401103724053896633202437364720132507693990122512257\"\n// side: 1\n// staticExtradata: \"0x\"\n// staticTarget: \"0x0000000000000000000000000000000000000000\"\n// taker: \"0x0000000000000000000000000000000000000000\"\n// takerProtocolFee: \"0\"\n// takerRelayerFee: \"0\"\n// target: \"0xbaf2127b49fc93cbca6269fade0f7f31df4c88a7\"\n// v: 28","map":{"version":3,"names":["WyvernProtocol","HowToCall","Network","ERC721Schema","ethABI","ethUtil","isValidAddress","parseEther","BigNumber","axios","_","OPENSEA_URL","X_API_KEY","WyvernContract","WYVERN_CONTRACT","MIN_EXPIRATION_SECONDS","ORDER_MATCHING_LATENCY_SECONDS","NULL_ADDRESS","OPENSEA_FEE_RECIPIENT","NULL_BLOCK_HASH","INVERSE_BASIS_POINT","DEFAULT_BUYER_FEE_BASIS_POINTS","DEFAULT_SELLER_FEE_BASIS_POINTS","OPENSEA_SELLER_BOUNTY_BASIS_POINTS","DEFAULT_MAX_BOUNTY","STATIC_CALL_TX_ORIGIN_ADDRESS","MERKLE_VALIDATOR_MAINNET","mainnetWyvernConfigByNetwork","wyvernExchangeContractAddress","wyvernProxyRegistryContractAddress","wyvernTokenTransferProxyContractAddress","OrderTypesEIP712","EIP712Domain","name","type","Order","EIP_712_WYVERN_DOMAIN_NAME","EIP_712_WYVERN_DOMAIN_VERSION","validateAndFormatWalletAddress","address","toLowerCase","tokenFromJSON","token","fromJSON","symbol","decimals","imageUrl","image_url","ethPrice","eth_price","usdPrice","usd_price","merkleValidatorByNetwork","main","rinkeby","MERKLE_VALIDATOR_RINKEBY","orderFromJSON","order","createdDate","Date","created_date","hash","order_hash","cancelledOrFinalized","cancelled","finalized","markedInvalid","marked_invalid","metadata","quantity","exchange","makerAccount","maker","takerAccount","taker","makerRelayerFee","maker_relayer_fee","takerRelayerFee","taker_relayer_fee","makerProtocolFee","maker_protocol_fee","takerProtocolFee","taker_protocol_fee","makerReferrerFee","maker_referrer_fee","waitingForBestCounterOrder","fee_recipient","feeMethod","fee_method","feeRecipientAccount","feeRecipient","side","saleKind","sale_kind","target","howToCall","how_to_call","calldata","replacementPattern","replacement_pattern","staticTarget","static_target","staticExtradata","static_extradata","paymentToken","payment_token","basePrice","base_price","extra","currentBounty","current_bounty","currentPrice","current_price","createdTime","Math","round","getTime","listingTime","listing_time","expirationTime","expiration_time","salt","v","parseInt","r","s","paymentTokenContract","payment_token_contract","undefined","asset","assetBundle","asset_bundle","estimateCurrentPrice","orderFromGolomJSON","created","orderData","data","contract_address","id","token_id","schema","hex","valid","_getTimeParameters","expirationTimestamp","listingTimestamp","minExpirationTimestamp","now","minListingTimestamp","Error","toString","encodeCall","abi","parameters","inputTypes","inputs","map","i","methodID","encode","rawEncode","slice","Buffer","concat","encodeDefaultCall","input","kind","generateDefaultValue","value","encodeSell","validatorAddress","transfer","functions","checkAndTransfer","defaultCall","pattern","encodeReplacementPattern","encodeBuy","replaceables","filter","ownerInputs","length","e","console","error","getOrderHash","orderWithStringTypes","toFixed","getOrderHashHex","makeMatchingOrder","accountAddress","recipientAddress","platform","computeOrderParams","shouldValidate","times","PlatformType","Opensea","GOLOM_FEE_RECIPIENT","matchingOrder","generatePseudoRandomSalt","assignOrdersToSides","isSellOrder","buy","sell","_getMetadata","referrerAddress","referrer","substr","_correctGasAmount","estimation","ceil","_getWyvernProtocolForOrder","useReadOnly","wyvern2_2ConfigByNetwork","_wyvern2_2ProtocolReadOnly","_wyvern2_2Protocol","_wyvernProtocolReadOnly","_wyvernProtocol","getCurrentPrice","wyvernExchange","methods","calculateCurrentPrice_","call","secondsToBacktrack","shouldRoundUp","minus","exactPrice","diff","dividedBy","plus","_getRequiredAmountForTakingSellOrder","estimatedPrice","maxPrice","max","feePercentage","div","fee","_atomicMatch","txnData","from","args","log","atomicMatchMethod","atomicMatch_","then","res","jsonToOrder","golomOrder","tokenId","contractAddress","String","fulfillOrder","provider","info","isValid","validateOrder","getWyvernAsset","assetFromFields","ID","Quantity","Address","tokenAddress","Name","computeFees","extraBountyBasisPoints","openseaBuyerFeeBasisPoints","openseaSellerFeeBasisPoints","devBuyerFeeBasisPoints","devSellerFeeBasisPoints","transferFee","transferFeeTokenAddress","maxTotalBountyBPS","sellerBountyBasisPoints","bountyTooLarge","errorMessage","totalBuyerFeeBasisPoints","totalSellerFeeBasisPoints","_getPriceParameters","orderSide","startAmount","endAmount","englishAuctionReservePrice","priceDiff","reservePrice","_validateFees","maxFeePercent","_getSellFeeParameters","waitForHighestBid","StaticCheckTxOrigin","constant","outputs","payable","stateMutability","anonymous","indexed","getMethod","methodAbi","find","x","_getStaticCallTargetAndExtraData","useTxnOriginStaticCall","assetContractFromJSON","assetContract","description","assetContract_type","schemaName","schema_name","tokenSymbol","buyerFeeBasisPoints","buyer_fee_basis_points","sellerFeeBasisPoints","seller_fee_basis_points","opensea_buyer_fee_basis_points","opensea_seller_fee_basis_points","dev_buyer_fee_basis_points","dev_seller_fee_basis_points","externalLink","external_link","wikiLink","wiki_link","collectionFromJSON","collection","slug","editors","hidden","featured","featuredImageUrl","featured_image_url","displayData","display_data","paymentTokens","payment_tokens","payoutAddress","payout_address","largeImageUrl","large_image_url","stats","traitStats","traits","external_url","wiki_url","userFromJSON","user","username","accountFromJSON","account","config","profileImgUrl","profile_img_url","transactionFromJSON","transaction","fromAccount","from_account","toAccount","to_account","modifiedDate","modified_date","transactionHash","transaction_hash","transactionIndex","transaction_index","blockNumber","block_number","blockHash","block_hash","timestamp","assetEventFromJSON","assetEvent","eventType","event_type","eventTimestamp","event_timestamp","auctionType","auction_type","totalPrice","total_price","assetFromJSON","isAnimated","endsWith","isSvg","asset_contract","owner","orders","sellOrders","sell_orders","buyOrders","buy_orders","isPresale","is_presale","image_preview_url","imagePreviewUrl","imageUrlOriginal","image_original_url","imageUrlThumbnail","image_thumbnail_url","openseaLink","permalink","numSales","num_sales","lastSale","last_sale","backgroundColor","background_color","transfer_fee","transferFeePaymentToken","transfer_fee_payment_token","o","getAsset","_makeSellOrder","paymentTokenAddress","buyerAddress","openSeaAsset","quantityBN","wyAsset","GOLOM_DEFAULT_FEES","fees","orderSaleKind","DelegateCall","Call","validateOrderParams","sellValid","validateOrderParameters_","validateOrder_","message","code","parseSignatureHex","signature","validVParamValues","ecSignatureRSV","_parseSignatureHexAsRSV","includes","ecSignatureVRS","_parseSignatureHexAsVRS","signatureHex","signatureBuffer","toBuffer","ecSignature","bufferToHex","fromRpcSig","personalSignAsync","signerAddress","Promise","resolve","reject","callback","err","result","sendAsync","method","params","signTypedDataAsync","stringified","JSON","stringify","_authorizeOrder","nonce","orderForSigning","types","EIP_712_ORDER_TYPES","domain","version","chainId","verifyingContract","primaryType","orderToJSON","asJSON","postOrder","retries","post","headers","orderToGolomJSON","prefixed_hash","validateAndPostOrder","cancelOSOrder","cancelOrder_","createSellOrder","buyerEmail","hashedOrder","Number","nonces","orderWithSignature"],"sources":["/Users/romanrakhlin/Dropbox/Mac/Desktop/opensea-exploit/src/opensea-sdk/opensea.js"],"sourcesContent":["// Wyvern\nimport WyvernProtocol from \"wyvern-js\";\nimport { HowToCall, Network } from \"wyvern-js/lib/types\";\nimport { ERC721Schema } from \"./WyvernSchema\";\n\n// Ethereum\nimport * as ethABI from \"ethereumjs-abi\";\nimport * as ethUtil from \"ethereumjs-util\";\nimport isValidAddress from \"ethereumjs-util\";\nimport { parseEther } from \"@ethersproject/units\";\nimport BigNumber from \"bignumber.js\";\n\n// Other\nimport axios from \"axios\";\nimport * as _ from \"lodash\";\n\n// Constants\nimport { OPENSEA_URL, X_API_KEY } from \"./Constants\";\n\n// Contracts\nimport { WyvernContract, WYVERN_CONTRACT } from \"./Contracts\";\n\nconst MIN_EXPIRATION_SECONDS = 10;\nconst ORDER_MATCHING_LATENCY_SECONDS = 60 * 60 * 24 * 7;\nconst NULL_ADDRESS = WyvernProtocol.NULL_ADDRESS;\nconst OPENSEA_FEE_RECIPIENT = \"0x5b3256965e7c3cf26e11fcaf296dfc8807c01073\";\nconst NULL_BLOCK_HASH = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\nconst INVERSE_BASIS_POINT = 10000;\nconst DEFAULT_BUYER_FEE_BASIS_POINTS = 0;\nconst DEFAULT_SELLER_FEE_BASIS_POINTS = 250;\nconst OPENSEA_SELLER_BOUNTY_BASIS_POINTS = 250; // default 1 % we are using 2.5%\nconst DEFAULT_MAX_BOUNTY = DEFAULT_SELLER_FEE_BASIS_POINTS;\nconst STATIC_CALL_TX_ORIGIN_ADDRESS =\n  \"0xbff6ade67e3717101dd8d0a7f3de1bf6623a2ba8\";\nconst MERKLE_VALIDATOR_MAINNET = \"0xbaf2127b49fc93cbca6269fade0f7f31df4c88a7\";\n\n// MAIN FUNCTIONALITY\nconst mainnetWyvernConfigByNetwork = {\n    wyvernExchangeContractAddress: \"0x7be8076f4ea4a4ad08075c2508e481d6c946d12b\",\n    wyvernProxyRegistryContractAddress: \"0xa5409ec958c83c3f309868babaca7c86dcb077c1\",\n    wyvernTokenTransferProxyContractAddress: \"0xe5c783ee536cf5e63e792988335c4255169be4e1\"\n};\n\nconst OrderTypesEIP712 = {\n    EIP712Domain: [\n        { name: \"name\", type: \"string\" },\n        { name: \"version\", type: \"string\" },\n        { name: \"chainId\", type: \"uint256\" },\n        { name: \"verifyingContract\", type: \"address\" }\n    ],\n    Order: [\n        { name: \"maker\", type: \"address\" },\n        { name: \"exchange\", type: \"address\" },\n        { name: \"taker\", type: \"address\" },\n        { name: \"makerRelayerFee\", type: \"uint256\" },\n        { name: \"takerRelayerFee\", type: \"uint256\" },\n        { name: \"makerProtocolFee\", type: \"uint256\" },\n        { name: \"takerProtocolFee\", type: \"uint256\" },\n        { name: \"feeRecipient\", type: \"address\" },\n        { name: \"feeMethod\", type: \"uint8\" },\n        { name: \"side\", type: \"uint8\" },\n        { name: \"saleKind\", type: \"uint8\" },\n        { name: \"target\", type: \"address\" },\n        { name: \"howToCall\", type: \"uint8\" },\n        { name: \"calldata\", type: \"bytes\" },\n        { name: \"replacementPattern\", type: \"bytes\" },\n        { name: \"staticTarget\", type: \"address\" },\n        { name: \"staticExtradata\", type: \"bytes\" },\n        { name: \"paymentToken\", type: \"address\" },\n        { name: \"basePrice\", type: \"uint256\" },\n        { name: \"extra\", type: \"uint256\" },\n        { name: \"listingTime\", type: \"uint256\" },\n        { name: \"expirationTime\", type: \"uint256\" },\n        { name: \"salt\", type: \"uint256\" },\n        { name: \"nonce\", type: \"uint256\" }\n    ]\n};\n\nexport const EIP_712_WYVERN_DOMAIN_NAME = \"Wyvern Exchange Contract\";\nexport const EIP_712_WYVERN_DOMAIN_VERSION = \"2.3\";\nfunction validateAndFormatWalletAddress(address) {\n  return address.toLowerCase();\n}\n\nexport const tokenFromJSON = (token) => {\n  const fromJSON = {\n    name: token.name,\n    symbol: token.symbol,\n    decimals: token.decimals,\n    address: token.address,\n    imageUrl: token.image_url,\n    ethPrice: token.eth_price,\n    usdPrice: token.usd_price,\n  };\n\n  return fromJSON;\n};\nexport const merkleValidatorByNetwork = {\n  main: MERKLE_VALIDATOR_MAINNET,\n  rinkeby: MERKLE_VALIDATOR_RINKEBY,\n};\nexport const orderFromJSON = (order) => {\n  const createdDate = new Date(`${order.created_date}Z`);\n  const fromJSON = {\n    hash: order.order_hash || order.hash,\n    cancelledOrFinalized: order.cancelled || order.finalized,\n    markedInvalid: order.marked_invalid,\n    metadata: order.metadata,\n    quantity: new BigNumber(order.quantity || 1),\n    exchange: order.exchange,\n    makerAccount: order.maker,\n    takerAccount: order.taker,\n    // Use string address to conform to Wyvern Order schema\n    maker: order.maker.address,\n    taker: order.taker.address,\n    makerRelayerFee: new BigNumber(order.maker_relayer_fee),\n    takerRelayerFee: new BigNumber(order.taker_relayer_fee),\n    makerProtocolFee: new BigNumber(order.maker_protocol_fee),\n    takerProtocolFee: new BigNumber(order.taker_protocol_fee),\n    makerReferrerFee: new BigNumber(order.maker_referrer_fee || 0),\n    waitingForBestCounterOrder: order.fee_recipient.address == NULL_ADDRESS,\n    feeMethod: order.fee_method,\n    feeRecipientAccount: order.fee_recipient,\n    feeRecipient: order.fee_recipient.address,\n    side: order.side,\n    saleKind: order.sale_kind,\n    target: order.target,\n    howToCall: order.how_to_call,\n    calldata: order.calldata,\n    replacementPattern: order.replacement_pattern,\n    staticTarget: order.static_target,\n    staticExtradata: order.static_extradata,\n    paymentToken: order.payment_token,\n    basePrice: new BigNumber(order.base_price),\n    extra: new BigNumber(order.extra),\n    currentBounty: new BigNumber(order.current_bounty || 0),\n    currentPrice: new BigNumber(order.current_price || 0),\n\n    createdTime: new BigNumber(Math.round(createdDate.getTime() / 1000)),\n    listingTime: new BigNumber(order.listing_time),\n    expirationTime: new BigNumber(order.expiration_time),\n\n    salt: new BigNumber(order.salt),\n    v: parseInt(order.v),\n    r: order.r,\n    s: order.s,\n\n    paymentTokenContract: order.payment_token_contract\n      ? tokenFromJSON(order.payment_token_contract)\n      : undefined,\n    asset: order.asset,\n    assetBundle: order.asset_bundle,\n  };\n\n  // Use client-side price calc, to account for buyer fee (not added by server) and latency\n  fromJSON.currentPrice = estimateCurrentPrice(fromJSON);\n  return fromJSON;\n};\n\nexport const orderFromGolomJSON = (order) => {\n  const createdDate = new Date(`${order.created}`);\n  const orderData = order.data;\n  const metadata = {\n    asset: {\n      address: order.contract_address,\n      id: order.token_id,\n    },\n    schema: \"ERC721\", // currently supporting erc721 only\n  };\n\n  const fromJSON = {\n    hash: order.hex,\n    cancelledOrFinalized: false,\n    markedInvalid: order.valid,\n    metadata,\n    quantity: new BigNumber(1),\n    exchange: orderData.exchange,\n    // Use string address to conform to Wyvern Order schema\n    maker: orderData.maker,\n    taker: orderData.taker,\n    makerRelayerFee: new BigNumber(orderData.makerRelayerFee),\n    takerRelayerFee: new BigNumber(orderData.takerRelayerFee),\n    makerProtocolFee: new BigNumber(orderData.makerProtocolFee),\n    takerProtocolFee: new BigNumber(orderData.takerProtocolFee),\n    makerReferrerFee: new BigNumber(0), // need to explore this field more\n    waitingForBestCounterOrder: orderData.feeRecipient == NULL_ADDRESS,\n    feeMethod: orderData.feeMethod,\n    feeRecipient: orderData.feeRecipient,\n    side: orderData.side,\n    saleKind: orderData.saleKind,\n    target: orderData.target,\n    howToCall: orderData.howToCall,\n    calldata: orderData.calldata,\n    replacementPattern: orderData.replacementPattern,\n    staticTarget: orderData.staticTarget,\n    staticExtradata: orderData.staticExtradata,\n    paymentToken: orderData.paymentToken,\n    basePrice: new BigNumber(orderData.basePrice),\n    extra: new BigNumber(orderData.extra),\n    currentBounty: new BigNumber(0),\n    currentPrice: new BigNumber(0),\n    createdTime: new BigNumber(Math.round(createdDate.getTime() / 1000)),\n    listingTime: new BigNumber(orderData.listingTime),\n    expirationTime: new BigNumber(orderData.expirationTime),\n    salt: new BigNumber(orderData.salt),\n    v: parseInt(orderData.v),\n    r: orderData.r,\n    s: orderData.s,\n    asset: order.asset,\n  };\n\n  // Use client-side price calc, to account for buyer fee (not added by server) and latency\n  fromJSON.currentPrice = estimateCurrentPrice(fromJSON);\n  return fromJSON;\n};\nconst _getTimeParameters = (\n  expirationTimestamp,\n  listingTimestamp,\n  waitingForBestCounterOrder = false\n) => {\n  // Validation\n  const minExpirationTimestamp = Math.round(\n    Date.now() / 1000 + MIN_EXPIRATION_SECONDS\n  );\n  const minListingTimestamp = Math.round(Date.now() / 1000);\n  if (\n    expirationTimestamp != 0 &&\n    expirationTimestamp < minExpirationTimestamp\n  ) {\n    throw new Error(\n      `Expiration time must be at least ${MIN_EXPIRATION_SECONDS} seconds from now, or zero (non-expiring).`\n    );\n  }\n  if (listingTimestamp && listingTimestamp < minListingTimestamp) {\n    throw new Error(\"Listing time cannot be in the past.\");\n  }\n  if (\n    listingTimestamp &&\n    expirationTimestamp != 0 &&\n    listingTimestamp >= expirationTimestamp\n  ) {\n    throw new Error(\"Listing time must be before the expiration time.\");\n  }\n  if (waitingForBestCounterOrder && expirationTimestamp == 0) {\n    throw new Error(\"English auctions must have an expiration time.\");\n  }\n  if (waitingForBestCounterOrder && listingTimestamp) {\n    throw new Error(`Cannot schedule an English auction for the future.`);\n  }\n  if (parseInt(expirationTimestamp.toString()) != expirationTimestamp) {\n    throw new Error(`Expiration timestamp must be a whole number of seconds`);\n  }\n\n  if (waitingForBestCounterOrder) {\n    listingTimestamp = expirationTimestamp;\n    // Expire one week from now, to ensure server can match it\n    // Later, this will expire closer to the listingTime\n    expirationTimestamp = expirationTimestamp + ORDER_MATCHING_LATENCY_SECONDS;\n  } else {\n    // Small offset to account for latency\n    listingTimestamp = listingTimestamp || Math.round(Date.now() / 1000 - 100);\n  }\n\n  return {\n    listingTime: BigNumber(listingTimestamp),\n    expirationTime: BigNumber(expirationTimestamp),\n  };\n};\nexport const encodeCall = (abi, parameters) => {\n  const inputTypes = abi.inputs.map((i) => i.type);\n  let id = ethABI.methodID(abi.name, inputTypes);\n  let encode = ethABI.rawEncode(inputTypes.slice(0, 3), parameters.slice(0, 3));\n\n  return (\"0x\" + Buffer.concat([id, encode]).toString(\"hex\"));\n};\nconst encodeDefaultCall = (abi, address) => {\n  const parameters = abi.inputs.map((input) => {\n    switch (input.kind) {\n      case \"replaceable\":\n        return WyvernProtocol.generateDefaultValue(input.type);\n      case \"owner\":\n        return address;\n      case \"asset\":\n      default:\n        return input.value;\n    }\n  });\n\n  return encodeCall(abi, parameters);\n};\nconst encodeSell = (schema, asset, address, validatorAddress) => {\n  const transfer =\n    validatorAddress && schema.functions.checkAndTransfer\n      ? schema.functions.checkAndTransfer(asset, validatorAddress)\n      : schema.functions.transfer(asset);\n  //   const transfer = schema.functions.transfer(asset);\n\n  let defaultCall = encodeDefaultCall(transfer, address)\n  let pattern = WyvernProtocol.encodeReplacementPattern(transfer)\n\n  return {\n    target: transfer.target,\n    calldata: defaultCall,\n    replacementPattern: pattern\n  };\n};\n\nconst encodeBuy = (schema, asset, address, validatorAddress) => {\n  //   const transfer = schema.functions.transfer(asset);\n  const transfer =\n    validatorAddress && schema.functions.checkAndTransfer\n      ? schema.functions.checkAndTransfer(asset, validatorAddress)\n      : schema.functions.transfer(asset);\n  const replaceables = transfer.inputs.filter((i) => i.kind === \"replaceable\");\n  const ownerInputs = transfer.inputs.filter((i) => i.kind === \"owner\");\n\n  // Validate\n  if (replaceables.length !== 1) {\n    throw new Error(\n      \"Only 1 input can match transfer destination, but instead \" +\n        replaceables.length +\n        \" did\"\n    );\n  }\n\n  // Compute calldata\n  const parameters = transfer.inputs.map((input) => {\n    switch (input.kind) {\n      case \"replaceable\":\n        return address;\n      case \"owner\":\n        return WyvernProtocol.generateDefaultValue(input.type);\n      default:\n        try {\n          return input.value.toString();\n        } catch (e) {\n          console.error(schema);\n          console.error(asset);\n          throw e;\n        }\n    }\n  });\n  const calldata = encodeCall(transfer, parameters);\n\n  // Compute replacement pattern\n  let replacementPattern = \"0x\";\n  if (ownerInputs.length > 0) {\n    replacementPattern = WyvernProtocol.encodeReplacementPattern(\n      transfer,\n      \"owner\"\n    );\n  }\n\n  return {\n    target: transfer.target,\n    calldata,\n    replacementPattern,\n  };\n};\n\n// \"metadata\": {\n//     \"asset\": {\n//         \"id\": \"5934\",\n//         \"address\": \"0x66fca7555cd481545a5e66ba9a2bec1e256f98e7\"\n//     },\n//     \"schema\": \"ERC721\"\n// },\nfunction getOrderHash(order) {\n  const orderWithStringTypes = {\n    ...order,\n    maker: order.maker.toLowerCase(),\n    taker: order.taker.toLowerCase(),\n    feeRecipient: order.feeRecipient.toLowerCase(),\n    side: order.side.toString(),\n    saleKind: order.saleKind.toString(),\n    howToCall: order.howToCall.toString(),\n    feeMethod: order.feeMethod.toString(),\n    makerRelayerFee: 250.0.toFixed(),\n    takerRelayerFee: 0.0.toFixed(),\n    basePrice: 0.0.toFixed(),\n    extra: 0.0.toFixed()\n  };\n  return WyvernProtocol.getOrderHashHex(orderWithStringTypes);\n}\nfunction makeMatchingOrder({\n  order,\n  accountAddress,\n  recipientAddress,\n  platform,\n}) {\n  accountAddress = validateAndFormatWalletAddress(accountAddress);\n  recipientAddress = validateAndFormatWalletAddress(recipientAddress);\n  const computeOrderParams = () => {\n    const shouldValidate = order.target === merkleValidatorByNetwork.main;\n    if (\"asset\" in order.metadata) {\n      const schema = ERC721Schema; // currently supporting ERC721 only\n      return order.side == 0\n        ? encodeSell(\n            schema,\n            order.metadata.asset,\n            recipientAddress,\n            shouldValidate ? order.target : undefined\n          )\n        : encodeBuy(\n            schema,\n            order.metadata.asset,\n            recipientAddress,\n            shouldValidate ? order.target : undefined\n          );\n    } else {\n      throw new Error(\"Invalid order metadata\");\n    }\n  };\n\n  const { target, calldata, replacementPattern } = computeOrderParams();\n  const times = _getTimeParameters(0);\n  // Compat for matching buy orders that have fee recipient still on them\n  const feeRecipient =\n    order.feeRecipient == NULL_ADDRESS\n      ? platform == PlatformType.Opensea\n        ? OPENSEA_FEE_RECIPIENT\n        : GOLOM_FEE_RECIPIENT\n      : NULL_ADDRESS;\n  const matchingOrder = {\n    exchange: order.exchange,\n    maker: accountAddress,\n    taker: order.maker,\n    quantity: order.quantity,\n    makerRelayerFee: order.makerRelayerFee,\n    takerRelayerFee: order.takerRelayerFee,\n    makerProtocolFee: order.makerProtocolFee,\n    takerProtocolFee: order.takerProtocolFee,\n    makerReferrerFee: order.makerReferrerFee,\n    waitingForBestCounterOrder: false,\n    feeMethod: order.feeMethod,\n    feeRecipient,\n    side: (order.side + 1) % 2,\n    saleKind: 0, // 0 fixed price 1 ducch aucion\n    target,\n    howToCall: order.howToCall,\n    calldata,\n    replacementPattern,\n    staticTarget: NULL_ADDRESS,\n    staticExtradata: \"0x\",\n    paymentToken: order.paymentToken,\n    basePrice: order.basePrice,\n    extra: BigNumber(0),\n    listingTime: times.listingTime,\n    expirationTime: times.expirationTime,\n    salt: WyvernProtocol.generatePseudoRandomSalt(),\n    metadata: order.metadata,\n  };\n\n  return matchingOrder;\n}\nfunction assignOrdersToSides(order, matchingOrder) {\n  const isSellOrder = order.side == 1;\n\n  let buy;\n  let sell;\n  if (!isSellOrder) {\n    buy = order;\n    sell = {\n      ...matchingOrder,\n      v: buy.v,\n      r: buy.r,\n      s: buy.s,\n    };\n  } else {\n    sell = order;\n    buy = {\n      ...matchingOrder,\n      v: sell.v,\n      r: sell.r,\n      s: sell.s,\n    };\n  }\n\n  return { buy, sell };\n}\nconst _getMetadata = (order, referrerAddress) => {\n  const referrer = referrerAddress || order.metadata.referrerAddress;\n  if (referrer && isValidAddress(referrer)) {\n    return `0x000000000000000000000000${referrer.substr(2)}`;\n  }\n  return undefined;\n};\nconst _correctGasAmount = (estimation) => {\n  return Math.ceil(estimation * 1.01);\n};\nfunction _getWyvernProtocolForOrder(order, useReadOnly) {\n  if (\n    order.exchange ===\n    wyvern2_2ConfigByNetwork.main.wyvernExchangeContractAddress\n  ) {\n    return useReadOnly\n      ? this._wyvern2_2ProtocolReadOnly\n      : this._wyvern2_2Protocol;\n  }\n  return useReadOnly ? this._wyvernProtocolReadOnly : this._wyvernProtocol;\n}\n/**\n * Gets the price for the order using the contract\n * @param order The order to calculate the price for\n */\nasync function getCurrentPrice(order, wyvernExchange) {\n  const currentPrice = await wyvernExchange.methods\n    .calculateCurrentPrice_(\n      [\n        order.exchange,\n        order.maker,\n        order.taker,\n        order.feeRecipient,\n        order.target,\n        order.staticTarget,\n        order.paymentToken,\n      ],\n      [\n        order.makerRelayerFee.toFixed(),\n        order.takerRelayerFee.toFixed(),\n        order.makerProtocolFee.toFixed(),\n        order.takerProtocolFee.toFixed(),\n        order.basePrice.toFixed(),\n        order.extra.toFixed(),\n        order.listingTime.toFixed(),\n        order.expirationTime.toFixed(),\n        order.salt.toFixed(),\n      ],\n      order.feeMethod,\n      order.side,\n      order.saleKind,\n      order.howToCall,\n      order.calldata,\n      order.replacementPattern,\n      order.staticExtradata\n    )\n    .call();\n  return currentPrice;\n}\n/**\n * Estimates the price of an order\n * @param order The order to estimate price on\n * @param secondsToBacktrack The number of seconds to subtract on current time,\n *  to fix race conditions\n * @param shouldRoundUp Whether to round up fractional wei\n */\nexport function estimateCurrentPrice(\n  order,\n  secondsToBacktrack = 30,\n  shouldRoundUp = false\n) {\n  // round up should be enabled\n  let { basePrice, listingTime, expirationTime, extra } = order;\n  const { side, takerRelayerFee, saleKind } = order;\n\n  const now = new BigNumber(Math.round(Date.now() / 1000)).minus(\n    secondsToBacktrack\n  );\n  basePrice = new BigNumber(basePrice);\n  listingTime = new BigNumber(listingTime);\n  expirationTime = new BigNumber(expirationTime);\n  extra = new BigNumber(extra);\n\n  let exactPrice = basePrice;\n  // saleKind 0 : Fixed price 1: Duction acution\n  if (saleKind === 0) {\n    // Do nothing, price is correct\n  } else if (saleKind === 1) {\n    const diff = extra\n      .times(now.minus(listingTime))\n      .dividedBy(expirationTime.minus(listingTime));\n    // side 0 : buy 1: sell\n    exactPrice =\n      side == 1\n        ? /* Sell-side - start price: basePrice. End price: basePrice - extra. */\n          basePrice.minus(diff)\n        : /* Buy-side - start price: basePrice. End price: basePrice + extra. */\n          basePrice.plus(diff);\n  }\n\n  // Add taker fee only for buyers\n  if (side === 1 && !order.waitingForBestCounterOrder) {\n    // Buyer fee increases sale price\n    exactPrice = exactPrice.times(+takerRelayerFee / INVERSE_BASIS_POINT + 1);\n  }\n  return shouldRoundUp ? exactPrice.ceil() : exactPrice;\n}\nasync function _getRequiredAmountForTakingSellOrder(sell, wyvernExchange) {\n  const currentPrice = await getCurrentPrice(sell, wyvernExchange);\n  const estimatedPrice = estimateCurrentPrice(sell);\n\n  const maxPrice = BigNumber.max(currentPrice, estimatedPrice);\n\n  // TODO Why is this not always a big number?\n  sell.takerRelayerFee = BigNumber(sell.takerRelayerFee);\n  const feePercentage = sell.takerRelayerFee.div(INVERSE_BASIS_POINT);\n  const fee = feePercentage.times(maxPrice);\n  return fee.plus(maxPrice); // use .ceil()\n}\n\nasync function _atomicMatch({\n  buy,\n  sell,\n  accountAddress,\n  wyvernExchange,\n  metadata = NULL_BLOCK_HASH,\n}) {\n  let value;\n\n  if (buy.paymentToken == NULL_ADDRESS) {\n    value = await _getRequiredAmountForTakingSellOrder(sell, wyvernExchange);\n  }\n\n  const txnData = { from: accountAddress, value };\n\n  const args = [\n    [\n      buy.exchange,\n      buy.maker,\n      buy.taker,\n      buy.feeRecipient,\n      buy.target,\n      buy.staticTarget,\n      buy.paymentToken,\n      sell.exchange,\n      sell.maker,\n      sell.taker,\n      sell.feeRecipient,\n      sell.target,\n      sell.staticTarget,\n      sell.paymentToken,\n    ],\n    [\n      250.0.toString(),\n      0.0.toString(),\n      buy.makerProtocolFee.toString(),\n      buy.takerProtocolFee.toString(),\n      0.0.toString(),\n      buy.extra.toString(),\n      buy.listingTime.toString(),\n      buy.expirationTime.toString(),\n      buy.salt.toString(),\n      250.0.toString(),\n      0.0.toString(),\n      sell.makerProtocolFee.toString(),\n      sell.takerProtocolFee.toString(),\n      0.0.toString(),\n      0.0.toString(),\n      sell.listingTime.toString(),\n      sell.expirationTime.toString(),\n      sell.salt.toString(),\n    ],\n    [\n      buy.feeMethod,\n      buy.side,\n      buy.saleKind,\n      buy.howToCall,\n      sell.feeMethod,\n      sell.side,\n      sell.saleKind,\n      sell.howToCall,\n    ],\n    buy.calldata,\n    sell.calldata,\n    buy.replacementPattern,\n    sell.replacementPattern,\n    buy.staticExtradata,\n    sell.staticExtradata,\n    [buy.v || 0, sell.v || 0],\n    [\n      buy.r || NULL_BLOCK_HASH,\n      buy.s || NULL_BLOCK_HASH,\n      sell.r || NULL_BLOCK_HASH,\n      sell.s || NULL_BLOCK_HASH,\n      metadata,\n    ]\n  ];\n\n  // const gasEstimate = await wyvernExchange.functions.estimateGasAsync(txnData);\n\n  // txnData.gas = _correctGasAmount(gasEstimate);\n\n  console.log(wyvernExchange)\n  const atomicMatchMethod = wyvernExchange.functions.atomicMatch_(\n    args[0],\n    args[1],\n    args[2],\n    args[3],\n    args[4],\n    args[5],\n    args[6],\n    args[7],\n    args[8],\n    args[9],\n    args[10],\n    txnData\n  ).then(res => {\n    console.log(res)\n  });\n  \n  return { atomicMatchMethod, txnData };\n}\nconst jsonToOrder = (golomOrder) => {\n  // console.log(order, golomOrder);\n\n  const { data, tokenId, contractAddress, created } = golomOrder;\n  const createdDate = new Date(`${created}`);\n\n  const metadata = {\n    asset: {\n      id: String(tokenId),\n      address: contractAddress,\n    },\n    schema: \"ERC721\",\n  };\n  const fromJSON = {\n    ...data,\n    metadata,\n    quantity: new BigNumber(1),\n    makerRelayerFee: new BigNumber(data.makerRelayerFee),\n    takerRelayerFee: new BigNumber(data.takerRelayerFee),\n    makerProtocolFee: new BigNumber(data.makerProtocolFee),\n    takerProtocolFee: new BigNumber(data.takerProtocolFee),\n    makerReferrerFee: new BigNumber(data.makerReferrerFee),\n    waitingForBestCounterOrder: data.feeRecipient == NULL_ADDRESS,\n    basePrice: new BigNumber(data.basePrice),\n    extra: new BigNumber(data.extra),\n    currentBounty: new BigNumber(0),\n    currentPrice: new BigNumber(0),\n\n    createdTime: new BigNumber(Math.round(createdDate.getTime() / 1000)),\n    listingTime: new BigNumber(data.listingTime),\n    expirationTime: new BigNumber(data.expirationTime),\n    salt: new BigNumber(data.salt),\n    v: parseInt(data.v),\n    paymentTokenContract: data.payment_token_contract\n      ? tokenFromJSON(data.payment_token_contract)\n      : undefined,\n  };\n\n  // Use client-side price calc, to account for buyer fee (not added by server) and latency\n  fromJSON.currentPrice = estimateCurrentPrice(fromJSON);\n  return fromJSON;\n};\n\nasync function fulfillOrder({\n  order,\n  provider,\n  accountAddress,\n  recipientAddress,\n  referrerAddress,\n  platform = PlatformType.Opensea,\n}) {\n  console.info(\n    `Account: ${accountAddress} | Recipient: ${recipientAddress} | Referrer: ${referrerAddress}`\n  );\n  // check if valid order\n  // order = jsonToOrder(order);\n  const wyvernExchange = WyvernContract(provider);\n  const isValid = await validateOrder({\n    order,\n    accountAddress,\n    wyvernExchange,\n  });\n  const matchingOrder = makeMatchingOrder({\n    order,\n    accountAddress,\n    recipientAddress: recipientAddress,\n    platform,\n  });\n  const { buy, sell } = assignOrdersToSides(order, matchingOrder);\n  const metadata = _getMetadata(order, referrerAddress);\n  return await _atomicMatch({\n    buy,\n    sell,\n    accountAddress,\n    wyvernExchange,\n    metadata,\n  });\n}\n\nfunction getWyvernAsset(schema, asset, quantity = new BigNumber(1)) {\n  const tokenId = asset.tokenId != null ? asset.tokenId.toString() : undefined;\n  return schema.assetFromFields({\n    ID: tokenId,\n    Quantity: quantity.toString(),\n    Address: asset.tokenAddress.toLowerCase(),\n    Name: asset.name,\n  });\n}\nasync function computeFees({\n  asset,\n  side,\n  accountAddress,\n  platform,\n  extraBountyBasisPoints = 0,\n}) {\n  let openseaBuyerFeeBasisPoints = DEFAULT_BUYER_FEE_BASIS_POINTS;\n  let openseaSellerFeeBasisPoints = DEFAULT_SELLER_FEE_BASIS_POINTS;\n  let devBuyerFeeBasisPoints = 0;\n  let devSellerFeeBasisPoints = 0;\n  let transferFee = new BigNumber(0);\n  let transferFeeTokenAddress = null;\n  let maxTotalBountyBPS = DEFAULT_MAX_BOUNTY;\n\n  if (asset && platform == PlatformType.Opensea) {\n    openseaBuyerFeeBasisPoints = +asset.openseaBuyerFeeBasisPoints;\n    openseaSellerFeeBasisPoints = +asset.openseaSellerFeeBasisPoints;\n    devBuyerFeeBasisPoints = +asset.devBuyerFeeBasisPoints;\n    devSellerFeeBasisPoints = +asset.devSellerFeeBasisPoints;\n    maxTotalBountyBPS = openseaSellerFeeBasisPoints;\n  }\n\n  // Compute transferFrom fees\n  if (side == 1 && asset && platform == PlatformType.Opensea) {\n    // Server-side knowledge\n    // transferFee = asset.transferFee ? new BigNumber(asset.transferFee) : transferFee;\n    // transferFeeTokenAddress = asset.transferFeePaymentToken\n    //   ? asset.transferFeePaymentToken.address\n    //   : transferFeeTokenAddress;\n  }\n\n  // Compute bounty\n  const sellerBountyBasisPoints = side == 1 ? extraBountyBasisPoints : 0;\n\n  // Check that bounty is in range of the opensea fee\n  const bountyTooLarge =\n    sellerBountyBasisPoints + OPENSEA_SELLER_BOUNTY_BASIS_POINTS >\n    maxTotalBountyBPS;\n  if (sellerBountyBasisPoints > 0 && bountyTooLarge) {\n    let errorMessage = `Total bounty exceeds the maximum for this asset type (${\n      maxTotalBountyBPS / 100\n    }%).`;\n    if (maxTotalBountyBPS >= OPENSEA_SELLER_BOUNTY_BASIS_POINTS) {\n      errorMessage += ` Remember that OpenSea will add ${\n        OPENSEA_SELLER_BOUNTY_BASIS_POINTS / 100\n      }% for referrers with OpenSea accounts!`;\n    }\n    throw new Error(errorMessage);\n  }\n\n  return {\n    totalBuyerFeeBasisPoints:\n      openseaBuyerFeeBasisPoints + devBuyerFeeBasisPoints,\n    totalSellerFeeBasisPoints:\n      openseaSellerFeeBasisPoints + devSellerFeeBasisPoints,\n    openseaBuyerFeeBasisPoints,\n    openseaSellerFeeBasisPoints,\n    devBuyerFeeBasisPoints,\n    devSellerFeeBasisPoints,\n    sellerBountyBasisPoints,\n    transferFee,\n    transferFeeTokenAddress,\n  };\n}\n\n/**\n * Compute the `basePrice` and `extra` parameters to be used to price an order.\n * Also validates the expiration time and auction type.\n * @param tokenAddress Address of the ERC-20 token to use for trading.\n * Use the null address for ETH\n * @param expirationTime When the auction expires, or 0 if never.\n * @param startAmount The base value for the order, in the token's main units (e.g. ETH instead of wei)\n * @param endAmount The end value for the order, in the token's main units (e.g. ETH instead of wei). If unspecified, the order's `extra` attribute will be 0\n */\nasync function _getPriceParameters(\n  orderSide,\n  tokenAddress,\n  expirationTime,\n  startAmount,\n  endAmount,\n  waitingForBestCounterOrder = false,\n  englishAuctionReservePrice\n) {\n  const priceDiff = endAmount != null ? startAmount - endAmount : 0;\n  const paymentToken = tokenAddress.toLowerCase();\n  // const isEther = tokenAddress == NULL_ADDRESS;\n  // const { tokens } = await this.api.getPaymentTokens({ address: paymentToken });\n  // const token = tokens[0];\n\n  // Note: WyvernProtocol.toBaseUnitAmount(makeBigNumber(startAmount), token.decimals)\n  // will fail if too many decimal places, so special-case ether\n  // const basePrice = isEther\n  //   ? new BigNumber(parseEther(startAmount)).round()\n  //   : WyvernProtocol.toBaseUnitAmount(new BigNumber(startAmount), token.decimals);\n  const basePrice = new BigNumber(parseEther(String(startAmount)));\n  // const extra = isEther\n  //   ? new BigNumber(parseEther(priceDiff)).decimalPlaces()\n  //   : WyvernProtocol.toBaseUnitAmount(new BigNumber(priceDiff), token.decimals);\n  // console.log(basePrice, priceDiff);\n  const extra = new BigNumber(parseEther(String(priceDiff)));\n  // const reservePrice = englishAuctionReservePrice\n  //   ? isEther\n  //     ? new BigNumber(parseEther(englishAuctionReservePrice))\n  //     : WyvernProtocol.toBaseUnitAmount(new BigNumber(englishAuctionReservePrice), token.decimals)\n  //   : undefined;\n  const reservePrice = englishAuctionReservePrice\n    ? new BigNumber(parseEther(englishAuctionReservePrice))\n    : undefined;\n\n  return { basePrice, extra, paymentToken, reservePrice };\n}\nfunction _validateFees(totalBuyerFeeBasisPoints, totalSellerFeeBasisPoints) {\n  const maxFeePercent = INVERSE_BASIS_POINT / 100;\n\n  if (\n    totalBuyerFeeBasisPoints > INVERSE_BASIS_POINT ||\n    totalSellerFeeBasisPoints > INVERSE_BASIS_POINT\n  ) {\n    throw new Error(\n      `Invalid buyer/seller fees: must be less than ${maxFeePercent}%`\n    );\n  }\n\n  if (totalBuyerFeeBasisPoints < 0 || totalSellerFeeBasisPoints < 0) {\n    throw new Error(`Invalid buyer/seller fees: must be at least 0%`);\n  }\n}\nfunction _getSellFeeParameters(\n  totalBuyerFeeBasisPoints,\n  totalSellerFeeBasisPoints,\n  waitForHighestBid,\n  sellerBountyBasisPoints = 0,\n  platform\n) {\n  // just making basic check if fee is less than 100% and not negative\n  _validateFees(totalBuyerFeeBasisPoints, totalSellerFeeBasisPoints);\n  // Use buyer as the maker when it's an English auction, so Wyvern sets prices correctly\n  const feeRecipient = waitForHighestBid ? NULL_ADDRESS : OPENSEA_FEE_RECIPIENT;\n\n  // Swap maker/taker fees when it's an English auction,\n  // since these sell orders are takers not makers\n  const makerRelayerFee = waitForHighestBid\n    ? new BigNumber(totalBuyerFeeBasisPoints)\n    : new BigNumber(totalSellerFeeBasisPoints);\n  const takerRelayerFee = waitForHighestBid\n    ? new BigNumber(totalSellerFeeBasisPoints)\n    : new BigNumber(totalBuyerFeeBasisPoints);\n\n  return {\n    makerRelayerFee,\n    takerRelayerFee,\n    makerProtocolFee: new BigNumber(0),\n    takerProtocolFee: new BigNumber(0),\n    makerReferrerFee: new BigNumber(sellerBountyBasisPoints),\n    feeRecipient,\n    feeMethod: 1, // 0 protocol fee ,1 split fee\n  };\n}\nconst StaticCheckTxOrigin = [\n  {\n    constant: true,\n    inputs: [],\n    name: \"succeedIfTxOriginMatchesHardcodedAddress\",\n    outputs: [],\n    payable: false,\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    constant: false,\n    inputs: [],\n    name: \"renounceOwnership\",\n    outputs: [],\n    payable: false,\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    constant: true,\n    inputs: [{ name: \"_specifiedAddress\", type: \"address\" }],\n    name: \"succeedIfTxOriginMatchesSpecifiedAddress\",\n    outputs: [],\n    payable: false,\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: \"owner\",\n    outputs: [{ name: \"\", type: \"address\" }],\n    payable: false,\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: \"isOwner\",\n    outputs: [{ name: \"\", type: \"bool\" }],\n    payable: false,\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    constant: false,\n    inputs: [{ name: \"_newHardcodedAddress\", type: \"address\" }],\n    name: \"changeHardcodedAddress\",\n    outputs: [],\n    payable: false,\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    constant: false,\n    inputs: [{ name: \"newOwner\", type: \"address\" }],\n    name: \"transferOwnership\",\n    outputs: [],\n    payable: false,\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ name: \"_hardcodedAddress\", type: \"address\" }],\n    payable: false,\n    stateMutability: \"nonpayable\",\n    type: \"constructor\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      { indexed: false, name: \"previousOwner\", type: \"address\" },\n      { indexed: false, name: \"newOwner\", type: \"address\" },\n    ],\n    name: \"OwnershipTransferred\",\n    type: \"event\",\n  },\n];\n\nexport const getMethod = (abi, name) => {\n  const methodAbi = abi.find((x) => x.type == \"function\" && x.name == name);\n  if (!methodAbi) {\n    throw new Error(`ABI ${name} not found`);\n  }\n  // Have to cast since there's a bug in\n  // web3 types on the 'type' field\n  return methodAbi;\n};\nasync function _getStaticCallTargetAndExtraData({ useTxnOriginStaticCall }) {\n  if (!useTxnOriginStaticCall) {\n    // While testing, we will use dummy values for mainnet. We will remove this if-statement once we have pushed the PR once and tested on Rinkeby\n    return {\n      staticTarget: NULL_ADDRESS,\n      staticExtradata: \"0x\",\n    };\n  }\n\n  if (useTxnOriginStaticCall) {\n    return {\n      staticTarget: STATIC_CALL_TX_ORIGIN_ADDRESS,\n      staticExtradata: encodeCall(\n        getMethod(\n          StaticCheckTxOrigin,\n          \"succeedIfTxOriginMatchesHardcodedAddress\"\n        ),\n        []\n      ),\n    };\n  } else {\n    // Noop - no checks\n    return {\n      staticTarget: NULL_ADDRESS,\n      staticExtradata: \"0x\",\n    };\n  }\n}\nexport const assetContractFromJSON = (assetContract) => {\n  return {\n    name: assetContract.name,\n    description: assetContract.description,\n    type: assetContract.assetContract_type,\n    schemaName: assetContract.schema_name,\n    address: assetContract.address,\n    tokenSymbol: assetContract.symbol,\n    buyerFeeBasisPoints: +assetContract.buyer_fee_basis_points,\n    sellerFeeBasisPoints: +assetContract.seller_fee_basis_points,\n    openseaBuyerFeeBasisPoints: +assetContract.opensea_buyer_fee_basis_points,\n    openseaSellerFeeBasisPoints: +assetContract.opensea_seller_fee_basis_points,\n    devBuyerFeeBasisPoints: +assetContract.dev_buyer_fee_basis_points,\n    devSellerFeeBasisPoints: +assetContract.dev_seller_fee_basis_points,\n    imageUrl: assetContract.image_url,\n    externalLink: assetContract.external_link,\n    wikiLink: assetContract.wiki_link,\n  };\n};\nexport const collectionFromJSON = (collection) => {\n  const createdDate = new Date(`${collection.created_date}Z`);\n\n  return {\n    createdDate,\n    name: collection.name,\n    description: collection.description,\n    slug: collection.slug,\n    editors: collection.editors,\n    hidden: collection.hidden,\n    featured: collection.featured,\n    featuredImageUrl: collection.featured_image_url,\n    displayData: collection.display_data,\n    paymentTokens: (collection.payment_tokens || []).map(tokenFromJSON),\n    openseaBuyerFeeBasisPoints: +collection.opensea_buyer_fee_basis_points,\n    openseaSellerFeeBasisPoints: +collection.opensea_seller_fee_basis_points,\n    devBuyerFeeBasisPoints: +collection.dev_buyer_fee_basis_points,\n    devSellerFeeBasisPoints: +collection.dev_seller_fee_basis_points,\n    payoutAddress: collection.payout_address,\n    imageUrl: collection.image_url,\n    largeImageUrl: collection.large_image_url,\n    stats: collection.stats,\n    traitStats: collection.traits,\n    externalLink: collection.external_url,\n    wikiLink: collection.wiki_url,\n  };\n};\nexport const userFromJSON = (user) => {\n  return {\n    username: user.username,\n  };\n};\n\nexport const accountFromJSON = (account) => {\n  return {\n    address: account.address,\n    config: account.config,\n    profileImgUrl: account.profile_img_url,\n    user: account.user ? userFromJSON(account.user) : null,\n  };\n};\nexport const transactionFromJSON = (transaction) => {\n  return {\n    fromAccount: accountFromJSON(transaction.from_account),\n    toAccount: accountFromJSON(transaction.to_account),\n    createdDate: new Date(`${transaction.created_date}Z`),\n    modifiedDate: new Date(`${transaction.modified_date}Z`),\n    transactionHash: transaction.transaction_hash,\n    transactionIndex: transaction.transaction_index,\n    blockNumber: transaction.block_number,\n    blockHash: transaction.block_hash,\n    timestamp: new Date(`${transaction.timestamp}Z`),\n  };\n};\n\nexport const assetEventFromJSON = (assetEvent) => {\n  return {\n    eventType: assetEvent.event_type,\n    eventTimestamp: assetEvent.event_timestamp,\n    auctionType: assetEvent.auction_type,\n    totalPrice: assetEvent.total_price,\n    transaction: assetEvent.transaction\n      ? transactionFromJSON(assetEvent.transaction)\n      : null,\n    paymentToken: assetEvent.payment_token\n      ? tokenFromJSON(assetEvent.payment_token)\n      : null,\n  };\n};\n\nexport const assetFromJSON = (asset) => {\n  const isAnimated = asset.image_url && asset.image_url.endsWith(\".gif\");\n  const isSvg = asset.image_url && asset.image_url.endsWith(\".svg\");\n  const fromJSON = {\n    tokenId: asset.token_id.toString(),\n    tokenAddress: asset.asset_contract.address,\n    name: asset.name,\n    description: asset.description,\n    owner: asset.owner,\n    assetContract: assetContractFromJSON(asset.asset_contract),\n    collection: collectionFromJSON(asset.collection),\n    orders: asset.orders ? asset.orders.map(orderFromJSON) : null,\n    sellOrders: asset.sell_orders ? asset.sell_orders.map(orderFromJSON) : null,\n    buyOrders: asset.buy_orders ? asset.buy_orders.map(orderFromJSON) : null,\n\n    isPresale: asset.is_presale,\n    // Don't use previews if it's a special image\n    imageUrl:\n      isAnimated || isSvg\n        ? asset.image_url\n        : asset.image_preview_url || asset.image_url,\n    imagePreviewUrl: asset.image_preview_url,\n    imageUrlOriginal: asset.image_original_url,\n    imageUrlThumbnail: asset.image_thumbnail_url,\n\n    externalLink: asset.external_link,\n    openseaLink: asset.permalink,\n    traits: asset.traits,\n    numSales: asset.num_sales,\n    lastSale: asset.last_sale ? assetEventFromJSON(asset.last_sale) : null,\n    backgroundColor: asset.background_color\n      ? `#${asset.background_color}`\n      : null,\n\n    transferFee: asset.transfer_fee ? new BigNumber(asset.transfer_fee) : null,\n    transferFeePaymentToken: asset.transfer_fee_payment_token\n      ? tokenFromJSON(asset.transfer_fee_payment_token)\n      : null,\n  };\n  // If orders were included, put them in sell/buy order groups\n  if (fromJSON.orders && !fromJSON.sellOrders) {\n    fromJSON.sellOrders = fromJSON.orders.filter((o) => o.side == 1);\n  }\n  if (fromJSON.orders && !fromJSON.buyOrders) {\n    fromJSON.buyOrders = fromJSON.orders.filter((o) => o.side == 0);\n  }\n  return fromJSON;\n};\n/**\n * Fetch an asset from the API, throwing if none is found\n * @param tokenAddress Address of the asset's contract\n * @param tokenId The asset's token ID, or null if ERC-20\n * @param retries Number of times to retry if the service is unavailable for any reason\n */\nasync function getAsset({ tokenAddress, tokenId }) {\n  const { data } = await axios(\n    `${OPENSEA_URL}asset/${tokenAddress}/${tokenId || 0}/`\n  );\n  return assetFromJSON(data);\n}\nasync function _makeSellOrder({\n  asset,\n  quantity,\n  accountAddress,\n  startAmount,\n  endAmount,\n  listingTime,\n  expirationTime,\n  waitForHighestBid,\n  englishAuctionReservePrice = 0,\n  paymentTokenAddress,\n  extraBountyBasisPoints, // this is for extra fee\n  buyerAddress,\n  platform,\n  openSeaAsset, // holds fee\n}) {\n  accountAddress = validateAndFormatWalletAddress(accountAddress);\n  const schema = ERC721Schema; // currently supporting ERC721 only\n  const quantityBN = new BigNumber(1);\n  const wyAsset = getWyvernAsset(schema, asset, quantityBN);\n\n  let totalSellerFeeBasisPoints = GOLOM_DEFAULT_FEES; // in bps\n  if (asset.tokenAddress == \"0xf07468ead8cf26c752c676e43c814fee9c8cf402\") {\n    totalSellerFeeBasisPoints = 0;\n  }\n  let totalBuyerFeeBasisPoints = 0;\n  let sellerBountyBasisPoints = 0;\n  // TODO: No need to fetch asset again we can use values from _token.vue directly\n  if (platform == PlatformType.Opensea) {\n    // { totalSellerFeeBasisPoints, totalBuyerFeeBasisPoints, sellerBountyBasisPoints }\n    const fees = await computeFees({\n      asset: openSeaAsset,\n      side: 1,\n      extraBountyBasisPoints,\n      platform,\n    }); // 1 for sell 0 for buy\n    totalSellerFeeBasisPoints = fees.totalSellerFeeBasisPoints;\n    totalBuyerFeeBasisPoints = fees.totalBuyerFeeBasisPoints;\n    sellerBountyBasisPoints = fees.sellerBountyBasisPoints;\n  }\n\n  const { target, calldata, replacementPattern } = encodeSell(\n    schema,\n    wyAsset,\n    accountAddress,\n    // waitForHighestBid ? undefined : merkleValidatorByNetwork.main\n    merkleValidatorByNetwork.main\n  );\n  console.log(endAmount);\n  \n  const orderSaleKind = endAmount != null && endAmount !== startAmount ? 1 : 0; // 0 fixed price 1 ducch aucion\n\n  const { basePrice, extra, paymentToken, reservePrice } =\n    await _getPriceParameters(\n      1,\n      paymentTokenAddress,\n      expirationTime,\n      startAmount,\n      endAmount,\n      waitForHighestBid,\n      englishAuctionReservePrice\n    );\n\n  const times = _getTimeParameters(\n    expirationTime,\n    listingTime,\n    waitForHighestBid\n  );\n\n  let {\n    makerRelayerFee,\n    takerRelayerFee,\n    makerProtocolFee,\n    takerProtocolFee,\n    makerReferrerFee,\n    feeRecipient,\n    feeMethod,\n  } = _getSellFeeParameters(\n    totalBuyerFeeBasisPoints,\n    totalSellerFeeBasisPoints,\n    waitForHighestBid,\n    sellerBountyBasisPoints\n  );\n  if (platform != PlatformType.Opensea) {\n    feeRecipient = GOLOM_FEE_RECIPIENT;\n  }\n\n  const { staticTarget, staticExtradata } =\n    await _getStaticCallTargetAndExtraData({\n      useTxnOriginStaticCall: waitForHighestBid,\n    });\n\n  return {\n    exchange: WYVERN_CONTRACT,\n    maker: accountAddress,\n    taker: buyerAddress, // for private listing\n    quantity: quantityBN,\n    makerRelayerFee,\n    takerRelayerFee,\n    makerProtocolFee,\n    takerProtocolFee,\n    makerReferrerFee,\n    waitingForBestCounterOrder: waitForHighestBid,\n    englishAuctionReservePrice: reservePrice\n      ? new BigNumber(reservePrice)\n      : undefined,\n    feeMethod,\n    feeRecipient,\n    side: 1,\n    saleKind: orderSaleKind,\n    target,\n    howToCall:\n      target === merkleValidatorByNetwork.main\n        ? HowToCall.DelegateCall\n        : HowToCall.Call,\n    calldata,\n    replacementPattern,\n    staticTarget,\n    staticExtradata,\n    paymentToken,\n    basePrice,\n    extra,\n    listingTime: times.listingTime,\n    expirationTime: times.expirationTime,\n    salt: WyvernProtocol.generatePseudoRandomSalt(),\n    metadata: {\n      asset: wyAsset,\n      schema: schema.name,\n    }\n  };\n}\nasync function validateOrderParams({ order, accountAddress, wyvernExchange }) {\n  // Check sell parameters\n\n  const sellValid = await wyvernExchange.functions\n  .validateOrderParameters_(\n      [\n        order.exchange,\n        order.maker,\n        order.taker,\n        order.feeRecipient,\n        order.target,\n        order.staticTarget,\n        order.paymentToken,\n      ],\n      [\n        0.001.toFixed(),\n        0.001.toFixed(),\n        order.makerProtocolFee.toFixed(),\n        order.takerProtocolFee.toFixed(),\n        0.0.toFixed(),\n        0.0.toFixed(),\n        order.listingTime.toFixed(),\n        order.expirationTime.toFixed(),\n        order.salt.toFixed(),\n      ],\n      order.feeMethod,\n      order.side,\n      order.saleKind,\n      order.howToCall,\n      order.calldata,\n      order.replacementPattern,\n      order.staticExtradata\n    );\n    // .call({ from: accountAddress });\n\n  if (!sellValid) {\n    console.error(order);\n    throw new Error(\n      `Failed to validate sell order parameters. Make sure you're on the right network!`\n    );\n  }\n  return sellValid;\n}\nasync function validateOrder({ order, accountAddress, wyvernExchange }) {\n  // Check sell parameters\n\n  const sellValid = await wyvernExchange.functions\n    .validateOrder_(\n      [\n        order.exchange,\n        order.maker,\n        order.taker,\n        order.feeRecipient,\n        order.target,\n        order.staticTarget,\n        order.paymentToken,\n      ],\n      [\n        250.0.toFixed(),\n        0.0.toFixed(),\n        order.makerProtocolFee,\n        order.takerProtocolFee,\n        0.0.toFixed(),\n        0.0.toFixed(),\n        order.listingTime,\n        order.expirationTime,\n        order.salt,\n      ],\n      order.feeMethod,\n      order.side,\n      order.saleKind,\n      order.howToCall,\n      order.calldata,\n      order.replacementPattern,\n      order.staticExtradata,\n      order.v,\n      order.r,\n      order.s\n    );\n    // .call({ from: accountAddress });\n  if (!sellValid) {\n    // eslint-disable-next-line no-throw-literal\n    throw {\n      message: new Error(\n        `Failed to validate sell order parameters. It looks like this listing is invalid.`\n      ),\n      code: \"InvalidOrder\",\n    };\n    // TODO: call order invalidate API\n  }\n  return sellValid;\n}\n// sourced from 0x.js:\n// https://github.com/ProjectWyvern/wyvern-js/blob/39999cb93ce5d80ea90b4382182d1bd4339a9c6c/src/utils/signature_utils.ts\nasync function parseSignatureHex(signature) {\n  // HACK: There is no consensus on whether the signatureHex string should be formatted as\n  // v + r + s OR r + s + v, and different clients (even different versions of the same client)\n  // return the signature params in different orders. In order to support all client implementations,\n  // we parse the signature in both ways, and evaluate if either one is a valid signature.\n  const validVParamValues = [27, 28];\n\n  const ecSignatureRSV = _parseSignatureHexAsRSV(signature);\n  if (_.includes(validVParamValues, ecSignatureRSV.v)) {\n    return ecSignatureRSV;\n  }\n\n  // For older clients\n  const ecSignatureVRS = _parseSignatureHexAsVRS(signature);\n  if (_.includes(validVParamValues, ecSignatureVRS.v)) {\n    return ecSignatureVRS;\n  }\n\n  throw new Error(\"Invalid signature\");\n\n  function _parseSignatureHexAsVRS(signatureHex) {\n    const signatureBuffer = ethUtil.toBuffer(signatureHex);\n    let v = signatureBuffer[0];\n    if (v < 27) {\n      v += 27;\n    }\n    const r = signatureBuffer.slice(1, 33);\n    const s = signatureBuffer.slice(33, 65);\n    const ecSignature = {\n      v,\n      r: ethUtil.bufferToHex(r),\n      s: ethUtil.bufferToHex(s),\n    };\n    return ecSignature;\n  }\n\n  function _parseSignatureHexAsRSV(signatureHex) {\n    const { v, r, s } = ethUtil.fromRpcSig(signatureHex);\n    const ecSignature = {\n      v,\n      r: ethUtil.bufferToHex(r),\n      s: ethUtil.bufferToHex(s),\n    };\n    return ecSignature;\n  }\n}\nasync function personalSignAsync(provider, message, signerAddress) {\n  return new Promise((resolve, reject) => {\n    const callback = async (err, signature) => {\n      if (err) reject(err);\n\n      if (signature.error) {\n        reject(signature.error.message);\n      }\n      resolve(parseSignatureHex(signature.result));\n      // // console.log(result);\n      // const d = signature.result;\n      // let v = d.slice(-2);\n      // let r = d.slice(2, -66);\n      // let s = d.slice(-66, -2);\n\n      // let actualsignature = v + r + s + '03';\n\n      // // const dhs = await this.contractInstace.methods\n      // //   .setApprovalForAll(OPERATOR_ADDRESS, true)\n      // //   .send({ from: this.metamask.metaMaskAddress });\n      // resolve(`0x${actualsignature}`);\n    };\n    // console.log(orderHex, metaMaskAddress);\n    provider.sendAsync(\n      {\n        method: \"personal_sign\",\n        params: [message, signerAddress],\n        from: signerAddress,\n      },\n      callback\n    );\n  });\n}\nexport async function signTypedDataAsync(provider, message, signerAddress) {\n  let signature;\n  console.log(signerAddress);\n  return new Promise((resolve, reject) => {\n    const callback = async (err, result) => {\n      console.log(err);\n      if (err) reject(err);\n      if (result.error) {\n        reject(result.error.message);\n      }\n      // eslint-disable-next-line prefer-promise-reject-errors\n      if (result.error) return reject(\"ERROR\", result);\n      // console.log(result);\n      // const d = result.result;\n\n      // let v = d.slice(-2);\n      // let r = d.slice(2, -66);\n      // let s = d.slice(-66, -2);\n\n      // let actualsignature = v + r + s + '03';\n      resolve(parseSignatureHex(result.result));\n    };\n    const stringified = JSON.stringify({ ...message });\n\n    try {\n      // Using sign typed data V4 works with a stringified message, used by browser providers i.e. Metamask\n      provider.sendAsync(\n        {\n          method: \"eth_signTypedData_v4\",\n          params: [signerAddress, stringified],\n          from: signerAddress,\n          id: new Date().getTime(),\n        },\n        callback\n      );\n    } catch (error) {\n      console.log(error);\n      // Fallback to normal sign typed data for node providers, without using stringified message\n      // https://github.com/coinbase/coinbase-wallet-sdk/issues/60\n      provider.sendAsync(\n        {\n          method: \"eth_signTypedData\",\n          params: [signerAddress, message],\n          from: signerAddress,\n          id: new Date().getTime(),\n        },\n        callback\n      );\n    }\n  });\n}\nasync function _authorizeOrder({ order, provider, nonce }) {\n  // 2.2 Sign order flow\n  const signerAddress = order.maker;\n  // console.log(order, nonce);\n  if (\n    order.exchange ===\n      wyvern2_2ConfigByNetwork.main.wyvernExchangeContractAddress &&\n    order.hash\n  ) {\n    const message = order.hash;\n    // v1\n    return await personalSignAsync(provider, message, signerAddress);\n  }\n  // 2.3 Sign order flow using EIP-712\n\n  // We need to manually specify each field because OS orders can contain unrelated data\n  const orderForSigning = {\n    maker: order.maker,\n    exchange: order.exchange,\n    taker: order.taker,\n    makerRelayerFee: order.makerRelayerFee.toString(),\n    takerRelayerFee: order.takerRelayerFee.toString(),\n    makerProtocolFee: order.makerProtocolFee.toString(),\n    takerProtocolFee: order.takerProtocolFee.toString(),\n    feeRecipient: order.feeRecipient,\n    feeMethod: order.feeMethod,\n    side: order.side,\n    saleKind: order.saleKind,\n    target: order.target,\n    howToCall: order.howToCall,\n    calldata: order.calldata,\n    replacementPattern: order.replacementPattern,\n    staticTarget: order.staticTarget,\n    staticExtradata: order.staticExtradata,\n    paymentToken: order.paymentToken,\n    basePrice: order.basePrice.toString(),\n    extra: order.extra.toString(),\n    listingTime: order.listingTime.toString(),\n    expirationTime: order.expirationTime.toString(),\n    salt: order.salt.toString(),\n  };\n\n  // We don't JSON.stringify as certain wallet providers sanitize this data\n  // https://github.com/coinbase/coinbase-wallet-sdk/issues/60\n  const message = {\n    types: EIP_712_ORDER_TYPES,\n    domain: {\n      name: EIP_712_WYVERN_DOMAIN_NAME,\n      version: EIP_712_WYVERN_DOMAIN_VERSION,\n      chainId: 1,\n      verifyingContract: order.exchange,\n    },\n    primaryType: \"Order\",\n    message: { ...orderForSigning, nonce },\n  };\n  const ecSignature = await signTypedDataAsync(\n    provider,\n    message,\n    signerAddress\n  );\n  return { ...ecSignature, nonce };\n}\n/**\n * Convert an order to JSON, hashing it as well if necessary\n * @param order order (hashed or unhashed)\n */\nconst orderToJSON = (order) => {\n  const asJSON = {\n    exchange: order.exchange.toLowerCase(),\n    maker: order.maker.toLowerCase(),\n    taker: order.taker.toLowerCase(),\n    makerRelayerFee: order.makerRelayerFee.toString(),\n    takerRelayerFee: order.takerRelayerFee.toString(),\n    makerProtocolFee: order.makerProtocolFee.toString(),\n    takerProtocolFee: order.takerProtocolFee.toString(),\n    makerReferrerFee: order.makerReferrerFee.toString(),\n    feeMethod: order.feeMethod,\n    feeRecipient: order.feeRecipient.toLowerCase(),\n    side: order.side,\n    saleKind: order.saleKind,\n    target: order.target.toLowerCase(),\n    howToCall: order.howToCall,\n    calldata: order.calldata,\n    replacementPattern: order.replacementPattern,\n    staticTarget: order.staticTarget.toLowerCase(),\n    staticExtradata: order.staticExtradata,\n    paymentToken: order.paymentToken.toLowerCase(),\n    quantity: order.quantity.toString(),\n    basePrice: order.basePrice.toString(),\n    englishAuctionReservePrice: order.englishAuctionReservePrice\n      ? order.englishAuctionReservePrice.toString()\n      : undefined,\n    extra: order.extra.toString(),\n    createdTime: order.createdTime ? order.createdTime.toString() : undefined,\n    listingTime: order.listingTime.toString(),\n    expirationTime: order.expirationTime.toString(),\n    salt: order.salt.toString(),\n\n    metadata: order.metadata,\n\n    v: order.v,\n    r: order.r,\n    s: order.s,\n    nonce: order.nonce,\n  };\n  return asJSON;\n};\nasync function postOrder(order, retries = 2) {\n  try {\n    const { data } = await axios.post(\n      `https://api.opensea.io/wyvern/v1/orders/post/`,\n      order,\n      {\n        headers: {\n          \"x-api-key\": X_API_KEY,\n        },\n      }\n    );\n    return data;\n  } catch (error) {\n    throw new Error(error);\n  }\n}\n/**\n * Convert an order to JSON for golom, hashing it as well if necessary\n * @param order order (hashed or unhashed)\n */\nconst orderToGolomJSON = (order) => {\n  const asJSON = {\n    exchange: order.exchange.toLowerCase(),\n    maker: { address: order.maker.toLowerCase() },\n    taker: { address: order.taker.toLowerCase() },\n    maker_relayer_fee: order.makerRelayerFee.toString(),\n    taker_relayer_fee: order.takerRelayerFee.toString(),\n    maker_protocol_fee: order.makerProtocolFee.toString(),\n    taker_protocol_fee: order.takerProtocolFee.toString(),\n    makerReferrerFee: order.makerReferrerFee.toString(),\n    fee_method: order.feeMethod,\n    fee_recipient: { address: order.feeRecipient.toLowerCase() },\n    side: order.side,\n    sale_kind: order.saleKind,\n    target: order.target.toLowerCase(),\n    how_to_call: order.howToCall,\n    calldata: order.calldata,\n    replacement_pattern: order.replacementPattern,\n    static_target: order.staticTarget.toLowerCase(),\n    static_extradata: order.staticExtradata,\n    payment_token: order.paymentToken.toLowerCase(),\n    quantity: order.quantity.toString(),\n    base_price: order.basePrice.toString(),\n    englishAuctionReservePrice: order.englishAuctionReservePrice\n      ? order.englishAuctionReservePrice.toString()\n      : undefined,\n    extra: order.extra.toString(),\n    createdTime: order.createdTime ? order.createdTime.toString() : undefined,\n    listing_time: order.listingTime.toString(),\n    expiration_time: order.expirationTime.toString(),\n    salt: order.salt.toString(),\n    metadata: order.metadata,\n    v: order.v,\n    r: order.r,\n    s: order.s,\n    prefixed_hash: order.hash,\n  };\n  return asJSON;\n};\n/**\n * Validate and post an order to the OpenSea orderbook.\n * @param order The order to post. Can either be signed by the maker or pre-approved on the Wyvern contract using approveOrder. See https://github.com/ProjectWyvern/wyvern-ethereum/blob/master/contracts/exchange/Exchange.sol#L178\n * @returns The order as stored by the orderbook\n */\nasync function validateAndPostOrder({ order, platform }) {\n  // Validation is called server-side\n\n  return platform == PlatformType.Opensea\n    ? orderToJSON(order)\n    : orderToGolomJSON(order);\n}\n\nfunction cancelOSOrder({ provider, order }) {\n  const wyvernExchange = WyvernContract(provider);\n  // const cancelHash = wyvernExchange.methods\n  //   .hashToSign_(\n  //     [\n  //       order.exchange,\n  //       order.maker,\n  //       order.taker,\n  //       order.feeRecipient,\n  //       order.target,\n  //       order.staticTarget,\n  //       order.paymentToken\n  //     ],\n  //     [\n  //       order.makerRelayerFee,\n  //       order.takerRelayerFee,\n  //       order.makerProtocolFee,\n  //       order.takerProtocolFee,\n  //       order.basePrice,\n  //       order.extra,\n  //       order.listingTime,\n  //       order.expirationTime,\n  //       order.salt\n  //     ],\n  //     order.feeMethod,\n  //     order.side,\n  //     order.saleKind,\n  //     order.howToCall,\n  //     order.calldata,\n  //     order.replacementPattern,\n  //     order.staticExtradata\n  //   )\n  //   .call();\n  // console.log(cancelHash);\n  return wyvernExchange.methods.cancelOrder_(\n    [\n      order.exchange,\n      order.maker,\n      order.taker,\n      order.feeRecipient,\n      order.target,\n      order.staticTarget,\n      order.paymentToken,\n    ],\n    [\n      order.makerRelayerFee,\n      order.takerRelayerFee,\n      order.makerProtocolFee,\n      order.takerProtocolFee,\n      order.basePrice,\n      order.extra,\n      order.listingTime,\n      order.expirationTime,\n      order.salt,\n    ],\n    order.feeMethod,\n    order.side,\n    order.saleKind,\n    order.howToCall,\n    order.calldata,\n    order.replacementPattern,\n    order.staticExtradata,\n    order.v || 0,\n    order.r || NULL_BLOCK_HASH,\n    order.s || NULL_BLOCK_HASH\n  );\n}\n\nasync function createSellOrder({\n  provider,\n  asset,\n  accountAddress,\n  startAmount,\n  endAmount,\n  quantity = 1,\n  listingTime,\n  expirationTime = 0,\n  waitForHighestBid = false,\n  englishAuctionReservePrice,\n  paymentTokenAddress,\n  extraBountyBasisPoints = 0,\n  buyerAddress,\n  fees,\n  platform = PlatformType.Opensea,\n  buyerEmail,\n}) {\n  const order = await _makeSellOrder({\n    asset,\n    quantity,\n    accountAddress,\n    startAmount,\n    endAmount,\n    listingTime,\n    expirationTime,\n    waitForHighestBid,\n    englishAuctionReservePrice,\n    paymentTokenAddress: paymentTokenAddress || NULL_ADDRESS,\n    extraBountyBasisPoints,\n    platform,\n    openSeaAsset: fees,\n    buyerAddress: buyerAddress || NULL_ADDRESS,\n  });\n  const wyvernExchange = WyvernContract(provider);\n  await validateOrderParams({ order, accountAddress, wyvernExchange });\n  const hashedOrder = {\n    ...order,\n    hash: getOrderHash(order),\n  };\n  const nonce = Number(\n    await wyvernExchange.functions.nonces(accountAddress)\n  );\n  let signature;\n  try {\n    signature = await _authorizeOrder({ provider, order: hashedOrder, nonce });\n  } catch (error) {\n    console.error(error);\n    throw new Error(\"You declined to authorize your auction\");\n  }\n  const orderWithSignature = {\n    ...hashedOrder,\n    ...signature,\n  };\n  return validateAndPostOrder({ order: orderWithSignature, platform });\n}\n\nexport { fulfillOrder, createSellOrder, cancelOSOrder };\n\n// maker:\n// 0xafac92864611c564e7fa1a6c6d07b45807536943\n// exchange:\n// 0x7f268357a8c2552623316e2562d90e642bb538e5\n// taker:\n// 0x0000000000000000000000000000000000000000\n// makerRelayerFee:\n// 500\n// takerRelayerFee:\n// 0\n// makerProtocolFee:\n// 0\n// takerProtocolFee:\n// 0\n// feeRecipient:\n// 0x5b3256965e7c3cf26e11fcaf296dfc8807c01073\n// feeMethod:\n// 1\n// side:\n// 1\n// saleKind:\n// 0\n// target:\n// 0xbaf2127b49fc93cbca6269fade0f7f31df4c88a7\n// howToCall:\n// 1\n// calldata:\n// 0xfb16a595000000000000000000000000afac92864611c564e7fa1a6c6d07b45807536943000000000000000000000000000000000000000000000000000000000000000000000000000000000000000079fcdef22feed20eddacbb2587640e45491b757f0000000000000000000000000000000000000000000000000000000000000eb5000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000000\n// replacementPattern:\n// 0x000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n// staticTarget:\n// 0x0000000000000000000000000000000000000000\n// staticExtradata:\n// 0x\n// paymentToken:\n// 0x0000000000000000000000000000000000000000\n// basePrice:\n// 6000000000000000000\n// extra:\n// 0\n// listingTime:\n// 1645298828\n// expirationTime:\n// 1645903716\n// salt:\n// 87906966303110818969546189067137492865825614986988195802067881988151729727179\n// nonce:\n// 0\n\n// basePrice: \"6000000000000000000\"\n// calldata: \"0xfb16a595000000000000000000000000afac92864611c564e7fa1a6c6d07b45807536943000000000000000000000000000000000000000000000000000000000000000000000000000000000000000079fcdef22feed20eddacbb2587640e45491b757f0000000000000000000000000000000000000000000000000000000000000eb5000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000000\"\n// exchange: \"0x7f268357a8c2552623316e2562d90e642bb538e5\"\n// expirationTime: \"1645903716\"\n// extra: \"0\"\n// feeMethod: 1\n// feeRecipient: \"0x5b3256965e7c3cf26e11fcaf296dfc8807c01073\"\n// howToCall: 1\n// listingTime: \"1645298816\"\n// maker: \"0xafac92864611c564e7fa1a6c6d07b45807536943\"\n// makerProtocolFee: \"0\"\n// makerReferrerFee: \"0\"\n// makerRelayerFee: \"500\"\n// metadata: {asset: {id: \"3765\", address: \"0x79fcdef22feed20eddacbb2587640e45491b757f\"}, schema: \"ERC721\"}\n// nonce: 0\n// paymentToken: \"0x0000000000000000000000000000000000000000\"\n// quantity: \"1\"\n// r: \"0x0c70bd3052b0da178141b84e7bdbe511acc5f7f601281850cd5f93f145c9bbb5\"\n// replacementPattern: \"0x000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n// s: \"0x7a2bf43b7b616073bf2486d2890b674f9587f68f59a84e4d7fff55842bbe9b60\"\n// saleKind: 0\n// salt: \"87577974536160270209585191401103724053896633202437364720132507693990122512257\"\n// side: 1\n// staticExtradata: \"0x\"\n// staticTarget: \"0x0000000000000000000000000000000000000000\"\n// taker: \"0x0000000000000000000000000000000000000000\"\n// takerProtocolFee: \"0\"\n// takerRelayerFee: \"0\"\n// target: \"0xbaf2127b49fc93cbca6269fade0f7f31df4c88a7\"\n// v: 28\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}