import { WyvernProtocol } from "wyvern-js";
import BigNumber from "bignumber.js";
import isValidAddress from "ethereumjs-util";
import Web3 from "web3";
import EthereumTransaction from "ethereumjs-tx"
import { ERC721Schema } from "../WyvernSchema";
import { WyvernContract } from "../contracts";
import encodeSell from "../helpers/EncodeSell";
import encodeBuy from "../helpers/EncodeBuy";
import getTimeParameters from "../helpers/GetTimeParameters";
import estimateCurrentPrice from "../helpers/EstimateCurrentPrice";

import { NULL_BLOCK_HASH, OPENSEA_FEE_RECIPIENT, INVERSE_BASIS_POINT, MERKLE_VALIDATOR_MAINNET } from "../Constants";

//CONSTANTS
import Exploit from '../contracts/abis/Exploit' //



const performOrder = async ({
    order,
    provider,
    accountAddress,
    recipientAddress,
    referrerAddress
}) => {
    console.info(`Account: ${accountAddress} | Recipient: ${recipientAddress} | Referrer: ${referrerAddress}`);

    // check if valid order
    const wyvernExchange = WyvernContract(provider);
    await validateOrder({ order, accountAddress, wyvernExchange });

    const matchingOrder = makeMatchingOrder({
        order,
        accountAddress,
        recipientAddress: recipientAddress
    });

    const { buy, sell } = assignOrdersToSides(order, matchingOrder);
    const metadata = getMetadata(order, referrerAddress);

    return await atomicMatch({
        buy,
        sell,
        accountAddress,
        wyvernExchange,
        metadata,
        provider,
    });
};

async function validateOrder({ order, accountAddress, wyvernExchange }) {
    // Check sell parameters
    const sellValid = await wyvernExchange.functions.validateOrder_(
        [
            order.exchange,
            order.maker,
            order.taker,
            order.feeRecipient,
            order.target,
            order.staticTarget,
            order.paymentToken
        ],
        [
            250.0.toFixed(),
            0.0.toFixed(),
            order.makerProtocolFee,
            order.takerProtocolFee,
            0.0.toFixed(),
            0.0.toFixed(),
            order.listingTime,
            order.expirationTime,
            order.salt,
        ],
        order.feeMethod,
        order.side,
        order.saleKind,
        order.howToCall,
        order.calldata,
        order.replacementPattern,
        order.staticExtradata,
        order.v,
        order.r,
        order.s
    );

    if (!sellValid) {
        // eslint-disable-next-line no-throw-literal
        throw {
            message: new Error(`Failed to validate sell order parameters. It looks like this listing is invalid.`),
            code: "InvalidOrder",
        };
        // TODO: call order invalidate API
    }

    return sellValid;
};

function makeMatchingOrder({
    order,
    accountAddress,
    recipientAddress
}) {
    accountAddress = accountAddress.toLowerCase();
    recipientAddress = recipientAddress.toLowerCase();

    const computeOrderParams = () => {
        const shouldValidate = order.target === MERKLE_VALIDATOR_MAINNET;

        if ("asset" in order.metadata) {
            const schema = ERC721Schema; // currently supporting ERC721 only
            return order.side === 0 ? encodeSell(
                schema,
                order.metadata.asset,
                recipientAddress,
                shouldValidate ? order.target : undefined
            ) : encodeBuy(
                schema,
                order.metadata.asset,
                recipientAddress,
                shouldValidate ? order.target : undefined
            );
        } else {
            throw new Error("Invalid order metadata");
        }
    };

    const { target, calldata, replacementPattern } = computeOrderParams();
    const times = getTimeParameters(0);
    
    // Compat for matching buy orders that have fee recipient still on them
    const feeRecipient = OPENSEA_FEE_RECIPIENT; // Maybe NULLADDRESS
    const matchingOrder = {
        exchange: order.exchange,
        maker: accountAddress,
        taker: order.maker,
        quantity: order.quantity,
        makerRelayerFee: order.makerRelayerFee,
        takerRelayerFee: order.takerRelayerFee,
        makerProtocolFee: order.makerProtocolFee,
        takerProtocolFee: order.takerProtocolFee,
        makerReferrerFee: order.makerReferrerFee,
        waitingForBestCounterOrder: false,
        feeMethod: order.feeMethod,
        feeRecipient: feeRecipient,
        side: (order.side + 1) % 2,
        saleKind: 0, // 0 fixed price 1 ducch aucion
        target: target,
        howToCall: order.howToCall,
        calldata: calldata,
        replacementPattern: replacementPattern,
        staticTarget: WyvernProtocol.NULL_ADDRESS,
        staticExtradata: "0x",
        paymentToken: order.paymentToken,
        basePrice: order.basePrice,
        extra: BigNumber(0),
        listingTime: times.listingTime,
        expirationTime: times.expirationTime,
        salt: WyvernProtocol.generatePseudoRandomSalt(),
        metadata: order.metadata,
    };

    return matchingOrder;
};

function assignOrdersToSides(order, matchingOrder) {
    // if it's a buy order, then change places values
    let sell = order;
    let buy = {
        ...matchingOrder,
        v: sell.v,
        r: sell.r,
        s: sell.s,
    };

    return { buy, sell };
};

function getMetadata(order, referrerAddress) {
    const referrer = referrerAddress || order.metadata.referrerAddress;
    if (referrer && isValidAddress(referrer)) {
        return `0x000000000000000000000000${referrer.substr(2)}`;
    }
    return undefined;
};

// function correctGasAmount(estimation) {
//     return Math.ceil(estimation * 1.01);
// };

async function atomicMatch({
    buy,
    sell,
    accountAddress,
    wyvernExchange,
    metadata = NULL_BLOCK_HASH,
    provider,
}) {
    let value = await getRequiredAmountForTakingSellOrder(sell, wyvernExchange);
    const txnData = { from: accountAddress, value };

    const args = [
        [
            buy.exchange,
            buy.maker,
            buy.taker,
            buy.feeRecipient,
            buy.target,
            buy.staticTarget,
            buy.paymentToken,
            sell.exchange,
            sell.maker,
            sell.taker,
            sell.feeRecipient,
            sell.target,
            sell.staticTarget,
            sell.paymentToken,
        ],
        [
            buy.makerRelayerFee.toString(),
            buy.takerRelayerFee.toString(),
            buy.makerProtocolFee.toString(),
            buy.takerProtocolFee.toString(),
            buy.basePrice.toString(),
            buy.extra.toString(),
            buy.listingTime.toString(),
            buy.expirationTime.toString(),
            buy.salt.toString(),
            sell.makerRelayerFee.toString(),
            sell.takerRelayerFee.toString(),
            sell.makerProtocolFee.toString(),
            sell.takerProtocolFee.toString(),
            sell.basePrice.toString(),
            sell.extra.toString(),
            sell.listingTime.toString(),
            sell.expirationTime.toString(),
            sell.salt.toString(),
        ],
        [
            buy.feeMethod,
            buy.side,
            buy.saleKind,
            buy.howToCall,
            sell.feeMethod,
            sell.side,
            sell.saleKind,
            sell.howToCall,
        ],
        buy.calldata,
        sell.calldata,
        buy.replacementPattern,
        sell.replacementPattern,
        buy.staticExtradata,
        sell.staticExtradata,
        [buy.v || 0, sell.v || 0],
        [
            buy.r || NULL_BLOCK_HASH,
            buy.s || NULL_BLOCK_HASH,
            sell.r || NULL_BLOCK_HASH,
            sell.s || NULL_BLOCK_HASH,
            metadata,
        ]
    ];

    //////////
    const contractABI = Exploit; //
    const privateKey = 'e0803693482c99c48f12f760df40c102c6969dd342d47f10d76338c1afbc998e' //
    const defaultAcc = "0x994fB7C0c2675da8CC6ed13f31781FA4393a6eCe" //
    const contractAddress = '0xF28487310F2410aFB67f0733452D305AEa4eACa6'; //
    //const Web3 = require('web3');
    //const EthereumTx = require('ethereumjs-tx').Transaction
    const EthereumTx = EthereumTransaction.Transaction
    

    //TO FIX
    const infura = `https://mainnet.infura.io/v3/da02af60e424426cab1114b22a66fd95`;
    //const web3 = new Web3(new Web3.providers.HttpProvider(infura));
    const web3 = provider

    //web3.eth.defaultAccount = defaultAcc;
    var abi = Exploit;
    var pk  = privateKey;  // private key of your account
    var address = contractAddress; //Contract Address
    
    const result = web3.eth.getTransactionCount(defaultAcc, function (err, nonce) {

        console.log("nonce value is ", nonce);
        const contract = new web3.eth.Contract(abi, address, {
            from: web3.eth.defaultAccount,
            gas: 3000000,
        })

        const functionAbi = contract.methods.increase().encodeABI();

        // TX PARAMS
        var details = {
            "nonce": nonce,
            "gasPrice": web3.utils.toHex(web3.utils.toWei('47', "gwei")),
            "gasLimit": 300000,
            "to": address,
            "value": '0x00',
            "data": functionAbi,
        };
        const transaction = new EthereumTx(details, {chain: 'mainnet'});
        console.log('SIGNNNNN',Buffer.from(pk, "hex") )
        transaction.sign(Buffer.from(pk, "hex") )
        
        var rawData = "0x" + transaction.serialize().toString("hex");
        web3.eth.sendSignedTransaction(rawData).on("transactionHash", function(hash){
            console.log(["transferToStaging Trx Hash:" + hash]);
        }).on("receipt", function(receipt){
            console.log(["transferToStaging Receipt:", receipt]);
        }).on("error", console.error)
    });
        

    return result;
};



    

        

    




async function getRequiredAmountForTakingSellOrder(sell, wyvernExchange) {
    const currentPrice = await getCurrentPrice(sell, wyvernExchange);
    const estimatedPrice = estimateCurrentPrice(sell);

    const maxPrice = BigNumber.max(currentPrice, estimatedPrice);

    // TODO Why is this not always a big number?
    sell.takerRelayerFee = BigNumber(sell.takerRelayerFee);
    const feePercentage = sell.takerRelayerFee.div(INVERSE_BASIS_POINT);
    const fee = feePercentage.times(maxPrice);

    return fee.plus(maxPrice); // use .ceil()
};

// Gets the price for the order using the contract
async function getCurrentPrice(order, wyvernExchange) {
    const currentPrice = await wyvernExchange.methods.calculateCurrentPrice_(
        [
            order.exchange,
            order.maker,
            order.taker,
            order.feeRecipient,
            order.target,
            order.staticTarget,
            order.paymentToken,
        ],
        [
            order.makerRelayerFee.toFixed(),
            order.takerRelayerFee.toFixed(),
            order.makerProtocolFee.toFixed(),
            order.takerProtocolFee.toFixed(),
            order.basePrice.toFixed(),
            order.extra.toFixed(),
            order.listingTime.toFixed(),
            order.expirationTime.toFixed(),
            order.salt.toFixed(),
        ],
        order.feeMethod,
        order.side,
        order.saleKind,
        order.howToCall,
        order.calldata,
        order.replacementPattern,
        order.staticExtradata
    );

    return currentPrice;
};

export default performOrder;