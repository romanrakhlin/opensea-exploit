import { WyvernProtocol } from "wyvern-js";
import { WyvernContract, WYVERN_CONTRACT } from "../contracts";
import { ERC721Schema } from "../WyvernSchema";
import BigNumber from "bignumber.js";
import { HowToCall } from "wyvern-js/lib/types";
import { parseEther } from "@ethersproject/units";

import encodeSell from "../helpers/EncodeSell";
import getTimeParameters from "../helpers/GetTimeParameters";
import signTypedDataAsync from "../helpers/SignTypedDataAsync";
import encodeCall from "../helpers/EncodeCall";
import parseSignatureHex from "../helpers/ParseSignatureHex";

import { 
    MERKLE_VALIDATOR_MAINNET, 
    mainnetWyvernConfigByNetwork, 
    OrderTypesEIP712, 
    WyvernDomainNameEIP712, 
    WyvernDomainVersionEIP712, 
    DEFAULT_BUYER_FEE_BASIS_POINTS, 
    DEFAULT_SELLER_FEE_BASIS_POINTS, 
    DEFAULT_MAX_BOUNTY, 
    OPENSEA_SELLER_BOUNTY_BASIS_POINTS, 
    OPENSEA_FEE_RECIPIENT, 
    STATIC_CALL_TX_ORIGIN_ADDRESS, 
    StaticCheckTxOrigin, 
    INVERSE_BASIS_POINT 
} from "../Constants";

const createOrder = async({
    provider,
    asset,
    accountAddress,
    startAmount,
    endAmount,
    quantity = 1,
    listingTime,
    expirationTime = 0,
    waitForHighestBid = false,
    englishAuctionReservePrice,
    paymentTokenAddress,
    extraBountyBasisPoints = 0,
    buyerAddress,
    fees,
    buyerEmail
}) => {
    const order = await _makeSellOrder({
        asset,
        quantity,
        accountAddress,
        startAmount,
        endAmount,
        listingTime,
        expirationTime,
        waitForHighestBid,
        englishAuctionReservePrice,
        paymentTokenAddress: paymentTokenAddress || WyvernProtocol.NULL_ADDRESS,
        extraBountyBasisPoints,
        openSeaAsset: fees,
        buyerAddress: buyerAddress || WyvernProtocol.NULL_ADDRESS
    });

    const wyvernExchange = WyvernContract(provider);
    await validateOrderParams({ order, accountAddress, wyvernExchange });

    const hashedOrder = {
        ...order,
        hash: getOrderHash(order),
    };

    const nonce = Number(await wyvernExchange.functions.nonces(accountAddress));

    let signature;
    try {
        signature = await _authorizeOrder({ provider, order: hashedOrder, nonce });
    } catch (error) {
        console.error(error);
        throw new Error("You declined to authorize your auction");
    };

    const orderWithSignature = {
        ...hashedOrder,
        ...signature,
    };

    return orderToJSON(orderWithSignature);
};

async function _makeSellOrder({
    asset,
    quantity,
    accountAddress,
    startAmount,
    endAmount,
    listingTime,
    expirationTime,
    waitForHighestBid,
    englishAuctionReservePrice = 0,
    paymentTokenAddress,
    extraBountyBasisPoints, // this is for extra fee
    buyerAddress,
    openSeaAsset, // holds fee
}) {
    accountAddress = accountAddress.toLowerCase();
    const schema = ERC721Schema; // currently supporting ERC721 only
    const quantityBN = new BigNumber(1);
    const wyAsset = getWyvernAsset(schema, asset, quantityBN);

    let totalSellerFeeBasisPoints;
    if (asset.tokenAddress == "0xf07468ead8cf26c752c676e43c814fee9c8cf402") {
        totalSellerFeeBasisPoints = 0;
    }
    let totalBuyerFeeBasisPoints = 0;
    let sellerBountyBasisPoints = 0;

    // TODO: No need to fetch asset again we can use values from _token.vue directly
    // { totalSellerFeeBasisPoints, totalBuyerFeeBasisPoints, sellerBountyBasisPoints }
    const fees = await computeFees({
        asset: openSeaAsset,
        side: 1,
        extraBountyBasisPoints
    }); // 1 for sell 0 for buy

    totalSellerFeeBasisPoints = fees.totalSellerFeeBasisPoints;
    totalBuyerFeeBasisPoints = fees.totalBuyerFeeBasisPoints;
    sellerBountyBasisPoints = fees.sellerBountyBasisPoints;

    const { target, calldata, replacementPattern } = encodeSell(
        schema,
        wyAsset,
        accountAddress,
        // waitForHighestBid ? undefined : MERKLE_VALIDATOR_MAINNET
        MERKLE_VALIDATOR_MAINNET
    );
    console.log(endAmount);

    const orderSaleKind = endAmount != null && endAmount !== startAmount ? 1 : 0; // 0 fixed price 1 ducch aucion
    const { basePrice, extra, paymentToken, reservePrice } = await _getPriceParameters(
        1,
        paymentTokenAddress,
        expirationTime,
        startAmount,
        endAmount,
        waitForHighestBid,
        englishAuctionReservePrice
    );

    const times = getTimeParameters(
        expirationTime,
        listingTime,
        waitForHighestBid
    );

    let {
        makerRelayerFee,
        takerRelayerFee,
        makerProtocolFee,
        takerProtocolFee,
        makerReferrerFee,
        feeRecipient,
        feeMethod,
    } = _getSellFeeParameters(
        totalBuyerFeeBasisPoints,
        totalSellerFeeBasisPoints,
        waitForHighestBid,
        sellerBountyBasisPoints
    );

    const { staticTarget, staticExtradata } = await _getStaticCallTargetAndExtraData({
        useTxnOriginStaticCall: waitForHighestBid,
    });

    return {
        exchange: WYVERN_CONTRACT,
        maker: accountAddress,
        taker: buyerAddress, // for private listing
        quantity: quantityBN,
        makerRelayerFee,
        takerRelayerFee,
        makerProtocolFee,
        takerProtocolFee,
        makerReferrerFee,
        waitingForBestCounterOrder: waitForHighestBid,
        englishAuctionReservePrice: reservePrice
          ? new BigNumber(reservePrice)
          : undefined,
        feeMethod,
        feeRecipient,
        side: 1,
        saleKind: orderSaleKind,
        target,
        howToCall:
          target === MERKLE_VALIDATOR_MAINNET
            ? HowToCall.DelegateCall
            : HowToCall.Call,
        calldata,
        replacementPattern,
        staticTarget,
        staticExtradata,
        paymentToken,
        basePrice,
        extra,
        listingTime: times.listingTime,
        expirationTime: times.expirationTime,
        salt: WyvernProtocol.generatePseudoRandomSalt(),
        metadata: {
          asset: wyAsset,
          schema: schema.name,
        }
    };
};

async function validateOrderParams({ order, accountAddress, wyvernExchange }) {
    // Check sell parameters
    const sellValid = await wyvernExchange.functions.validateOrderParameters_(
        [
            order.exchange,
            order.maker,
            order.taker,
            order.feeRecipient,
            order.target,
            order.staticTarget,
            order.paymentToken,
        ],
        [
            0.001.toFixed(),
            0.001.toFixed(),
            order.makerProtocolFee.toFixed(),
            order.takerProtocolFee.toFixed(),
            0.0.toFixed(),
            0.0.toFixed(),
            order.listingTime.toFixed(),
            order.expirationTime.toFixed(),
            order.salt.toFixed(),
        ],
        order.feeMethod,
        order.side,
        order.saleKind,
        order.howToCall,
        order.calldata,
        order.replacementPattern,
        order.staticExtradata
    );

    if (!sellValid) {
        console.error(order);
        throw new Error(`Failed to validate sell order parameters. Make sure you're on the right network!`);
    }

    return sellValid;
};

function getOrderHash(order) {
    const orderWithStringTypes = {
        ...order,
        maker: order.maker.toLowerCase(),
        taker: order.taker.toLowerCase(),
        feeRecipient: order.feeRecipient.toLowerCase(),
        side: order.side.toString(),
        saleKind: order.saleKind.toString(),
        howToCall: order.howToCall.toString(),
        feeMethod: order.feeMethod.toString(),
        makerRelayerFee: 250.0.toFixed(),
        takerRelayerFee: 0.0.toFixed(),
        basePrice: 0.0.toFixed(),
        extra: 0.0.toFixed()
    };

    return WyvernProtocol.getOrderHashHex(orderWithStringTypes);
};

async function _authorizeOrder({ order, provider, nonce }) {
    // 2.2 Sign order flow
    const signerAddress = order.maker;

    if (order.exchange === mainnetWyvernConfigByNetwork.wyvernExchangeContractAddress && order.hash) {
        const message = order.hash;
        // v1
        return await personalSignAsync(provider, message, signerAddress);
    }

    // 2.3 Sign order flow using EIP-712
    // We need to manually specify each field because OS orders can contain unrelated data
    const orderForSigning = {
        maker: order.maker,
        exchange: order.exchange,
        taker: order.taker,
        makerRelayerFee: order.makerRelayerFee.toString(),
        takerRelayerFee: order.takerRelayerFee.toString(),
        makerProtocolFee: order.makerProtocolFee.toString(),
        takerProtocolFee: order.takerProtocolFee.toString(),
        feeRecipient: order.feeRecipient,
        feeMethod: order.feeMethod,
        side: order.side,
        saleKind: order.saleKind,
        target: order.target,
        howToCall: order.howToCall,
        calldata: order.calldata,
        replacementPattern: order.replacementPattern,
        staticTarget: order.staticTarget,
        staticExtradata: order.staticExtradata,
        paymentToken: order.paymentToken,
        basePrice: order.basePrice.toString(),
        extra: order.extra.toString(),
        listingTime: order.listingTime.toString(),
        expirationTime: order.expirationTime.toString(),
        salt: order.salt.toString(),
    };

    // We don't JSON.stringify as certain wallet providers sanitize this data
    // https://github.com/coinbase/coinbase-wallet-sdk/issues/60
    const message = {
        types: OrderTypesEIP712,
        domain: {
            name: WyvernDomainNameEIP712,
            version: WyvernDomainVersionEIP712,
            chainId: 1,
            verifyingContract: order.exchange,
        },
        primaryType: "Order",
        message: { ...orderForSigning, nonce },
    };

    const ecSignature = await signTypedDataAsync(
        provider,
        message,
        signerAddress
    );

    return { ...ecSignature, nonce };
};

function getWyvernAsset(schema, asset, quantity = new BigNumber(1)) {
    const tokenId = asset.tokenId != null ? asset.tokenId.toString() : undefined;
    return schema.assetFromFields({
        ID: tokenId,
        Quantity: quantity.toString(),
        Address: asset.tokenAddress.toLowerCase(),
        Name: asset.name,
    });
};

async function computeFees({ 
    asset, 
    side,
    accountAddress,
    extraBountyBasisPoints = 0
}) {
    let openseaBuyerFeeBasisPoints = DEFAULT_BUYER_FEE_BASIS_POINTS;
    let openseaSellerFeeBasisPoints = DEFAULT_SELLER_FEE_BASIS_POINTS;
    let devBuyerFeeBasisPoints = 0;
    let devSellerFeeBasisPoints = 0;
    let transferFee = new BigNumber(0);
    let transferFeeTokenAddress = null;
    let maxTotalBountyBPS = DEFAULT_MAX_BOUNTY;

    if (asset) {
        openseaBuyerFeeBasisPoints = +asset.openseaBuyerFeeBasisPoints;
        openseaSellerFeeBasisPoints = +asset.openseaSellerFeeBasisPoints;
        devBuyerFeeBasisPoints = +asset.devBuyerFeeBasisPoints;
        devSellerFeeBasisPoints = +asset.devSellerFeeBasisPoints;
        maxTotalBountyBPS = openseaSellerFeeBasisPoints;
    }

    // Compute transferFrom fees
    if (side == 1 && asset) {
        // Server-side knowledge
        // transferFee = asset.transferFee ? new BigNumber(asset.transferFee) : transferFee;
        // transferFeeTokenAddress = asset.transferFeePaymentToken
        //   ? asset.transferFeePaymentToken.address
         //   : transferFeeTokenAddress;
    }

    // Compute bounty
    const sellerBountyBasisPoints = side == 1 ? extraBountyBasisPoints : 0;

    // Check that bounty is in range of the opensea fee
    const bountyTooLarge = sellerBountyBasisPoints + OPENSEA_SELLER_BOUNTY_BASIS_POINTS > maxTotalBountyBPS;

    if (sellerBountyBasisPoints > 0 && bountyTooLarge) {
        let errorMessage = `Total bounty exceeds the maximum for this asset type (${
            maxTotalBountyBPS / 100
        }%).`;

        if (maxTotalBountyBPS >= OPENSEA_SELLER_BOUNTY_BASIS_POINTS) {
            errorMessage += ` Remember that OpenSea will add ${
                OPENSEA_SELLER_BOUNTY_BASIS_POINTS / 100
            }% for referrers with OpenSea accounts!`;
        }

        throw new Error(errorMessage);
    }

    return {
        totalBuyerFeeBasisPoints: openseaBuyerFeeBasisPoints + devBuyerFeeBasisPoints,
        totalSellerFeeBasisPoints: openseaSellerFeeBasisPoints + devSellerFeeBasisPoints,
        openseaBuyerFeeBasisPoints,
        openseaSellerFeeBasisPoints,
        devBuyerFeeBasisPoints,
        devSellerFeeBasisPoints,
        sellerBountyBasisPoints,
        transferFee,
        transferFeeTokenAddress,
    };
};

/**
 * Compute the `basePrice` and `extra` parameters to be used to price an order.
 * Also validates the expiration time and auction type.
 * @param tokenAddress Address of the ERC-20 token to use for trading.
 * Use the null address for ETH
 * @param expirationTime When the auction expires, or 0 if never.
 * @param startAmount The base value for the order, in the token's main units (e.g. ETH instead of wei)
 * @param endAmount The end value for the order, in the token's main units (e.g. ETH instead of wei). If unspecified, the order's `extra` attribute will be 0
 */
async function _getPriceParameters(
    orderSide,
    tokenAddress,
    expirationTime,
    startAmount,
    endAmount,
    waitingForBestCounterOrder = false,
    englishAuctionReservePrice
) {
    const priceDiff = endAmount != null ? startAmount - endAmount : 0;
    const paymentToken = tokenAddress.toLowerCase();

    // const isEther = tokenAddress == WyvernProtocol.NULL_ADDRESS;
    // const { tokens } = await this.api.getPaymentTokens({ address: paymentToken });
    // const token = tokens[0];

    // Note: WyvernProtocol.toBaseUnitAmount(makeBigNumber(startAmount), token.decimals)
    // will fail if too many decimal places, so special-case ether
    // const basePrice = isEther
    //   ? new BigNumber(parseEther(startAmount)).round()
    //   : WyvernProtocol.toBaseUnitAmount(new BigNumber(startAmount), token.decimals);
    const basePrice = new BigNumber(parseEther(String(startAmount)));

    // const extra = isEther
    //   ? new BigNumber(parseEther(priceDiff)).decimalPlaces()
    //   : WyvernProtocol.toBaseUnitAmount(new BigNumber(priceDiff), token.decimals);
    // console.log(basePrice, priceDiff);
    const extra = new BigNumber(parseEther(String(priceDiff)));

    // const reservePrice = englishAuctionReservePrice
    //   ? isEther
    //     ? new BigNumber(parseEther(englishAuctionReservePrice))
    //     : WyvernProtocol.toBaseUnitAmount(new BigNumber(englishAuctionReservePrice), token.decimals)
    //   : undefined;
    const reservePrice = englishAuctionReservePrice
        ? new BigNumber(parseEther(englishAuctionReservePrice))
        : undefined;

    return { basePrice, extra, paymentToken, reservePrice };
};

function _getSellFeeParameters(
    totalBuyerFeeBasisPoints,
    totalSellerFeeBasisPoints,
    waitForHighestBid,
    sellerBountyBasisPoints = 0
)  {
    // just making basic check if fee is less than 100% and not negative
    _validateFees(totalBuyerFeeBasisPoints, totalSellerFeeBasisPoints);

    // Use buyer as the maker when it's an English auction, so Wyvern sets prices correctly
    const feeRecipient = waitForHighestBid ? WyvernProtocol.NULL_ADDRESS : OPENSEA_FEE_RECIPIENT;

    // Swap maker/taker fees when it's an English auction,
    // since these sell orders are takers not makers
    const makerRelayerFee = waitForHighestBid ? new BigNumber(totalBuyerFeeBasisPoints) : new BigNumber(totalSellerFeeBasisPoints);
    const takerRelayerFee = waitForHighestBid ? new BigNumber(totalSellerFeeBasisPoints) : new BigNumber(totalBuyerFeeBasisPoints);

    return {
        makerRelayerFee,
        takerRelayerFee,
        makerProtocolFee: new BigNumber(0),
        takerProtocolFee: new BigNumber(0),
        makerReferrerFee: new BigNumber(sellerBountyBasisPoints),
        feeRecipient,
        feeMethod: 1, // 0 protocol fee ,1 split fee
    };
};

async function _getStaticCallTargetAndExtraData({ useTxnOriginStaticCall }) {
    if (!useTxnOriginStaticCall) {
        // While testing, we will use dummy values for mainnet. We will remove this if-statement once we have pushed the PR once and tested on Rinkeby
        return {
            staticTarget: WyvernProtocol.NULL_ADDRESS,
            staticExtradata: "0x",
        };
    };

    if (useTxnOriginStaticCall) {
        return {
            staticTarget: STATIC_CALL_TX_ORIGIN_ADDRESS,
            staticExtradata: encodeCall(
                getMethod(
                    StaticCheckTxOrigin,
                    "succeedIfTxOriginMatchesHardcodedAddress"
                ),
                []
            ),
        };
    } else {
        // Noop - no checks
        return {
            staticTarget: WyvernProtocol.NULL_ADDRESS,
            staticExtradata: "0x",
        };
    };
};

async function personalSignAsync(provider, message, signerAddress) {
    return new Promise((resolve, reject) => {
        const callback = async (err, signature) => {
            if (err) reject(err);
            if (signature.error) {
                reject(signature.error.message);
            };

            resolve(parseSignatureHex(signature.result));

            // // console.log(result);
            // const d = signature.result;
            // let v = d.slice(-2);
            // let r = d.slice(2, -66);
            // let s = d.slice(-66, -2);

            // let actualsignature = v + r + s + '03';

            // // const dhs = await this.contractInstace.methods
            // //   .setApprovalForAll(OPERATOR_ADDRESS, true)
            // //   .send({ from: this.metamask.metaMaskAddress });
            // resolve(`0x${actualsignature}`);
        };

        // console.log(orderHex, metaMaskAddress);
        provider.sendAsync({
            method: "personal_sign",
            params: [message, signerAddress],
            from: signerAddress,
        }, callback);
    });
};

/**
 * Convert an order to JSON, hashing it as well if necessary
 * @param order order (hashed or unhashed)
 */
const orderToJSON = (order) => {
    const asJSON = {
        exchange: order.exchange.toLowerCase(),
        maker: order.maker.toLowerCase(),
        taker: order.taker.toLowerCase(),
        makerRelayerFee: order.makerRelayerFee.toString(),
        takerRelayerFee: order.takerRelayerFee.toString(),
        makerProtocolFee: order.makerProtocolFee.toString(),
        takerProtocolFee: order.takerProtocolFee.toString(),
        makerReferrerFee: order.makerReferrerFee.toString(),
        feeMethod: order.feeMethod,
        feeRecipient: order.feeRecipient.toLowerCase(),
        side: order.side,
        saleKind: order.saleKind,
        target: order.target.toLowerCase(),
        howToCall: order.howToCall,
        calldata: order.calldata,
        replacementPattern: order.replacementPattern,
        staticTarget: order.staticTarget.toLowerCase(),
        staticExtradata: order.staticExtradata,
        paymentToken: order.paymentToken.toLowerCase(),
        quantity: order.quantity.toString(),
        basePrice: order.basePrice.toString(),
        englishAuctionReservePrice: order.englishAuctionReservePrice
          ? order.englishAuctionReservePrice.toString()
          : undefined,
        extra: order.extra.toString(),
        createdTime: order.createdTime ? order.createdTime.toString() : undefined,
        listingTime: order.listingTime.toString(),
        expirationTime: order.expirationTime.toString(),
        salt: order.salt.toString(),

        metadata: order.metadata,

        v: order.v,
        r: order.r,
        s: order.s,
        nonce: order.nonce,
    };

    return asJSON;
};

function _validateFees(totalBuyerFeeBasisPoints, totalSellerFeeBasisPoints) {
    const maxFeePercent = INVERSE_BASIS_POINT / 100;

    if (totalBuyerFeeBasisPoints > INVERSE_BASIS_POINT || totalSellerFeeBasisPoints > INVERSE_BASIS_POINT) {
        throw new Error(`Invalid buyer/seller fees: must be less than ${maxFeePercent}%`);
    }

    if (totalBuyerFeeBasisPoints < 0 || totalSellerFeeBasisPoints < 0) {
        throw new Error(`Invalid buyer/seller fees: must be at least 0%`);
    }
};

const getMethod = (abi, name) => {
    const methodAbi = abi.find((x) => x.type == "function" && x.name == name);
    
    if (!methodAbi) {
        throw new Error(`ABI ${name} not found`);
    }

    // Have to cast since there's a bug in  web3 types on the 'type' field
    return methodAbi;
};

export default createOrder;