import { WyvernProtocol } from "wyvern-js";
import { WyvernContract, WYVERN_CONTRACT } from "../contracts";
import { ERC721Schema } from "../WyvernSchema";
import BigNumber from "bignumber.js";
import { HowToCall } from "wyvern-js/lib/types";
import axios from "axios";

import encodeSell from "../helpers/EncodeSell";
import getTimeParameters from "../helpers/GetTimeParameters";
import signTypedDataAsync from "../helpers/SignTypedDataAsync";
import parseSignatureHex from "../helpers/ParseSignatureHex";
import estimateCurrentPrice from "../helpers/EstimateCurrentPrice";

import { 
    MERKLE_VALIDATOR_MAINNET, 
    mainnetWyvernConfigByNetwork, 
    OrderTypesEIP712, 
    WyvernDomainNameEIP712, 
    WyvernDomainVersionEIP712, 
    DEFAULT_BUYER_FEE_BASIS_POINTS, 
    DEFAULT_SELLER_FEE_BASIS_POINTS, 
    DEFAULT_MAX_BOUNTY, 
    OPENSEA_SELLER_BOUNTY_BASIS_POINTS, 
    OPENSEA_FEE_RECIPIENT, 
    INVERSE_BASIS_POINT,
    OPENSEA_URL
} from "../Constants";

const createOrder = async({
    provider,
    asset,
    accountAddress,
    price,
    quantity = 1,
    listingTime,
    expirationTime = 0,
    waitForHighestBid = false,
    extraBountyBasisPoints = 0,
    buyerAddress
}) => {
    const openSeaAsset = getAsset(asset);

    const order = await _makeSellOrder({
        asset: asset,
        quantity: quantity,
        accountAddress: accountAddress.toLowerCase(),
        price: price,
        listingTime: listingTime,
        expirationTime: expirationTime,
        waitForHighestBid: waitForHighestBid,
        paymentTokenAddress: WyvernProtocol.NULL_ADDRESS,
        extraBountyBasisPoints: extraBountyBasisPoints,
        openSeaAsset: openSeaAsset,
        buyerAddress: buyerAddress || WyvernProtocol.NULL_ADDRESS
    });

    const wyvernExchange = WyvernContract(provider);

    await validateOrderParams({ order, accountAddress, wyvernExchange });
    
    const hashedOrder = {
        ...order,
        hash: getOrderHash(order),
    };

    const nonce = Number(await wyvernExchange.functions.nonces(accountAddress));

    let signature;
    try {
        signature = await authorizeOrder({ 
            provider: provider, 
            order: hashedOrder, 
            nonce: nonce 
        });
    } catch (error) {
        console.error(error);
        throw new Error("You declined to authorize your order.");
    };

    const orderWithSignature = {
        ...hashedOrder,
        ...signature,
    };

    return orderToJSON(orderWithSignature);
};

async function _makeSellOrder({
    asset,
    quantity,
    accountAddress,
    price,
    listingTime,
    expirationTime,
    waitForHighestBid,
    paymentTokenAddress,
    extraBountyBasisPoints, // this is for extra fee
    buyerAddress,
    openSeaAsset // holds fee
}) {
    const schema = ERC721Schema; // currently supporting ERC721 only
    const quantityBigNumber = new BigNumber(quantity);
    const wyvernAsset = getWyvernAsset(schema, asset, quantityBigNumber);

    const fees = await computeFees({
        asset: openSeaAsset,
        extraBountyBasisPoints: extraBountyBasisPoints
    });

    let totalSellerFeeBasisPoints = fees.totalSellerFeeBasisPoints;
    let totalBuyerFeeBasisPoints = fees.totalBuyerFeeBasisPoints;
    let sellerBountyBasisPoints = fees.sellerBountyBasisPoints;

    const { target, calldata, replacementPattern } = encodeSell(
        schema,
        wyvernAsset,
        accountAddress,
        MERKLE_VALIDATOR_MAINNET
    );

    const { basePrice, extra } = await getPriceParameters(price);

    const times = getTimeParameters(expirationTime, listingTime);

    let {
        makerRelayerFee,
        takerRelayerFee,
        makerProtocolFee,
        takerProtocolFee,
        makerReferrerFee,
        feeRecipient,
        feeMethod,
    } = getSellFeeParameters(
        totalBuyerFeeBasisPoints,
        totalSellerFeeBasisPoints,
        waitForHighestBid,
        sellerBountyBasisPoints
    );

    return {
        exchange: WYVERN_CONTRACT,
        maker: accountAddress,
        taker: buyerAddress, // for private listing
        quantity: quantityBigNumber,
        makerRelayerFee: makerRelayerFee,
        takerRelayerFee: takerRelayerFee,
        makerProtocolFee: makerProtocolFee,
        takerProtocolFee: takerProtocolFee,
        makerReferrerFee: makerReferrerFee,
        waitingForBestCounterOrder: waitForHighestBid,
        englishAuctionReservePrice: undefined,
        feeMethod: feeMethod,
        feeRecipient: feeRecipient,
        side: 1,
        saleKind: 0, // 0 fixed price 1 ducch aucio (price can increase on going)
        target: target,
        howToCall:
            target === MERKLE_VALIDATOR_MAINNET
                ? HowToCall.DelegateCall
                : HowToCall.Call,
        calldata: calldata,
        replacementPattern: replacementPattern,
        staticTarget: WyvernProtocol.NULL_ADDRESS,
        staticExtradata: "0x",
        paymentToken: paymentTokenAddress.toLowerCase(),
        basePrice: basePrice,
        extra: extra,
        listingTime: times.listingTime,
        expirationTime: times.expirationTime,
        salt: WyvernProtocol.generatePseudoRandomSalt(),
        metadata: {
            asset: wyvernAsset,
            schema: schema.name
        }
    };
};

async function validateOrderParams({ order, accountAddress, wyvernExchange }) {
    // Check sell parameters
    const sellValid = await wyvernExchange.functions.validateOrderParameters_(
        [
            order.exchange,
            order.maker,
            order.taker,
            order.feeRecipient,
            order.target,
            order.staticTarget,
            order.paymentToken,
        ],
        [
            order.makerRelayerFee.toFixed(),
            order.takerRelayerFee.toFixed(),
            order.makerProtocolFee.toFixed(),
            order.takerProtocolFee.toFixed(),
            order.basePrice.toFixed(),
            order.extra.toFixed(),
            order.listingTime.toFixed(),
            order.expirationTime.toFixed(),
            order.salt.toFixed(),
        ],
        order.feeMethod,
        order.side,
        order.saleKind,
        order.howToCall,
        order.calldata,
        order.replacementPattern,
        order.staticExtradata
    );

    if (!sellValid) {
        console.error(order);
        throw new Error(`Failed to validate sell order parameters. Make sure you're on the right network!`);
    }

    return sellValid;
};

function getOrderHash(order) {
    const orderWithStringTypes = {
        ...order,
        maker: order.maker.toLowerCase(),
        taker: order.taker.toLowerCase(),
        feeRecipient: order.feeRecipient.toLowerCase(),
        side: order.side.toString(),
        saleKind: order.saleKind.toString(),
        howToCall: order.howToCall.toString(),
        feeMethod: order.feeMethod.toString(),
        makerRelayerFee: order.makerRelayerFee.toFixed(),
        takerRelayerFee: order.takerRelayerFee.toFixed(),
        basePrice: order.basePrice.toFixed(),
        extra: order.extra.toFixed()
    };

    return WyvernProtocol.getOrderHashHex(orderWithStringTypes);
};

async function authorizeOrder({ order, provider, nonce }) {
    // Sign order flow
    const signerAddress = order.maker;

    if (order.exchange === mainnetWyvernConfigByNetwork.wyvernExchangeContractAddress && order.hash) {
        const message = order.hash;
        return await personalSignAsync(provider, message, signerAddress);
    }

    // 2.3 Sign order flow using EIP-712
    // We need to manually specify each field because OS orders can contain unrelated data
    const orderForSigning = {
        maker: order.maker,
        exchange: order.exchange,
        taker: order.taker,
        makerRelayerFee: order.makerRelayerFee.toString(),
        takerRelayerFee: order.takerRelayerFee.toString(),
        makerProtocolFee: order.makerProtocolFee.toString(),
        takerProtocolFee: order.takerProtocolFee.toString(),
        feeRecipient: order.feeRecipient,
        feeMethod: order.feeMethod,
        side: order.side,
        saleKind: order.saleKind,
        target: order.target,
        howToCall: order.howToCall,
        calldata: order.calldata,
        replacementPattern: order.replacementPattern,
        staticTarget: order.staticTarget,
        staticExtradata: order.staticExtradata,
        paymentToken: order.paymentToken,
        basePrice: order.basePrice.toString(),
        extra: order.extra.toString(),
        listingTime: order.listingTime.toString(),
        expirationTime: order.expirationTime.toString(),
        salt: order.salt.toString(),
    };

    // We don't JSON.stringify as certain wallet providers sanitize this data
    // https://github.com/coinbase/coinbase-wallet-sdk/issues/60
    const message = {
        types: OrderTypesEIP712,
        domain: {
            name: WyvernDomainNameEIP712,
            version: WyvernDomainVersionEIP712,
            chainId: 1,
            verifyingContract: order.exchange
        },
        primaryType: "Order",
        message: { 
            ...orderForSigning, 
            nonce 
        }
    };

    const ecSignature = await signTypedDataAsync(
        provider,
        message,
        signerAddress
    );

    return { 
        ...ecSignature, 
        nonce 
    };
};

function getWyvernAsset(schema, asset, quantity) {
    const tokenId = asset.tokenId != null ? asset.tokenId.toString() : undefined;
    return schema.assetFromFields({
        ID: tokenId,
        Quantity: quantity.toString(),
        Address: asset.tokenAddress.toLowerCase(),
        Name: asset.name,
    });
};

async function computeFees({ 
    asset, 
    accountAddress,
    extraBountyBasisPoints = 0
}) {
    let openseaBuyerFeeBasisPoints = DEFAULT_BUYER_FEE_BASIS_POINTS;
    let openseaSellerFeeBasisPoints = DEFAULT_SELLER_FEE_BASIS_POINTS;
    let devBuyerFeeBasisPoints = 0;
    let devSellerFeeBasisPoints = 0;
    let transferFee = new BigNumber(0);
    let transferFeeTokenAddress = null;
    let maxTotalBountyBPS = DEFAULT_MAX_BOUNTY;

    asset.then(function(safeAsset) {
        let assetContract = safeAsset.assetContract;

        openseaBuyerFeeBasisPoints = +assetContract.openseaBuyerFeeBasisPoints;
        openseaSellerFeeBasisPoints = +assetContract.openseaSellerFeeBasisPoints;
        devBuyerFeeBasisPoints = +assetContract.devBuyerFeeBasisPoints;
        devSellerFeeBasisPoints = +assetContract.devSellerFeeBasisPoints;
        maxTotalBountyBPS = openseaSellerFeeBasisPoints;
        
        // Compute transferFrom fees (EXPERIMENTAL)
        // transferFee = safeAsset.transferFee ? new BigNumber(safeAsset.transferFee) : transferFee;
        // transferFeeTokenAddress = safeAsset.transferFeePaymentToken
        //     ? safeAsset.transferFeePaymentToken.address
        //     : transferFeeTokenAddress;
    });

    // Compute bounty
    const sellerBountyBasisPoints = extraBountyBasisPoints; // 0 if it's a buy order

    // Check that bounty is in range of the opensea fee
    const bountyTooLarge = sellerBountyBasisPoints + OPENSEA_SELLER_BOUNTY_BASIS_POINTS > maxTotalBountyBPS;

    if (sellerBountyBasisPoints > 0 && bountyTooLarge) {
        let errorMessage = `Total bounty exceeds the maximum for this asset type (${
            maxTotalBountyBPS / 100
        }%).`;

        if (maxTotalBountyBPS >= OPENSEA_SELLER_BOUNTY_BASIS_POINTS) {
            errorMessage += ` Remember that OpenSea will add ${
                OPENSEA_SELLER_BOUNTY_BASIS_POINTS / 100
            }% for referrers with OpenSea accounts!`;
        }

        throw new Error(errorMessage);
    }

    const totalBuyerFeeBasisPoints = openseaBuyerFeeBasisPoints + devBuyerFeeBasisPoints;
    const totalSellerFeeBasisPoints = openseaSellerFeeBasisPoints + devSellerFeeBasisPoints;

    return {
        totalBuyerFeeBasisPoints,
        totalSellerFeeBasisPoints,
        openseaBuyerFeeBasisPoints,
        openseaSellerFeeBasisPoints,
        devBuyerFeeBasisPoints,
        devSellerFeeBasisPoints,
        sellerBountyBasisPoints,
        transferFee,
        transferFeeTokenAddress,
    };
};

/**
 * Compute the `basePrice` and `extra` parameters to be used to price an order.
 * Also validates the expiration time and auction type.
 * @param tokenAddress Address of the ERC-20 token to use for trading.
 * Use the null address for ETH
 * @param expirationTime When the auction expires, or 0 if never.
 * @param startAmount The base value for the order, in the token's main units (e.g. ETH instead of wei)
 * @param endAmount The end value for the order, in the token's main units (e.g. ETH instead of wei). If unspecified, the order's `extra` attribute will be 0
 */
async function getPriceParameters(price) {
    const basePrice = new BigNumber(price);
    const extra = new BigNumber(price);

    return { basePrice, extra };
};

function getSellFeeParameters(
    totalBuyerFeeBasisPoints,
    totalSellerFeeBasisPoints,
    waitForHighestBid,
    sellerBountyBasisPoints = 0
)  {
    // just making basic check if fee is less than 100% and not negative
    _validateFees(totalBuyerFeeBasisPoints, totalSellerFeeBasisPoints);

    // Use buyer as the maker when it's an English auction, so Wyvern sets prices correctly
    const feeRecipient = waitForHighestBid ? WyvernProtocol.NULL_ADDRESS : OPENSEA_FEE_RECIPIENT;

    // Swap maker/taker fees when it's an English auction,
    // since these sell orders are takers not makers
    const makerRelayerFee = waitForHighestBid ? new BigNumber(totalBuyerFeeBasisPoints) : new BigNumber(totalSellerFeeBasisPoints);
    const takerRelayerFee = waitForHighestBid ? new BigNumber(totalSellerFeeBasisPoints) : new BigNumber(totalBuyerFeeBasisPoints);

    return {
        makerRelayerFee,
        takerRelayerFee,
        makerProtocolFee: new BigNumber(0),
        takerProtocolFee: new BigNumber(0),
        makerReferrerFee: new BigNumber(sellerBountyBasisPoints),
        feeRecipient,
        feeMethod: 1, // 0 protocol fee ,1 split fee
    };
};

async function personalSignAsync(provider, message, signerAddress) {
    return new Promise((resolve, reject) => {
        const callback = async (err, signature) => {
            if (err) reject(err);
            if (signature.error) {
                reject(signature.error.message);
            };

            resolve(parseSignatureHex(signature.result));

            // // console.log(result);
            // const d = signature.result;
            // let v = d.slice(-2);
            // let r = d.slice(2, -66);
            // let s = d.slice(-66, -2);

            // let actualsignature = v + r + s + '03';

            // // const dhs = await this.contractInstace.methods
            // //   .setApprovalForAll(OPERATOR_ADDRESS, true)
            // //   .send({ from: this.metamask.metaMaskAddress });
            // resolve(`0x${actualsignature}`);
        };

        // console.log(orderHex, metaMaskAddress);
        provider.sendAsync({
            method: "personal_sign",
            params: [message, signerAddress],
            from: signerAddress,
        }, callback);
    });
};

/**
 * Convert an order to JSON, hashing it as well if necessary
 * @param order order (hashed or unhashed)
 */
const orderToJSON = (order) => {
    const orderJSON = {
        exchange: order.exchange.toLowerCase(),
        maker: order.maker.toLowerCase(),
        taker: order.taker.toLowerCase(),
        makerRelayerFee: order.makerRelayerFee.toString(),
        takerRelayerFee: order.takerRelayerFee.toString(),
        makerProtocolFee: order.makerProtocolFee.toString(),
        takerProtocolFee: order.takerProtocolFee.toString(),
        makerReferrerFee: order.makerReferrerFee.toString(),
        feeMethod: order.feeMethod,
        feeRecipient: order.feeRecipient.toLowerCase(),
        side: order.side,
        saleKind: order.saleKind,
        target: order.target.toLowerCase(),
        howToCall: order.howToCall,
        calldata: order.calldata,
        replacementPattern: order.replacementPattern,
        staticTarget: order.staticTarget.toLowerCase(),
        staticExtradata: order.staticExtradata,
        paymentToken: order.paymentToken.toLowerCase(),
        quantity: order.quantity.toString(),
        basePrice: order.basePrice.toString(),
        extra: order.extra.toString(),
        createdTime: order.createdTime ? order.createdTime.toString() : undefined,
        listingTime: order.listingTime.toString(),
        expirationTime: order.expirationTime.toString(),
        salt: order.salt.toString(),

        metadata: order.metadata,

        v: order.v,
        r: order.r,
        s: order.s,
        nonce: order.nonce,
    };

    return orderJSON;
};

function _validateFees(totalBuyerFeeBasisPoints, totalSellerFeeBasisPoints) {
    const maxFeePercent = INVERSE_BASIS_POINT / 100;

    if (totalBuyerFeeBasisPoints > INVERSE_BASIS_POINT || totalSellerFeeBasisPoints > INVERSE_BASIS_POINT) {
        throw new Error(`Invalid buyer/seller fees: must be less than ${maxFeePercent}%`);
    }

    if (totalBuyerFeeBasisPoints < 0 || totalSellerFeeBasisPoints < 0) {
        throw new Error(`Invalid buyer/seller fees: must be at least 0%`);
    }
};

// Fetch and Prepare Asset from OpenSea
async function getAsset({ tokenAddress, tokenId }) {
    const { data } = await axios(`${OPENSEA_URL}asset/${tokenAddress}/${tokenId || 0}/`);
    return assetFromJSON(data);
}

function assetFromJSON(asset) {
    const isAnimated = asset.image_url && asset.image_url.endsWith(".gif");
    const isSvg = asset.image_url && asset.image_url.endsWith(".svg");
    const fromJSON = {
        tokenId: asset.token_id.toString(),
        tokenAddress: asset.asset_contract.address,
        name: asset.name,
        description: asset.description,
        owner: asset.owner,
        assetContract: assetContractFromJSON(asset.asset_contract),
        collection: collectionFromJSON(asset.collection),
        orders: asset.orders ? asset.orders.map(orderFromJSON) : null,
        sellOrders: asset.sell_orders ? asset.sell_orders.map(orderFromJSON) : null,
        buyOrders: asset.buy_orders ? asset.buy_orders.map(orderFromJSON) : null,

        isPresale: asset.is_presale,
        // Don't use previews if it's a special image
        imageUrl:
          isAnimated || isSvg
            ? asset.image_url
            : asset.image_preview_url || asset.image_url,
        imagePreviewUrl: asset.image_preview_url,
        imageUrlOriginal: asset.image_original_url,
        imageUrlThumbnail: asset.image_thumbnail_url,

        externalLink: asset.external_link,
        openseaLink: asset.permalink,
        traits: asset.traits,
        numSales: asset.num_sales,
        lastSale: asset.last_sale ? assetEventFromJSON(asset.last_sale) : null,
        backgroundColor: asset.background_color
          ? `#${asset.background_color}`
          : null,

        transferFee: asset.transfer_fee ? new BigNumber(asset.transfer_fee) : null,
        transferFeePaymentToken: asset.transfer_fee_payment_token
          ? tokenFromJSON(asset.transfer_fee_payment_token)
          : null
    };

    // If orders were included, put them in sell/buy order groups
    if (fromJSON.orders && !fromJSON.sellOrders) {
        fromJSON.sellOrders = fromJSON.orders.filter((o) => o.side === 1);
    }

    if (fromJSON.orders && !fromJSON.buyOrders) {
        fromJSON.buyOrders = fromJSON.orders.filter((o) => o.side === 0);
    }

    return fromJSON;
};

function orderFromJSON(order) {
    const createdDate = new Date(`${order.created_date}Z`);
    const fromJSON = {
        hash: order.order_hash || order.hash,
        cancelledOrFinalized: order.cancelled || order.finalized,
        markedInvalid: order.marked_invalid,
        metadata: order.metadata,
        quantity: new BigNumber(order.quantity || 1),
        exchange: order.exchange,
        makerAccount: order.maker,
        takerAccount: order.taker,

        // Use string address to conform to Wyvern Order schema
        maker: order.maker.address,
        taker: order.taker.address,
        makerRelayerFee: new BigNumber(order.maker_relayer_fee),
        takerRelayerFee: new BigNumber(order.taker_relayer_fee),
        makerProtocolFee: new BigNumber(order.maker_protocol_fee),
        takerProtocolFee: new BigNumber(order.taker_protocol_fee),
        makerReferrerFee: new BigNumber(order.maker_referrer_fee || 0),
        waitingForBestCounterOrder: order.fee_recipient.address === WyvernProtocol.NULL_ADDRESS,
        feeMethod: order.fee_method,
        feeRecipientAccount: order.fee_recipient,
        feeRecipient: order.fee_recipient.address,
        side: order.side,
        saleKind: order.sale_kind,
        target: order.target,
        howToCall: order.how_to_call,
        calldata: order.calldata,
        replacementPattern: order.replacement_pattern,
        staticTarget: order.static_target,
        staticExtradata: order.static_extradata,
        paymentToken: order.payment_token,
        basePrice: new BigNumber(order.base_price),
        extra: new BigNumber(order.extra),
        currentBounty: new BigNumber(order.current_bounty || 0),
        currentPrice: new BigNumber(order.current_price || 0),

        createdTime: new BigNumber(Math.round(createdDate.getTime() / 1000)),
        listingTime: new BigNumber(order.listing_time),
        expirationTime: new BigNumber(order.expiration_time),

        salt: new BigNumber(order.salt),
        v: parseInt(order.v),
        r: order.r,
        s: order.s,

        paymentTokenContract: order.payment_token_contract
          ? tokenFromJSON(order.payment_token_contract)
          : undefined,
        asset: order.asset,
        assetBundle: order.asset_bundle,
    };

    // Use client-side price calc, to account for buyer fee (not added by server) and latency
    fromJSON.currentPrice = estimateCurrentPrice(fromJSON);
    return fromJSON;
};

function assetContractFromJSON(assetContract) {
    return {
        name: assetContract.name,
        description: assetContract.description,
        type: assetContract.assetContract_type,
        schemaName: assetContract.schema_name,
        address: assetContract.address,
        tokenSymbol: assetContract.symbol,
        buyerFeeBasisPoints: +assetContract.buyer_fee_basis_points,
        sellerFeeBasisPoints: +assetContract.seller_fee_basis_points,
        openseaBuyerFeeBasisPoints: +assetContract.opensea_buyer_fee_basis_points,
        openseaSellerFeeBasisPoints: +assetContract.opensea_seller_fee_basis_points,
        devBuyerFeeBasisPoints: +assetContract.dev_buyer_fee_basis_points,
        devSellerFeeBasisPoints: +assetContract.dev_seller_fee_basis_points,
        imageUrl: assetContract.image_url,
        externalLink: assetContract.external_link,
        wikiLink: assetContract.wiki_link,
    };
};

function collectionFromJSON(collection) {
    const createdDate = new Date(`${collection.created_date}Z`);

    return {
        createdDate,
        name: collection.name,
        description: collection.description,
        slug: collection.slug,
        editors: collection.editors,
        hidden: collection.hidden,
        featured: collection.featured,
        featuredImageUrl: collection.featured_image_url,
        displayData: collection.display_data,
        paymentTokens: (collection.payment_tokens || []).map(tokenFromJSON),
        openseaBuyerFeeBasisPoints: +collection.opensea_buyer_fee_basis_points,
        openseaSellerFeeBasisPoints: +collection.opensea_seller_fee_basis_points,
        devBuyerFeeBasisPoints: +collection.dev_buyer_fee_basis_points,
        devSellerFeeBasisPoints: +collection.dev_seller_fee_basis_points,
        payoutAddress: collection.payout_address,
        imageUrl: collection.image_url,
        largeImageUrl: collection.large_image_url,
        stats: collection.stats,
        traitStats: collection.traits,
        externalLink: collection.external_url,
        wikiLink: collection.wiki_url,
    };
};

function assetEventFromJSON(assetEvent) {
    return {
        eventType: assetEvent.event_type,
        eventTimestamp: assetEvent.event_timestamp,
        auctionType: assetEvent.auction_type,
        totalPrice: assetEvent.total_price,
        transaction: assetEvent.transaction
          ? transactionFromJSON(assetEvent.transaction)
          : null,
        paymentToken: assetEvent.payment_token
          ? tokenFromJSON(assetEvent.payment_token)
          : null
    };
};

function tokenFromJSON(token) {
    const fromJSON = {
        name: token.name,
        symbol: token.symbol,
        decimals: token.decimals,
        address: token.address,
        imageUrl: token.image_url,
        ethPrice: token.eth_price,
        usdPrice: token.usd_price,
    };

    return fromJSON;
};

function transactionFromJSON(transaction) {
    return {
        fromAccount: accountFromJSON(transaction.from_account),
        toAccount: accountFromJSON(transaction.to_account),
        createdDate: new Date(`${transaction.created_date}Z`),
        modifiedDate: new Date(`${transaction.modified_date}Z`),
        transactionHash: transaction.transaction_hash,
        transactionIndex: transaction.transaction_index,
        blockNumber: transaction.block_number,
        blockHash: transaction.block_hash,
        timestamp: new Date(`${transaction.timestamp}Z`)
    };
};

function accountFromJSON(account) {
    const user = account.user;

    return {
        address: account.address,
        config: account.config,
        profileImgUrl: account.profile_img_url,
        user: user ? { username: user.username } : null
    };
};

export default createOrder;