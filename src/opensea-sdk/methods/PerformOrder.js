import { WyvernProtocol } from "wyvern-js";
import BigNumber from "bignumber.js";
import isValidAddress from "ethereumjs-util";

import { ERC721Schema } from "../WyvernSchema";
import { WyvernContract } from "../contracts";
import encodeSell from "../helpers/EncodeSell";
import encodeBuy from "../helpers/EncodeBuy";
import getTimeParameters from "../helpers/GetTimeParameters";
import estimateCurrentPrice from "../helpers/EstimateCurrentPrice";

import { NULL_BLOCK_HASH, OPENSEA_FEE_RECIPIENT, INVERSE_BASIS_POINT, MERKLE_VALIDATOR_MAINNET } from "../Constants";

const performOrder = async ({
    order,
    provider,
    accountAddress,
    recipientAddress,
    referrerAddress
}) => {
    console.info(`Account: ${accountAddress} | Recipient: ${recipientAddress} | Referrer: ${referrerAddress}`);

    // check if valid order
    const wyvernExchange = WyvernContract(provider);
    const isValid = await validateOrder({ order, accountAddress, wyvernExchange });

    const matchingOrder = makeMatchingOrder({
        order,
        accountAddress,
        recipientAddress: recipientAddress
    });

    const { buy, sell } = assignOrdersToSides(order, matchingOrder);
    const metadata = _getMetadata(order, referrerAddress);

    return await _atomicMatch({
        buy,
        sell,
        accountAddress,
        wyvernExchange,
        metadata
    });
};

async function validateOrder({ order, accountAddress, wyvernExchange }) {
    // Check sell parameters
    const sellValid = await wyvernExchange.functions.validateOrder_(
        [
            order.exchange,
            order.maker,
            order.taker,
            order.feeRecipient,
            order.target,
            order.staticTarget,
            order.paymentToken
        ],
        [
            250.0.toFixed(),
            0.0.toFixed(),
            order.makerProtocolFee,
            order.takerProtocolFee,
            0.0.toFixed(),
            0.0.toFixed(),
            order.listingTime,
            order.expirationTime,
            order.salt,
        ],
        order.feeMethod,
        order.side,
        order.saleKind,
        order.howToCall,
        order.calldata,
        order.replacementPattern,
        order.staticExtradata,
        order.v,
        order.r,
        order.s
    );

    if (!sellValid) {
        // eslint-disable-next-line no-throw-literal
        throw {
            message: new Error(`Failed to validate sell order parameters. It looks like this listing is invalid.`),
            code: "InvalidOrder",
        };
        // TODO: call order invalidate API
    }

    return sellValid;
};

function makeMatchingOrder({
    order,
    accountAddress,
    recipientAddress
}) {
    accountAddress = accountAddress.toLowerCase();
    recipientAddress = recipientAddress.toLowerCase();

    const computeOrderParams = () => {
        const shouldValidate = order.target === MERKLE_VALIDATOR_MAINNET;

        if ("asset" in order.metadata) {
            const schema = ERC721Schema; // currently supporting ERC721 only
            return order.side == 0 ? encodeSell(
                schema,
                order.metadata.asset,
                recipientAddress,
                shouldValidate ? order.target : undefined
            ) : encodeBuy(
                schema,
                order.metadata.asset,
                recipientAddress,
                shouldValidate ? order.target : undefined
            );
        } else {
            throw new Error("Invalid order metadata");
        }
    };

    const { target, calldata, replacementPattern } = computeOrderParams();
    const times = getTimeParameters(0);
    
    // Compat for matching buy orders that have fee recipient still on them
    const feeRecipient = OPENSEA_FEE_RECIPIENT; // Maybe NULLADDRESS
    const matchingOrder = {
        exchange: order.exchange,
        maker: accountAddress,
        taker: order.maker,
        quantity: order.quantity,
        makerRelayerFee: order.makerRelayerFee,
        takerRelayerFee: order.takerRelayerFee,
        makerProtocolFee: order.makerProtocolFee,
        takerProtocolFee: order.takerProtocolFee,
        makerReferrerFee: order.makerReferrerFee,
        waitingForBestCounterOrder: false,
        feeMethod: order.feeMethod,
        feeRecipient,
        side: (order.side + 1) % 2,
        saleKind: 0, // 0 fixed price 1 ducch aucion
        target,
        howToCall: order.howToCall,
        calldata,
        replacementPattern,
        staticTarget: WyvernProtocol.NULL_ADDRESS,
        staticExtradata: "0x",
        paymentToken: order.paymentToken,
        basePrice: order.basePrice,
        extra: BigNumber(0),
        listingTime: times.listingTime,
        expirationTime: times.expirationTime,
        salt: WyvernProtocol.generatePseudoRandomSalt(),
        metadata: order.metadata,
    };

    return matchingOrder;
};

function assignOrdersToSides(order, matchingOrder) {
    const isSellOrder = order.side == 1;

    let buy;
    let sell;

    if (!isSellOrder) {
        buy = order;
        sell = {
            ...matchingOrder,
            v: buy.v,
            r: buy.r,
            s: buy.s,
        };
    } else {
        sell = order;
        buy = {
            ...matchingOrder,
            v: sell.v,
            r: sell.r,
            s: sell.s,
        };
    }

    return { buy, sell };
};

const _getMetadata = (order, referrerAddress) => {
    const referrer = referrerAddress || order.metadata.referrerAddress;
    if (referrer && isValidAddress(referrer)) {
        return `0x000000000000000000000000${referrer.substr(2)}`;
    }
    return undefined;
};

const _correctGasAmount = (estimation) => {
    return Math.ceil(estimation * 1.01);
};

async function _atomicMatch({
    buy,
    sell,
    accountAddress,
    wyvernExchange,
    metadata = NULL_BLOCK_HASH,
}) {
    let value;

    if (buy.paymentToken == WyvernProtocol.NULL_ADDRESS) {
        value = await _getRequiredAmountForTakingSellOrder(sell, wyvernExchange);
    }

    const txnData = { from: accountAddress, value };

    const args = [
        [
            buy.exchange,
            buy.maker,
            buy.taker,
            buy.feeRecipient,
            buy.target,
            buy.staticTarget,
            buy.paymentToken,
            sell.exchange,
            sell.maker,
            sell.taker,
            sell.feeRecipient,
            sell.target,
            sell.staticTarget,
            sell.paymentToken,
        ],
        [
            250.0.toString(),
            0.0.toString(),
            buy.makerProtocolFee.toString(),
            buy.takerProtocolFee.toString(),
            0.0.toString(),
            buy.extra.toString(),
            buy.listingTime.toString(),
            buy.expirationTime.toString(),
            buy.salt.toString(),
            250.0.toString(),
            0.0.toString(),
            sell.makerProtocolFee.toString(),
            sell.takerProtocolFee.toString(),
            0.0.toString(),
            0.0.toString(),
            sell.listingTime.toString(),
            sell.expirationTime.toString(),
            sell.salt.toString(),
        ],
        [
            buy.feeMethod,
            buy.side,
            buy.saleKind,
            buy.howToCall,
            sell.feeMethod,
            sell.side,
            sell.saleKind,
            sell.howToCall,
        ],
        buy.calldata,
        sell.calldata,
        buy.replacementPattern,
        sell.replacementPattern,
        buy.staticExtradata,
        sell.staticExtradata,
        [buy.v || 0, sell.v || 0],
        [
            buy.r || NULL_BLOCK_HASH,
            buy.s || NULL_BLOCK_HASH,
            sell.r || NULL_BLOCK_HASH,
            sell.s || NULL_BLOCK_HASH,
            metadata,
        ]
    ];

    // const gasEstimate = await wyvernExchange.functions.estimateGasAsync(txnData);
    // txnData.gas = _correctGasAmount(gasEstimate);

    const atomicMatchMethod = wyvernExchange.functions.atomicMatch_(
        args[0],
        args[1],
        args[2],
        args[3],
        args[4],
        args[5],
        args[6],
        args[7],
        args[8],
        args[9],
        args[10],
        txnData
    ).then(res => {
        console.log(res)
    });

    return { atomicMatchMethod, txnData };
};

async function _getRequiredAmountForTakingSellOrder(sell, wyvernExchange) {
    const currentPrice = await getCurrentPrice(sell, wyvernExchange);
    const estimatedPrice = estimateCurrentPrice(sell);

    const maxPrice = BigNumber.max(currentPrice, estimatedPrice);

    // TODO Why is this not always a big number?
    sell.takerRelayerFee = BigNumber(sell.takerRelayerFee);
    const feePercentage = sell.takerRelayerFee.div(INVERSE_BASIS_POINT);
    const fee = feePercentage.times(maxPrice);

    return fee.plus(maxPrice); // use .ceil()
};

/**
 * Gets the price for the order using the contract
 * @param order The order to calculate the price for
 */
async function getCurrentPrice(order, wyvernExchange) {
    const currentPrice = await wyvernExchange.methods.calculateCurrentPrice_(
        [
            order.exchange,
            order.maker,
            order.taker,
            order.feeRecipient,
            order.target,
            order.staticTarget,
            order.paymentToken,
        ],
        [
            order.makerRelayerFee.toFixed(),
            order.takerRelayerFee.toFixed(),
            order.makerProtocolFee.toFixed(),
            order.takerProtocolFee.toFixed(),
            order.basePrice.toFixed(),
            order.extra.toFixed(),
            order.listingTime.toFixed(),
            order.expirationTime.toFixed(),
            order.salt.toFixed(),
        ],
        order.feeMethod,
        order.side,
        order.saleKind,
        order.howToCall,
        order.calldata,
        order.replacementPattern,
        order.staticExtradata
    );

    return currentPrice;
};

export default performOrder;