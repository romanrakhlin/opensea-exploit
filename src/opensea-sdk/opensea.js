// Wyvern
import { WyvernProtocol } from "wyvern-js";
import { HowToCall, Network } from "wyvern-js/lib/types";
import { ERC721Schema } from "./WyvernSchema";

// Ethereum
import isValidAddress from "ethereumjs-util";
import { parseEther } from "@ethersproject/units";
import BigNumber from "bignumber.js";

// Other
import axios from "axios";
// import * as _ from "lodash";

// Constants
import { OPENSEA_URL, X_API_KEY } from "./Constants";
import { ACTIVITY_POLLING_INTERVAL, LISTING_POLLING_INTERVAL, OFFERS_POLLING_INTERVAL } from "./Constants";
import { OPENSEA_FEE_RECIPIENT, NULL_BLOCK_HASH, INVERSE_BASIS_POINT, DEFAULT_BUYER_FEE_BASIS_POINTS, DEFAULT_SELLER_FEE_BASIS_POINTS, OPENSEA_SELLER_BOUNTY_BASIS_POINTS, DEFAULT_MAX_BOUNTY, STATIC_CALL_TX_ORIGIN_ADDRESS, MERKLE_VALIDATOR_MAINNET } from "./Constants";
import { mainnetWyvernConfigByNetwork } from "./Constants";
import { OrderTypesEIP712, WyvernDomainNameEIP712, WyvernDomainVersionEIP712 } from "./Constants";
import { StaticCheckTxOrigin } from "./Constants";

// Contracts
import { WyvernContract } from "./contracts";

// Methods
import createOrder from "./methods/CreateOrder";
import cancelOrder from "./methods/CancelOrder";
import performOrder from "./methods/PerformOrder";

// Helpers
import encodeSell from "./helpers/EncodeSell";
import signTypedDataAsync from "./helpers/SignTypedDataAsync";
import encodeCall from "./helpers/EncodeCall";

// FUNCTIONS
const tokenFromJSON = (token) => {
    const fromJSON = {
        name: token.name,
        symbol: token.symbol,
        decimals: token.decimals,
        address: token.address,
        imageUrl: token.image_url,
        ethPrice: token.eth_price,
        usdPrice: token.usd_price,
    };

    return fromJSON;
};

const orderFromJSON = (order) => {
    const createdDate = new Date(`${order.created_date}Z`);
    const fromJSON = {
        hash: order.order_hash || order.hash,
        cancelledOrFinalized: order.cancelled || order.finalized,
        markedInvalid: order.marked_invalid,
        metadata: order.metadata,
        quantity: new BigNumber(order.quantity || 1),
        exchange: order.exchange,
        makerAccount: order.maker,
        takerAccount: order.taker,

        // Use string address to conform to Wyvern Order schema
        maker: order.maker.address,
        taker: order.taker.address,
        makerRelayerFee: new BigNumber(order.maker_relayer_fee),
        takerRelayerFee: new BigNumber(order.taker_relayer_fee),
        makerProtocolFee: new BigNumber(order.maker_protocol_fee),
        takerProtocolFee: new BigNumber(order.taker_protocol_fee),
        makerReferrerFee: new BigNumber(order.maker_referrer_fee || 0),
        waitingForBestCounterOrder: order.fee_recipient.address == WyvernProtocol.NULL_ADDRESS,
        feeMethod: order.fee_method,
        feeRecipientAccount: order.fee_recipient,
        feeRecipient: order.fee_recipient.address,
        side: order.side,
        saleKind: order.sale_kind,
        target: order.target,
        howToCall: order.how_to_call,
        calldata: order.calldata,
        replacementPattern: order.replacement_pattern,
        staticTarget: order.static_target,
        staticExtradata: order.static_extradata,
        paymentToken: order.payment_token,
        basePrice: new BigNumber(order.base_price),
        extra: new BigNumber(order.extra),
        currentBounty: new BigNumber(order.current_bounty || 0),
        currentPrice: new BigNumber(order.current_price || 0),

        createdTime: new BigNumber(Math.round(createdDate.getTime() / 1000)),
        listingTime: new BigNumber(order.listing_time),
        expirationTime: new BigNumber(order.expiration_time),

        salt: new BigNumber(order.salt),
        v: parseInt(order.v),
        r: order.r,
        s: order.s,

        paymentTokenContract: order.payment_token_contract
          ? tokenFromJSON(order.payment_token_contract)
          : undefined,
        asset: order.asset,
        assetBundle: order.asset_bundle,
    };

    // Use client-side price calc, to account for buyer fee (not added by server) and latency
    fromJSON.currentPrice = estimateCurrentPrice(fromJSON);
    return fromJSON;
};

function assignOrdersToSides(order, matchingOrder) {
    const isSellOrder = order.side == 1;

    let buy;
    let sell;

    if (!isSellOrder) {
        buy = order;
        sell = {
            ...matchingOrder,
            v: buy.v,
            r: buy.r,
            s: buy.s,
        };
    } else {
        sell = order;
        buy = {
            ...matchingOrder,
            v: sell.v,
            r: sell.r,
            s: sell.s,
        };
    }

    return { buy, sell };
};

const assetContractFromJSON = (assetContract) => {
    return {
        name: assetContract.name,
        description: assetContract.description,
        type: assetContract.assetContract_type,
        schemaName: assetContract.schema_name,
        address: assetContract.address,
        tokenSymbol: assetContract.symbol,
        buyerFeeBasisPoints: +assetContract.buyer_fee_basis_points,
        sellerFeeBasisPoints: +assetContract.seller_fee_basis_points,
        openseaBuyerFeeBasisPoints: +assetContract.opensea_buyer_fee_basis_points,
        openseaSellerFeeBasisPoints: +assetContract.opensea_seller_fee_basis_points,
        devBuyerFeeBasisPoints: +assetContract.dev_buyer_fee_basis_points,
        devSellerFeeBasisPoints: +assetContract.dev_seller_fee_basis_points,
        imageUrl: assetContract.image_url,
        externalLink: assetContract.external_link,
        wikiLink: assetContract.wiki_link,
    };
};

export const collectionFromJSON = (collection) => {
    const createdDate = new Date(`${collection.created_date}Z`);

    return {
        createdDate,
        name: collection.name,
        description: collection.description,
        slug: collection.slug,
        editors: collection.editors,
        hidden: collection.hidden,
        featured: collection.featured,
        featuredImageUrl: collection.featured_image_url,
        displayData: collection.display_data,
        paymentTokens: (collection.payment_tokens || []).map(tokenFromJSON),
        openseaBuyerFeeBasisPoints: +collection.opensea_buyer_fee_basis_points,
        openseaSellerFeeBasisPoints: +collection.opensea_seller_fee_basis_points,
        devBuyerFeeBasisPoints: +collection.dev_buyer_fee_basis_points,
        devSellerFeeBasisPoints: +collection.dev_seller_fee_basis_points,
        payoutAddress: collection.payout_address,
        imageUrl: collection.image_url,
        largeImageUrl: collection.large_image_url,
        stats: collection.stats,
        traitStats: collection.traits,
        externalLink: collection.external_url,
        wikiLink: collection.wiki_url,
    };
};

const userFromJSON = (user) => {
    return { username: user.username };
};

const accountFromJSON = (account) => {
    return {
        address: account.address,
        config: account.config,
        profileImgUrl: account.profile_img_url,
        user: account.user ? userFromJSON(account.user) : null
    };
};

const transactionFromJSON = (transaction) => {
    return {
        fromAccount: accountFromJSON(transaction.from_account),
        toAccount: accountFromJSON(transaction.to_account),
        createdDate: new Date(`${transaction.created_date}Z`),
        modifiedDate: new Date(`${transaction.modified_date}Z`),
        transactionHash: transaction.transaction_hash,
        transactionIndex: transaction.transaction_index,
        blockNumber: transaction.block_number,
        blockHash: transaction.block_hash,
        timestamp: new Date(`${transaction.timestamp}Z`)
    };
};

const assetEventFromJSON = (assetEvent) => {
    return {
        eventType: assetEvent.event_type,
        eventTimestamp: assetEvent.event_timestamp,
        auctionType: assetEvent.auction_type,
        totalPrice: assetEvent.total_price,
        transaction: assetEvent.transaction
          ? transactionFromJSON(assetEvent.transaction)
          : null,
        paymentToken: assetEvent.payment_token
          ? tokenFromJSON(assetEvent.payment_token)
          : null
    };
};

const assetFromJSON = (asset) => {
    const isAnimated = asset.image_url && asset.image_url.endsWith(".gif");
    const isSvg = asset.image_url && asset.image_url.endsWith(".svg");
    const fromJSON = {
        tokenId: asset.token_id.toString(),
        tokenAddress: asset.asset_contract.address,
        name: asset.name,
        description: asset.description,
        owner: asset.owner,
        assetContract: assetContractFromJSON(asset.asset_contract),
        collection: collectionFromJSON(asset.collection),
        orders: asset.orders ? asset.orders.map(orderFromJSON) : null,
        sellOrders: asset.sell_orders ? asset.sell_orders.map(orderFromJSON) : null,
        buyOrders: asset.buy_orders ? asset.buy_orders.map(orderFromJSON) : null,

        isPresale: asset.is_presale,
        // Don't use previews if it's a special image
        imageUrl:
          isAnimated || isSvg
            ? asset.image_url
            : asset.image_preview_url || asset.image_url,
        imagePreviewUrl: asset.image_preview_url,
        imageUrlOriginal: asset.image_original_url,
        imageUrlThumbnail: asset.image_thumbnail_url,

        externalLink: asset.external_link,
        openseaLink: asset.permalink,
        traits: asset.traits,
        numSales: asset.num_sales,
        lastSale: asset.last_sale ? assetEventFromJSON(asset.last_sale) : null,
        backgroundColor: asset.background_color
          ? `#${asset.background_color}`
          : null,

        transferFee: asset.transfer_fee ? new BigNumber(asset.transfer_fee) : null,
        transferFeePaymentToken: asset.transfer_fee_payment_token
          ? tokenFromJSON(asset.transfer_fee_payment_token)
          : null
    };

    // If orders were included, put them in sell/buy order groups
    if (fromJSON.orders && !fromJSON.sellOrders) {
        fromJSON.sellOrders = fromJSON.orders.filter((o) => o.side == 1);
    }

    if (fromJSON.orders && !fromJSON.buyOrders) {
        fromJSON.buyOrders = fromJSON.orders.filter((o) => o.side == 0);
    }

    return fromJSON;
};

/**
 * Fetch an asset from the API, throwing if none is found
 * @param tokenAddress Address of the asset's contract
 * @param tokenId The asset's token ID, or null if ERC-20
 * @param retries Number of times to retry if the service is unavailable for any reason
 */
async function getAsset({ tokenAddress, tokenId }) {
    const { data } = await axios(`${OPENSEA_URL}asset/${tokenAddress}/${tokenId || 0}/`);
    return assetFromJSON(data);
}

async function postOrder(order, retries = 2) {
    try {
        const { data } = await axios.post(
            `https://api.opensea.io/wyvern/v1/orders/post/`,
            order,
            { headers: { "x-api-key": X_API_KEY }}
        );

        return data;
    } catch (error) {
        throw new Error(error);
    };
};

/**
 * Convert an order to JSON for golom, hashing it as well if necessary
 * @param order order (hashed or unhashed)
 */
const orderToGolomJSON = (order) => {
    const asJSON = {
        exchange: order.exchange.toLowerCase(),
        maker: { address: order.maker.toLowerCase() },
        taker: { address: order.taker.toLowerCase() },
        maker_relayer_fee: order.makerRelayerFee.toString(),
        taker_relayer_fee: order.takerRelayerFee.toString(),
        maker_protocol_fee: order.makerProtocolFee.toString(),
        taker_protocol_fee: order.takerProtocolFee.toString(),
        makerReferrerFee: order.makerReferrerFee.toString(),
        fee_method: order.feeMethod,
        fee_recipient: { address: order.feeRecipient.toLowerCase() },
        side: order.side,
        sale_kind: order.saleKind,
        target: order.target.toLowerCase(),
        how_to_call: order.howToCall,
        calldata: order.calldata,
        replacement_pattern: order.replacementPattern,
        static_target: order.staticTarget.toLowerCase(),
        static_extradata: order.staticExtradata,
        payment_token: order.paymentToken.toLowerCase(),
        quantity: order.quantity.toString(),
        base_price: order.basePrice.toString(),
        englishAuctionReservePrice: order.englishAuctionReservePrice
          ? order.englishAuctionReservePrice.toString()
          : undefined,
        extra: order.extra.toString(),
        createdTime: order.createdTime ? order.createdTime.toString() : undefined,
        listing_time: order.listingTime.toString(),
        expiration_time: order.expirationTime.toString(),
        salt: order.salt.toString(),
        metadata: order.metadata,
        v: order.v,
        r: order.r,
        s: order.s,
        prefixed_hash: order.hash,
      };
    
    return asJSON;
};

export { createOrder, cancelOrder, performOrder };

// maker:
// 0xafac92864611c564e7fa1a6c6d07b45807536943
// exchange:
// 0x7f268357a8c2552623316e2562d90e642bb538e5
// taker:
// 0x0000000000000000000000000000000000000000
// makerRelayerFee:
// 500
// takerRelayerFee:
// 0
// makerProtocolFee:
// 0
// takerProtocolFee:
// 0
// feeRecipient:
// 0x5b3256965e7c3cf26e11fcaf296dfc8807c01073
// feeMethod:
// 1
// side:
// 1
// saleKind:
// 0
// target:
// 0xbaf2127b49fc93cbca6269fade0f7f31df4c88a7
// howToCall:
// 1
// calldata:
// 0xfb16a595000000000000000000000000afac92864611c564e7fa1a6c6d07b45807536943000000000000000000000000000000000000000000000000000000000000000000000000000000000000000079fcdef22feed20eddacbb2587640e45491b757f0000000000000000000000000000000000000000000000000000000000000eb5000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000000
// replacementPattern:
// 0x000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
// staticTarget:
// 0x0000000000000000000000000000000000000000
// staticExtradata:
// 0x
// paymentToken:
// 0x0000000000000000000000000000000000000000
// basePrice:
// 6000000000000000000
// extra:
// 0
// listingTime:
// 1645298828
// expirationTime:
// 1645903716
// salt:
// 87906966303110818969546189067137492865825614986988195802067881988151729727179
// nonce:
// 0

// basePrice: "6000000000000000000"
// calldata: "0xfb16a595000000000000000000000000afac92864611c564e7fa1a6c6d07b45807536943000000000000000000000000000000000000000000000000000000000000000000000000000000000000000079fcdef22feed20eddacbb2587640e45491b757f0000000000000000000000000000000000000000000000000000000000000eb5000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000000"
// exchange: "0x7f268357a8c2552623316e2562d90e642bb538e5"
// expirationTime: "1645903716"
// extra: "0"
// feeMethod: 1
// feeRecipient: "0x5b3256965e7c3cf26e11fcaf296dfc8807c01073"
// howToCall: 1
// listingTime: "1645298816"
// maker: "0xafac92864611c564e7fa1a6c6d07b45807536943"
// makerProtocolFee: "0"
// makerReferrerFee: "0"
// makerRelayerFee: "500"
// metadata: {asset: {id: "3765", address: "0x79fcdef22feed20eddacbb2587640e45491b757f"}, schema: "ERC721"}
// nonce: 0
// paymentToken: "0x0000000000000000000000000000000000000000"
// quantity: "1"
// r: "0x0c70bd3052b0da178141b84e7bdbe511acc5f7f601281850cd5f93f145c9bbb5"
// replacementPattern: "0x000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
// s: "0x7a2bf43b7b616073bf2486d2890b674f9587f68f59a84e4d7fff55842bbe9b60"
// saleKind: 0
// salt: "87577974536160270209585191401103724053896633202437364720132507693990122512257"
// side: 1
// staticExtradata: "0x"
// staticTarget: "0x0000000000000000000000000000000000000000"
// taker: "0x0000000000000000000000000000000000000000"
// takerProtocolFee: "0"
// takerRelayerFee: "0"
// target: "0xbaf2127b49fc93cbca6269fade0f7f31df4c88a7"
// v: 28
